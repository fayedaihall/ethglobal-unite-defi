"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/near-api-js";
exports.ids = ["vendor-chunks/near-api-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/near-api-js/lib/account.js":
/*!*************************************************!*\
  !*** ./node_modules/near-api-js/lib/account.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Account = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nconst depd_1 = __importDefault(__webpack_require__(/*! depd */ \"(ssr)/./node_modules/depd/index.js\"));\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/near-api-js/lib/transaction.js\");\nconst providers_1 = __webpack_require__(/*! ./providers */ \"(ssr)/./node_modules/near-api-js/lib/providers/index.js\");\nconst borsh_1 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\nconst key_pair_1 = __webpack_require__(/*! ./utils/key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\nconst errors_1 = __webpack_require__(/*! ./utils/errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/errors.js\");\nconst rpc_errors_1 = __webpack_require__(/*! ./utils/rpc_errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/rpc_errors.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/near-api-js/lib/constants.js\");\nconst exponential_backoff_1 = __importDefault(__webpack_require__(/*! ./utils/exponential-backoff */ \"(ssr)/./node_modules/near-api-js/lib/utils/exponential-backoff.js\"));\n// Default number of retries with different nonce before giving up on a transaction.\nconst TX_NONCE_RETRY_NUMBER = 12;\n// Default wait until next retry in millis.\nconst TX_NONCE_RETRY_WAIT = 500;\n// Exponential back off for waiting to retry.\nconst TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;\nfunction parseJsonFromRawResponse(response) {\n    return JSON.parse(Buffer.from(response).toString());\n}\nfunction bytesJsonStringify(input) {\n    return Buffer.from(JSON.stringify(input));\n}\n/**\n * This class provides common account related RPC calls including signing transactions with a {@link utils/key_pair!KeyPair}.\n *\n * @hint Use {@link walletAccount!WalletConnection} in the browser to redirect to [NEAR Wallet](https://wallet.near.org/) for Account/key management using the {@link key_stores/browser_local_storage_key_store!BrowserLocalStorageKeyStore}.\n * @see [https://docs.near.org/docs/develop/front-end/naj-quick-reference#account](https://docs.near.org/tools/near-api-js/quick-reference#account)\n * @see [Account Spec](https://nomicon.io/DataStructures/Account.html)\n */\nclass Account {\n    constructor(connection, accountId) {\n        /** @hidden */\n        this.accessKeyByPublicKeyCache = {};\n        this.connection = connection;\n        this.accountId = accountId;\n    }\n    /**\n     * Returns basic NEAR account information via the `view_account` RPC query method\n     * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)\n     */\n    state() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.connection.provider.query({\n                request_type: 'view_account',\n                account_id: this.accountId,\n                finality: 'optimistic'\n            });\n        });\n    }\n    /** @hidden */\n    printLogsAndFailures(contractId, results) {\n        if (!process.env['NEAR_NO_LOGS']) {\n            for (const result of results) {\n                console.log(`Receipt${result.receiptIds.length > 1 ? 's' : ''}: ${result.receiptIds.join(', ')}`);\n                this.printLogs(contractId, result.logs, '\\t');\n                if (result.failure) {\n                    console.warn(`\\tFailure [${contractId}]: ${result.failure}`);\n                }\n            }\n        }\n    }\n    /** @hidden */\n    printLogs(contractId, logs, prefix = '') {\n        if (!process.env['NEAR_NO_LOGS']) {\n            for (const log of logs) {\n                console.log(`${prefix}Log [${contractId}]: ${log}`);\n            }\n        }\n    }\n    /**\n     * Create a signed transaction which can be broadcast to the network\n     * @param receiverId NEAR account receiving the transaction\n     * @param actions list of actions to perform as part of the transaction\n     * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}\n     */\n    signTransaction(receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKeyInfo = yield this.findAccessKey(receiverId, actions);\n            if (!accessKeyInfo) {\n                throw new providers_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, 'KeyNotFound');\n            }\n            const { accessKey } = accessKeyInfo;\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = block.header.hash;\n            const nonce = accessKey.nonce.add(new bn_js_1.default(1));\n            return yield (0, transaction_1.signTransaction)(receiverId, nonce, actions, (0, borsh_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);\n        });\n    }\n    /**\n     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.\n     * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}\n     */\n    signAndSendTransaction({ receiverId, actions, returnError }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let txHash, signedTx;\n            // TODO: TX_NONCE (different constants for different uses of exponentialBackoff?)\n            const result = yield (0, exponential_backoff_1.default)(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, () => __awaiter(this, void 0, void 0, function* () {\n                [txHash, signedTx] = yield this.signTransaction(receiverId, actions);\n                const publicKey = signedTx.transaction.publicKey;\n                try {\n                    return yield this.connection.provider.sendTransaction(signedTx);\n                }\n                catch (error) {\n                    if (error.type === 'InvalidNonce') {\n                        (0, errors_1.logWarning)(`Retrying transaction ${receiverId}:${(0, borsh_1.baseEncode)(txHash)} with new nonce.`);\n                        delete this.accessKeyByPublicKeyCache[publicKey.toString()];\n                        return null;\n                    }\n                    if (error.type === 'Expired') {\n                        (0, errors_1.logWarning)(`Retrying transaction ${receiverId}:${(0, borsh_1.baseEncode)(txHash)} due to expired block hash`);\n                        return null;\n                    }\n                    error.context = new providers_1.ErrorContext((0, borsh_1.baseEncode)(txHash));\n                    throw error;\n                }\n            }));\n            if (!result) {\n                // TODO: This should have different code actually, as means \"transaction not submitted for sure\"\n                throw new providers_1.TypedError('nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.', 'RetriesExceeded');\n            }\n            const flatLogs = [result.transaction_outcome, ...result.receipts_outcome].reduce((acc, it) => {\n                if (it.outcome.logs.length ||\n                    (typeof it.outcome.status === 'object' && typeof it.outcome.status.Failure === 'object')) {\n                    return acc.concat({\n                        'receiptIds': it.outcome.receipt_ids,\n                        'logs': it.outcome.logs,\n                        'failure': typeof it.outcome.status.Failure != 'undefined' ? (0, rpc_errors_1.parseRpcError)(it.outcome.status.Failure) : null\n                    });\n                }\n                else\n                    return acc;\n            }, []);\n            this.printLogsAndFailures(signedTx.transaction.receiverId, flatLogs);\n            // Should be falsy if result.status.Failure is null\n            if (!returnError && typeof result.status === 'object' && typeof result.status.Failure === 'object' && result.status.Failure !== null) {\n                // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n                if (result.status.Failure.error_message && result.status.Failure.error_type) {\n                    throw new providers_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);\n                }\n                else {\n                    throw (0, rpc_errors_1.parseResultError)(result);\n                }\n            }\n            // TODO: if Tx is Unknown or Started.\n            return result;\n        });\n    }\n    /**\n     * Finds the {@link providers/provider!AccessKeyView} associated with the accounts {@link utils/key_pair!PublicKey} stored in the {@link key_stores/keystore!KeyStore}.\n     *\n     * @todo Find matching access key based on transaction (i.e. receiverId and actions)\n     *\n     * @param receiverId currently unused (see todo)\n     * @param actions currently unused (see todo)\n     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    findAccessKey(receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Find matching access key based on transaction (i.e. receiverId and actions)\n            const publicKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n            if (!publicKey) {\n                throw new providers_1.TypedError(`no matching key pair found in ${this.connection.signer}`, 'PublicKeyNotFound');\n            }\n            const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];\n            if (cachedAccessKey !== undefined) {\n                return { publicKey, accessKey: cachedAccessKey };\n            }\n            try {\n                const rawAccessKey = yield this.connection.provider.query({\n                    request_type: 'view_access_key',\n                    account_id: this.accountId,\n                    public_key: publicKey.toString(),\n                    finality: 'optimistic'\n                });\n                // store nonce as BN to preserve precision on big number\n                const accessKey = Object.assign(Object.assign({}, rawAccessKey), { nonce: new bn_js_1.default(rawAccessKey.nonce) });\n                // this function can be called multiple times and retrieve the same access key\n                // this checks to see if the access key was already retrieved and cached while\n                // the above network call was in flight. To keep nonce values in line, we return\n                // the cached access key.\n                if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {\n                    return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };\n                }\n                this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;\n                return { publicKey, accessKey };\n            }\n            catch (e) {\n                if (e.type == 'AccessKeyDoesNotExist') {\n                    return null;\n                }\n                throw e;\n            }\n        });\n    }\n    /**\n     * Create a new account and deploy a contract to it\n     *\n     * @param contractId NEAR account where the contract is deployed\n     * @param publicKey The public key to add to the created contract account\n     * @param data The compiled contract code\n     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking\n     */\n    createAndDeployContract(contractId, publicKey, data, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKey = (0, transaction_1.fullAccessKey)();\n            yield this.signAndSendTransaction({\n                receiverId: contractId,\n                actions: [(0, transaction_1.createAccount)(), (0, transaction_1.transfer)(amount), (0, transaction_1.addKey)(key_pair_1.PublicKey.from(publicKey), accessKey), (0, transaction_1.deployContract)(data)]\n            });\n            const contractAccount = new Account(this.connection, contractId);\n            return contractAccount;\n        });\n    }\n    /**\n     * @param receiverId NEAR account receiving Ⓝ\n     * @param amount Amount to send in yoctoⓃ\n     */\n    sendMoney(receiverId, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId,\n                actions: [(0, transaction_1.transfer)(amount)]\n            });\n        });\n    }\n    /**\n     * @param newAccountId NEAR account name to be created\n     * @param publicKey A public key created from the masterAccount\n     */\n    createAccount(newAccountId, publicKey, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKey = (0, transaction_1.fullAccessKey)();\n            return this.signAndSendTransaction({\n                receiverId: newAccountId,\n                actions: [(0, transaction_1.createAccount)(), (0, transaction_1.transfer)(amount), (0, transaction_1.addKey)(key_pair_1.PublicKey.from(publicKey), accessKey)]\n            });\n        });\n    }\n    /**\n     * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted\n     */\n    deleteAccount(beneficiaryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!process.env['NEAR_NO_LOGS']) {\n                console.log('Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.');\n            }\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [(0, transaction_1.deleteAccount)(beneficiaryId)]\n            });\n        });\n    }\n    /**\n     * @param data The compiled contract code\n     */\n    deployContract(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [(0, transaction_1.deployContract)(data)]\n            });\n        });\n    }\n    /** @hidden */\n    encodeJSContractArgs(contractId, method, args) {\n        return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);\n    }\n    /**\n     * Execute function call\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    functionCall({ contractId, methodName, args = {}, gas = constants_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify, jsContract }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.validateArgs(args);\n            let functionCallArgs;\n            if (jsContract) {\n                const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));\n                functionCallArgs = ['call_js_contract', encodedArgs, gas, attachedDeposit, null, true];\n            }\n            else {\n                const stringifyArg = stringify === undefined ? transaction_1.stringifyJsonOrBytes : stringify;\n                functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];\n            }\n            return this.signAndSendTransaction({\n                receiverId: jsContract ? this.connection.jsvmAccountId : contractId,\n                // eslint-disable-next-line prefer-spread\n                actions: [transaction_1.functionCall.apply(void 0, functionCallArgs)],\n                walletMeta,\n                walletCallbackUrl\n            });\n        });\n    }\n    /**\n     * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)\n     * @todo expand this API to support more options.\n     * @param publicKey A public key to be associated with the contract\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.\n     * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n     */\n    addKey(publicKey, contractId, methodNames, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!methodNames) {\n                methodNames = [];\n            }\n            if (!Array.isArray(methodNames)) {\n                methodNames = [methodNames];\n            }\n            let accessKey;\n            if (!contractId) {\n                accessKey = (0, transaction_1.fullAccessKey)();\n            }\n            else {\n                accessKey = (0, transaction_1.functionCallAccessKey)(contractId, methodNames, amount);\n            }\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [(0, transaction_1.addKey)(key_pair_1.PublicKey.from(publicKey), accessKey)]\n            });\n        });\n    }\n    /**\n     * @param publicKey The public key to be deleted\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    deleteKey(publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [(0, transaction_1.deleteKey)(key_pair_1.PublicKey.from(publicKey))]\n            });\n        });\n    }\n    /**\n     * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)\n     *\n     * @param publicKey The public key for the account that's staking\n     * @param amount The account to stake in yoctoⓃ\n     */\n    stake(publicKey, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [(0, transaction_1.stake)(amount, key_pair_1.PublicKey.from(publicKey))]\n            });\n        });\n    }\n    /** @hidden */\n    validateArgs(args) {\n        const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;\n        if (isUint8Array) {\n            return;\n        }\n        if (Array.isArray(args) || typeof args !== 'object') {\n            throw new errors_1.PositionalArgsError();\n        }\n    }\n    /**\n     * Invoke a contract view function using the RPC API.\n     * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)\n     *\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n     * @param args Any arguments to the view contract method, wrapped in JSON\n     * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.\n     * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.\n     * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.\n     * @param options.blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     * @returns {Promise<any>}\n     */\n    viewFunction(...restArgs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof restArgs[0] === 'string') {\n                const contractId = restArgs[0];\n                const methodName = restArgs[1];\n                const args = restArgs[2];\n                const options = restArgs[3];\n                return yield this.viewFunctionV1(contractId, methodName, args, options);\n            }\n            else {\n                return yield this.viewFunctionV2(restArgs[0]);\n            }\n        });\n    }\n    viewFunctionV1(contractId, methodName, args = {}, { parse = parseJsonFromRawResponse, stringify = bytesJsonStringify, jsContract = false, blockQuery = { finality: 'optimistic' } } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const deprecate = (0, depd_1.default)('Account.viewFunction(contractId, methodName, args, options)');\n            deprecate('use `Account.viewFunction(ViewFunctionCallOptions)` instead');\n            return this.viewFunctionV2({ contractId, methodName, args, parse, stringify, jsContract, blockQuery });\n        });\n    }\n    viewFunctionV2({ contractId, methodName, args, parse = parseJsonFromRawResponse, stringify = bytesJsonStringify, jsContract = false, blockQuery = { finality: 'optimistic' } }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let encodedArgs;\n            this.validateArgs(args);\n            if (jsContract) {\n                encodedArgs = this.encodeJSContractArgs(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : '');\n            }\n            else {\n                encodedArgs = stringify(args);\n            }\n            const result = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: 'call_function' }, blockQuery), { account_id: jsContract ? this.connection.jsvmAccountId : contractId, method_name: jsContract ? 'view_js_contract' : methodName, args_base64: encodedArgs.toString('base64') }));\n            if (result.logs) {\n                this.printLogs(contractId, result.logs);\n            }\n            return result.result && result.result.length > 0 && parse(Buffer.from(result.result));\n        });\n    }\n    /**\n     * Returns the state (key value pairs) of this account's contract based on the key prefix.\n     * Pass an empty string for prefix if you would like to return the entire state.\n     * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)\n     *\n     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.\n     * @param blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     */\n    viewState(prefix, blockQuery = { finality: 'optimistic' }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { values } = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: 'view_state' }, blockQuery), { account_id: this.accountId, prefix_base64: Buffer.from(prefix).toString('base64') }));\n            return values.map(({ key, value }) => ({\n                key: Buffer.from(key, 'base64'),\n                value: Buffer.from(value, 'base64')\n            }));\n        });\n    }\n    /**\n     * Get all access keys for the account\n     * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)\n     */\n    getAccessKeys() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.connection.provider.query({\n                request_type: 'view_access_key_list',\n                account_id: this.accountId,\n                finality: 'optimistic'\n            });\n            // Replace raw nonce into a new BN\n            return (_a = response === null || response === void 0 ? void 0 : response.keys) === null || _a === void 0 ? void 0 : _a.map((key) => (Object.assign(Object.assign({}, key), { access_key: Object.assign(Object.assign({}, key.access_key), { nonce: new bn_js_1.default(key.access_key.nonce) }) })));\n        });\n    }\n    /**\n     * Returns a list of authorized apps\n     * @todo update the response value to return all the different keys, not just app keys.\n     */\n    getAccountDetails() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: update the response value to return all the different keys, not just app keys.\n            // Also if we need this function, or getAccessKeys is good enough.\n            const accessKeys = yield this.getAccessKeys();\n            const authorizedApps = accessKeys\n                .filter(item => item.access_key.permission !== 'FullAccess')\n                .map(item => {\n                const perm = item.access_key.permission;\n                return {\n                    contractId: perm.FunctionCall.receiver_id,\n                    amount: perm.FunctionCall.allowance,\n                    publicKey: item.public_key,\n                };\n            });\n            return { authorizedApps };\n        });\n    }\n    /**\n     * Returns calculated account balance\n     */\n    getAccountBalance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const protocolConfig = yield this.connection.provider.experimental_protocolConfig({ finality: 'final' });\n            const state = yield this.state();\n            const costPerByte = new bn_js_1.default(protocolConfig.runtime_config.storage_amount_per_byte);\n            const stateStaked = new bn_js_1.default(state.storage_usage).mul(costPerByte);\n            const staked = new bn_js_1.default(state.locked);\n            const totalBalance = new bn_js_1.default(state.amount).add(staked);\n            const availableBalance = totalBalance.sub(bn_js_1.default.max(staked, stateStaked));\n            return {\n                total: totalBalance.toString(),\n                stateStaked: stateStaked.toString(),\n                staked: staked.toString(),\n                available: availableBalance.toString()\n            };\n        });\n    }\n    /**\n     * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.\n     *\n     * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.\n     * @returns {Promise<ActiveDelegatedStakeBalance>}\n     */\n    getActiveDelegatedStakeBalance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = block.header.hash;\n            const epochId = block.header.epoch_id;\n            const { current_validators, next_validators, current_proposals } = yield this.connection.provider.validators(epochId);\n            const pools = new Set();\n            [...current_validators, ...next_validators, ...current_proposals]\n                .forEach((validator) => pools.add(validator.account_id));\n            const uniquePools = [...pools];\n            const promises = uniquePools\n                .map((validator) => (this.viewFunction({\n                contractId: validator,\n                methodName: 'get_account_total_balance',\n                args: { account_id: this.accountId },\n                blockQuery: { blockId: blockHash }\n            })));\n            const results = yield Promise.allSettled(promises);\n            const hasTimeoutError = results.some((result) => {\n                if (result.status === 'rejected' && result.reason.type === 'TimeoutError') {\n                    return true;\n                }\n                return false;\n            });\n            // When RPC is down and return timeout error, throw error\n            if (hasTimeoutError) {\n                throw new Error('Failed to get delegated stake balance');\n            }\n            const summary = results.reduce((result, state, index) => {\n                const validatorId = uniquePools[index];\n                if (state.status === 'fulfilled') {\n                    const currentBN = new bn_js_1.default(state.value);\n                    if (!currentBN.isZero()) {\n                        return Object.assign(Object.assign({}, result), { stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }], total: result.total.add(currentBN) });\n                    }\n                }\n                if (state.status === 'rejected') {\n                    return Object.assign(Object.assign({}, result), { failedValidators: [...result.failedValidators, { validatorId, error: state.reason }] });\n                }\n                return result;\n            }, { stakedValidators: [], failedValidators: [], total: new bn_js_1.default(0) });\n            return Object.assign(Object.assign({}, summary), { total: summary.total.toString() });\n        });\n    }\n}\nexports.Account = Account;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2FjY291bnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGdDQUFnQyxtQkFBTyxDQUFDLG1EQUFPO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLGdEQUFNO0FBQzdDLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFlO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFPO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFrQjtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3pDLDhDQUE4QyxtQkFBTyxDQUFDLHNHQUE2QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRiw2QkFBNkI7QUFDNUg7QUFDQSxjQUFjLHNDQUFzQyw0R0FBNEcsNkVBQTZFO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0NBQXdDLElBQUksNkJBQTZCO0FBQy9HO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVyxLQUFLLGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLE9BQU8sV0FBVyxLQUFLLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixnQkFBZ0IsYUFBYSwwQkFBMEI7QUFDako7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxpRUFBaUUsbUJBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVyxHQUFHLGlDQUFpQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxXQUFXLEdBQUcsaUNBQWlDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSwrQkFBK0IsVUFBVSxvQ0FBb0M7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQix3Q0FBd0MsOEJBQThCLGdDQUFnQyxlQUFlLG1DQUFtQztBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQiwwQkFBMEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsdUJBQXVCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdFQUFnRSxtQkFBbUIsZ0RBQWdEO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsbUJBQW1CLGlDQUFpQyxzSEFBc0g7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0RBQW9ELElBQUkscUdBQXFHLDJCQUEyQixJQUFJO0FBQzVMO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx3RUFBd0U7QUFDakgsU0FBUztBQUNUO0FBQ0EscUJBQXFCLG1JQUFtSSwwQkFBMEI7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLCtCQUErQixpQkFBaUIsNktBQTZLO0FBQzNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3QkFBd0I7QUFDN0Q7QUFDQSxvQkFBb0IsU0FBUyxxRUFBcUUsNEJBQTRCLGlCQUFpQixtRkFBbUY7QUFDbE8saUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0xBQWdMLFVBQVUsMENBQTBDLHFCQUFxQixrREFBa0QsR0FBRztBQUM5UyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csbUJBQW1CO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxtQkFBbUI7QUFDcEY7QUFDQTtBQUNBLG9CQUFvQix5REFBeUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQsOEJBQThCO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWEsaURBQWlELDJDQUEyQyx1Q0FBdUM7QUFDN007QUFDQTtBQUNBO0FBQ0EseURBQXlELGFBQWEsaURBQWlELGtDQUFrQyxHQUFHO0FBQzVKO0FBQ0E7QUFDQSxhQUFhLElBQUksMkVBQTJFO0FBQzVGLGlEQUFpRCxjQUFjLGlDQUFpQztBQUNoRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi9hY2NvdW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjY291bnQgPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBkZXBkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlcGRcIikpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnNcIik7XG5jb25zdCBib3JzaF8xID0gcmVxdWlyZShcImJvcnNoXCIpO1xuY29uc3Qga2V5X3BhaXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2tleV9wYWlyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi91dGlscy9lcnJvcnNcIik7XG5jb25zdCBycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiLi91dGlscy9ycGNfZXJyb3JzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBleHBvbmVudGlhbF9iYWNrb2ZmXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvZXhwb25lbnRpYWwtYmFja29mZlwiKSk7XG4vLyBEZWZhdWx0IG51bWJlciBvZiByZXRyaWVzIHdpdGggZGlmZmVyZW50IG5vbmNlIGJlZm9yZSBnaXZpbmcgdXAgb24gYSB0cmFuc2FjdGlvbi5cbmNvbnN0IFRYX05PTkNFX1JFVFJZX05VTUJFUiA9IDEyO1xuLy8gRGVmYXVsdCB3YWl0IHVudGlsIG5leHQgcmV0cnkgaW4gbWlsbGlzLlxuY29uc3QgVFhfTk9OQ0VfUkVUUllfV0FJVCA9IDUwMDtcbi8vIEV4cG9uZW50aWFsIGJhY2sgb2ZmIGZvciB3YWl0aW5nIHRvIHJldHJ5LlxuY29uc3QgVFhfTk9OQ0VfUkVUUllfV0FJVF9CQUNLT0ZGID0gMS41O1xuZnVuY3Rpb24gcGFyc2VKc29uRnJvbVJhd1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoQnVmZmVyLmZyb20ocmVzcG9uc2UpLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gYnl0ZXNKc29uU3RyaW5naWZ5KGlucHV0KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGlucHV0KSk7XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgY29tbW9uIGFjY291bnQgcmVsYXRlZCBSUEMgY2FsbHMgaW5jbHVkaW5nIHNpZ25pbmcgdHJhbnNhY3Rpb25zIHdpdGggYSB7QGxpbmsgdXRpbHMva2V5X3BhaXIhS2V5UGFpcn0uXG4gKlxuICogQGhpbnQgVXNlIHtAbGluayB3YWxsZXRBY2NvdW50IVdhbGxldENvbm5lY3Rpb259IGluIHRoZSBicm93c2VyIHRvIHJlZGlyZWN0IHRvIFtORUFSIFdhbGxldF0oaHR0cHM6Ly93YWxsZXQubmVhci5vcmcvKSBmb3IgQWNjb3VudC9rZXkgbWFuYWdlbWVudCB1c2luZyB0aGUge0BsaW5rIGtleV9zdG9yZXMvYnJvd3Nlcl9sb2NhbF9zdG9yYWdlX2tleV9zdG9yZSFCcm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmV9LlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvZGV2ZWxvcC9mcm9udC1lbmQvbmFqLXF1aWNrLXJlZmVyZW5jZSNhY2NvdW50XShodHRwczovL2RvY3MubmVhci5vcmcvdG9vbHMvbmVhci1hcGktanMvcXVpY2stcmVmZXJlbmNlI2FjY291bnQpXG4gKiBAc2VlIFtBY2NvdW50IFNwZWNdKGh0dHBzOi8vbm9taWNvbi5pby9EYXRhU3RydWN0dXJlcy9BY2NvdW50Lmh0bWwpXG4gKi9cbmNsYXNzIEFjY291bnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGFjY291bnRJZCkge1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLmFjY2Vzc0tleUJ5UHVibGljS2V5Q2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5hY2NvdW50SWQgPSBhY2NvdW50SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYmFzaWMgTkVBUiBhY2NvdW50IGluZm9ybWF0aW9uIHZpYSB0aGUgYHZpZXdfYWNjb3VudGAgUlBDIHF1ZXJ5IG1ldGhvZFxuICAgICAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cyN2aWV3LWFjY291bnRdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cyN2aWV3LWFjY291bnQpXG4gICAgICovXG4gICAgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X3R5cGU6ICd2aWV3X2FjY291bnQnLFxuICAgICAgICAgICAgICAgIGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGZpbmFsaXR5OiAnb3B0aW1pc3RpYydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcmludExvZ3NBbmRGYWlsdXJlcyhjb250cmFjdElkLCByZXN1bHRzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnZbJ05FQVJfTk9fTE9HUyddKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlY2VpcHQke3Jlc3VsdC5yZWNlaXB0SWRzLmxlbmd0aCA+IDEgPyAncycgOiAnJ306ICR7cmVzdWx0LnJlY2VpcHRJZHMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50TG9ncyhjb250cmFjdElkLCByZXN1bHQubG9ncywgJ1xcdCcpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFxcdEZhaWx1cmUgWyR7Y29udHJhY3RJZH1dOiAke3Jlc3VsdC5mYWlsdXJlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaW50TG9ncyhjb250cmFjdElkLCBsb2dzLCBwcmVmaXggPSAnJykge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52WydORUFSX05PX0xPR1MnXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke3ByZWZpeH1Mb2cgWyR7Y29udHJhY3RJZH1dOiAke2xvZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaWduZWQgdHJhbnNhY3Rpb24gd2hpY2ggY2FuIGJlIGJyb2FkY2FzdCB0byB0aGUgbmV0d29ya1xuICAgICAqIEBwYXJhbSByZWNlaXZlcklkIE5FQVIgYWNjb3VudCByZWNlaXZpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGFjdGlvbnMgbGlzdCBvZiBhY3Rpb25zIHRvIHBlcmZvcm0gYXMgcGFydCBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAc2VlIHtAbGluayBwcm92aWRlcnMvanNvbi1ycGMtcHJvdmlkZXIhSnNvblJwY1Byb3ZpZGVyI3NlbmRUcmFuc2FjdGlvbiB8IEpzb25ScGNQcm92aWRlci5zZW5kVHJhbnNhY3Rpb259XG4gICAgICovXG4gICAgc2lnblRyYW5zYWN0aW9uKHJlY2VpdmVySWQsIGFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleUluZm8gPSB5aWVsZCB0aGlzLmZpbmRBY2Nlc3NLZXkocmVjZWl2ZXJJZCwgYWN0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIWFjY2Vzc0tleUluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdmlkZXJzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBzaWduIHRyYW5zYWN0aW9ucyBmb3IgYWNjb3VudCAke3RoaXMuYWNjb3VudElkfSBvbiBuZXR3b3JrICR7dGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZH0sIG5vIG1hdGNoaW5nIGtleSBwYWlyIGV4aXN0cyBmb3IgdGhpcyBhY2NvdW50YCwgJ0tleU5vdEZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGFjY2Vzc0tleSB9ID0gYWNjZXNzS2V5SW5mbztcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLmJsb2NrKHsgZmluYWxpdHk6ICdmaW5hbCcgfSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0hhc2ggPSBibG9jay5oZWFkZXIuaGFzaDtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gYWNjZXNzS2V5Lm5vbmNlLmFkZChuZXcgYm5fanNfMS5kZWZhdWx0KDEpKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCAoMCwgdHJhbnNhY3Rpb25fMS5zaWduVHJhbnNhY3Rpb24pKHJlY2VpdmVySWQsIG5vbmNlLCBhY3Rpb25zLCAoMCwgYm9yc2hfMS5iYXNlRGVjb2RlKShibG9ja0hhc2gpLCB0aGlzLmNvbm5lY3Rpb24uc2lnbmVyLCB0aGlzLmFjY291bnRJZCwgdGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIGEgdHJhbnNhY3Rpb24gdG8gcHJlZm9ybSBhIGxpc3Qgb2YgYWN0aW9ucyBhbmQgYnJvYWRjYXN0IGl0IHVzaW5nIHRoZSBSUEMgQVBJLlxuICAgICAqIEBzZWUge0BsaW5rIHByb3ZpZGVycy9qc29uLXJwYy1wcm92aWRlciFKc29uUnBjUHJvdmlkZXIjc2VuZFRyYW5zYWN0aW9uIHwgSnNvblJwY1Byb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHsgcmVjZWl2ZXJJZCwgYWN0aW9ucywgcmV0dXJuRXJyb3IgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHR4SGFzaCwgc2lnbmVkVHg7XG4gICAgICAgICAgICAvLyBUT0RPOiBUWF9OT05DRSAoZGlmZmVyZW50IGNvbnN0YW50cyBmb3IgZGlmZmVyZW50IHVzZXMgb2YgZXhwb25lbnRpYWxCYWNrb2ZmPylcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkICgwLCBleHBvbmVudGlhbF9iYWNrb2ZmXzEuZGVmYXVsdCkoVFhfTk9OQ0VfUkVUUllfV0FJVCwgVFhfTk9OQ0VfUkVUUllfTlVNQkVSLCBUWF9OT05DRV9SRVRSWV9XQUlUX0JBQ0tPRkYsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBbdHhIYXNoLCBzaWduZWRUeF0gPSB5aWVsZCB0aGlzLnNpZ25UcmFuc2FjdGlvbihyZWNlaXZlcklkLCBhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBzaWduZWRUeC50cmFuc2FjdGlvbi5wdWJsaWNLZXk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICdJbnZhbGlkTm9uY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgZXJyb3JzXzEubG9nV2FybmluZykoYFJldHJ5aW5nIHRyYW5zYWN0aW9uICR7cmVjZWl2ZXJJZH06JHsoMCwgYm9yc2hfMS5iYXNlRW5jb2RlKSh0eEhhc2gpfSB3aXRoIG5ldyBub25jZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjY2Vzc0tleUJ5UHVibGljS2V5Q2FjaGVbcHVibGljS2V5LnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICdFeHBpcmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGVycm9yc18xLmxvZ1dhcm5pbmcpKGBSZXRyeWluZyB0cmFuc2FjdGlvbiAke3JlY2VpdmVySWR9OiR7KDAsIGJvcnNoXzEuYmFzZUVuY29kZSkodHhIYXNoKX0gZHVlIHRvIGV4cGlyZWQgYmxvY2sgaGFzaGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29udGV4dCA9IG5ldyBwcm92aWRlcnNfMS5FcnJvckNvbnRleHQoKDAsIGJvcnNoXzEuYmFzZUVuY29kZSkodHhIYXNoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgaGF2ZSBkaWZmZXJlbnQgY29kZSBhY3R1YWxseSwgYXMgbWVhbnMgXCJ0cmFuc2FjdGlvbiBub3Qgc3VibWl0dGVkIGZvciBzdXJlXCJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdmlkZXJzXzEuVHlwZWRFcnJvcignbm9uY2UgcmV0cmllcyBleGNlZWRlZCBmb3IgdHJhbnNhY3Rpb24uIFRoaXMgdXN1YWxseSBtZWFucyB0aGVyZSBhcmUgdG9vIG1hbnkgcGFyYWxsZWwgcmVxdWVzdHMgd2l0aCB0aGUgc2FtZSBhY2Nlc3Mga2V5LicsICdSZXRyaWVzRXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZsYXRMb2dzID0gW3Jlc3VsdC50cmFuc2FjdGlvbl9vdXRjb21lLCAuLi5yZXN1bHQucmVjZWlwdHNfb3V0Y29tZV0ucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm91dGNvbWUubG9ncy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBpdC5vdXRjb21lLnN0YXR1cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGl0Lm91dGNvbWUuc3RhdHVzLkZhaWx1cmUgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAncmVjZWlwdElkcyc6IGl0Lm91dGNvbWUucmVjZWlwdF9pZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9ncyc6IGl0Lm91dGNvbWUubG9ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYWlsdXJlJzogdHlwZW9mIGl0Lm91dGNvbWUuc3RhdHVzLkZhaWx1cmUgIT0gJ3VuZGVmaW5lZCcgPyAoMCwgcnBjX2Vycm9yc18xLnBhcnNlUnBjRXJyb3IpKGl0Lm91dGNvbWUuc3RhdHVzLkZhaWx1cmUpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgdGhpcy5wcmludExvZ3NBbmRGYWlsdXJlcyhzaWduZWRUeC50cmFuc2FjdGlvbi5yZWNlaXZlcklkLCBmbGF0TG9ncyk7XG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgZmFsc3kgaWYgcmVzdWx0LnN0YXR1cy5GYWlsdXJlIGlzIG51bGxcbiAgICAgICAgICAgIGlmICghcmV0dXJuRXJyb3IgJiYgdHlwZW9mIHJlc3VsdC5zdGF0dXMgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZXN1bHQuc3RhdHVzLkZhaWx1cmUgPT09ICdvYmplY3QnICYmIHJlc3VsdC5zdGF0dXMuRmFpbHVyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGVycm9yIGRhdGEgaGFzIGVycm9yX21lc3NhZ2UgYW5kIGVycm9yX3R5cGUgcHJvcGVydGllcywgd2UgY29uc2lkZXIgdGhhdCBub2RlIHJldHVybmVkIGFuIGVycm9yIGluIHRoZSBvbGQgZm9ybWF0XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMuRmFpbHVyZS5lcnJvcl9tZXNzYWdlICYmIHJlc3VsdC5zdGF0dXMuRmFpbHVyZS5lcnJvcl90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm92aWRlcnNfMS5UeXBlZEVycm9yKGBUcmFuc2FjdGlvbiAke3Jlc3VsdC50cmFuc2FjdGlvbl9vdXRjb21lLmlkfSBmYWlsZWQuICR7cmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX21lc3NhZ2V9YCwgcmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHJwY19lcnJvcnNfMS5wYXJzZVJlc3VsdEVycm9yKShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IGlmIFR4IGlzIFVua25vd24gb3IgU3RhcnRlZC5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUge0BsaW5rIHByb3ZpZGVycy9wcm92aWRlciFBY2Nlc3NLZXlWaWV3fSBhc3NvY2lhdGVkIHdpdGggdGhlIGFjY291bnRzIHtAbGluayB1dGlscy9rZXlfcGFpciFQdWJsaWNLZXl9IHN0b3JlZCBpbiB0aGUge0BsaW5rIGtleV9zdG9yZXMva2V5c3RvcmUhS2V5U3RvcmV9LlxuICAgICAqXG4gICAgICogQHRvZG8gRmluZCBtYXRjaGluZyBhY2Nlc3Mga2V5IGJhc2VkIG9uIHRyYW5zYWN0aW9uIChpLmUuIHJlY2VpdmVySWQgYW5kIGFjdGlvbnMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJJZCBjdXJyZW50bHkgdW51c2VkIChzZWUgdG9kbylcbiAgICAgKiBAcGFyYW0gYWN0aW9ucyBjdXJyZW50bHkgdW51c2VkIChzZWUgdG9kbylcbiAgICAgKiBAcmV0dXJucyBgeyBwdWJsaWNLZXkgUHVibGljS2V5OyBhY2Nlc3NLZXk6IEFjY2Vzc0tleVZpZXcgfWBcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZmluZEFjY2Vzc0tleShyZWNlaXZlcklkLCBhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBGaW5kIG1hdGNoaW5nIGFjY2VzcyBrZXkgYmFzZWQgb24gdHJhbnNhY3Rpb24gKGkuZS4gcmVjZWl2ZXJJZCBhbmQgYWN0aW9ucylcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5zaWduZXIuZ2V0UHVibGljS2V5KHRoaXMuYWNjb3VudElkLCB0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkKTtcbiAgICAgICAgICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3ZpZGVyc18xLlR5cGVkRXJyb3IoYG5vIG1hdGNoaW5nIGtleSBwYWlyIGZvdW5kIGluICR7dGhpcy5jb25uZWN0aW9uLnNpZ25lcn1gLCAnUHVibGljS2V5Tm90Rm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZEFjY2Vzc0tleSA9IHRoaXMuYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZVtwdWJsaWNLZXkudG9TdHJpbmcoKV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkQWNjZXNzS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwdWJsaWNLZXksIGFjY2Vzc0tleTogY2FjaGVkQWNjZXNzS2V5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0FjY2Vzc0tleSA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogJ3ZpZXdfYWNjZXNzX2tleScsXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpdHk6ICdvcHRpbWlzdGljJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIG5vbmNlIGFzIEJOIHRvIHByZXNlcnZlIHByZWNpc2lvbiBvbiBiaWcgbnVtYmVyXG4gICAgICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdBY2Nlc3NLZXkpLCB7IG5vbmNlOiBuZXcgYm5fanNfMS5kZWZhdWx0KHJhd0FjY2Vzc0tleS5ub25jZSkgfSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGFuZCByZXRyaWV2ZSB0aGUgc2FtZSBhY2Nlc3Mga2V5XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBhY2Nlc3Mga2V5IHdhcyBhbHJlYWR5IHJldHJpZXZlZCBhbmQgY2FjaGVkIHdoaWxlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFib3ZlIG5ldHdvcmsgY2FsbCB3YXMgaW4gZmxpZ2h0LiBUbyBrZWVwIG5vbmNlIHZhbHVlcyBpbiBsaW5lLCB3ZSByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FjaGVkIGFjY2VzcyBrZXkuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZVtwdWJsaWNLZXkudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHVibGljS2V5LCBhY2Nlc3NLZXk6IHRoaXMuYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZVtwdWJsaWNLZXkudG9TdHJpbmcoKV0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXSA9IGFjY2Vzc0tleTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwdWJsaWNLZXksIGFjY2Vzc0tleSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09ICdBY2Nlc3NLZXlEb2VzTm90RXhpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFjY291bnQgYW5kIGRlcGxveSBhIGNvbnRyYWN0IHRvIGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RJZCBORUFSIGFjY291bnQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgY29udHJhY3QgYWNjb3VudFxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBjb21waWxlZCBjb250cmFjdCBjb2RlXG4gICAgICogQHBhcmFtIGFtb3VudCBvZiBORUFSIHRvIHRyYW5zZmVyIHRvIHRoZSBjcmVhdGVkIGNvbnRyYWN0IGFjY291bnQuIFRyYW5zZmVyIGVub3VnaCB0byBwYXkgZm9yIHN0b3JhZ2UgaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvY29uY2VwdHMvc3RvcmFnZS1zdGFraW5nXG4gICAgICovXG4gICAgY3JlYXRlQW5kRGVwbG95Q29udHJhY3QoY29udHJhY3RJZCwgcHVibGljS2V5LCBkYXRhLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9ICgwLCB0cmFuc2FjdGlvbl8xLmZ1bGxBY2Nlc3NLZXkpKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IGNvbnRyYWN0SWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogWygwLCB0cmFuc2FjdGlvbl8xLmNyZWF0ZUFjY291bnQpKCksICgwLCB0cmFuc2FjdGlvbl8xLnRyYW5zZmVyKShhbW91bnQpLCAoMCwgdHJhbnNhY3Rpb25fMS5hZGRLZXkpKGtleV9wYWlyXzEuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSwgYWNjZXNzS2V5KSwgKDAsIHRyYW5zYWN0aW9uXzEuZGVwbG95Q29udHJhY3QpKGRhdGEpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdEFjY291bnQgPSBuZXcgQWNjb3VudCh0aGlzLmNvbm5lY3Rpb24sIGNvbnRyYWN0SWQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0QWNjb3VudDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSByZWNlaXZlcklkIE5FQVIgYWNjb3VudCByZWNlaXZpbmcg4pODXG4gICAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgdG8gc2VuZCBpbiB5b2N0b+KTg1xuICAgICAqL1xuICAgIHNlbmRNb25leShyZWNlaXZlcklkLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogWygwLCB0cmFuc2FjdGlvbl8xLnRyYW5zZmVyKShhbW91bnQpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbmV3QWNjb3VudElkIE5FQVIgYWNjb3VudCBuYW1lIHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IEEgcHVibGljIGtleSBjcmVhdGVkIGZyb20gdGhlIG1hc3RlckFjY291bnRcbiAgICAgKi9cbiAgICBjcmVhdGVBY2NvdW50KG5ld0FjY291bnRJZCwgcHVibGljS2V5LCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9ICgwLCB0cmFuc2FjdGlvbl8xLmZ1bGxBY2Nlc3NLZXkpKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiBuZXdBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogWygwLCB0cmFuc2FjdGlvbl8xLmNyZWF0ZUFjY291bnQpKCksICgwLCB0cmFuc2FjdGlvbl8xLnRyYW5zZmVyKShhbW91bnQpLCAoMCwgdHJhbnNhY3Rpb25fMS5hZGRLZXkpKGtleV9wYWlyXzEuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSwgYWNjZXNzS2V5KV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJlbmVmaWNpYXJ5SWQgVGhlIE5FQVIgYWNjb3VudCB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgcmVtYWluaW5nIOKTgyBiYWxhbmNlIGZyb20gdGhlIGFjY291bnQgYmVpbmcgZGVsZXRlZFxuICAgICAqL1xuICAgIGRlbGV0ZUFjY291bnQoYmVuZWZpY2lhcnlJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFwcm9jZXNzLmVudlsnTkVBUl9OT19MT0dTJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRGVsZXRpbmcgYW4gYWNjb3VudCBkb2VzIG5vdCBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyIE5GVHMgYW5kIEZUcyB0byB0aGUgYmVuZWZpY2lhcnkgYWRkcmVzcy4gRW5zdXJlIHRvIHRyYW5zZmVyIGFzc2V0cyBiZWZvcmUgZGVsZXRpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbKDAsIHRyYW5zYWN0aW9uXzEuZGVsZXRlQWNjb3VudCkoYmVuZWZpY2lhcnlJZCldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBjb21waWxlZCBjb250cmFjdCBjb2RlXG4gICAgICovXG4gICAgZGVwbG95Q29udHJhY3QoZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogWygwLCB0cmFuc2FjdGlvbl8xLmRlcGxveUNvbnRyYWN0KShkYXRhKV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBlbmNvZGVKU0NvbnRyYWN0QXJncyhjb250cmFjdElkLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKGNvbnRyYWN0SWQpLCBCdWZmZXIuZnJvbShbMF0pLCBCdWZmZXIuZnJvbShtZXRob2QpLCBCdWZmZXIuZnJvbShbMF0pLCBCdWZmZXIuZnJvbShhcmdzKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGZ1bmN0aW9uIGNhbGxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uQ2FsbCh7IGNvbnRyYWN0SWQsIG1ldGhvZE5hbWUsIGFyZ3MgPSB7fSwgZ2FzID0gY29uc3RhbnRzXzEuREVGQVVMVF9GVU5DVElPTl9DQUxMX0dBUywgYXR0YWNoZWREZXBvc2l0LCB3YWxsZXRNZXRhLCB3YWxsZXRDYWxsYmFja1VybCwgc3RyaW5naWZ5LCBqc0NvbnRyYWN0IH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVBcmdzKGFyZ3MpO1xuICAgICAgICAgICAgbGV0IGZ1bmN0aW9uQ2FsbEFyZ3M7XG4gICAgICAgICAgICBpZiAoanNDb250cmFjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWRBcmdzID0gdGhpcy5lbmNvZGVKU0NvbnRyYWN0QXJncyhjb250cmFjdElkLCBtZXRob2ROYW1lLCBKU09OLnN0cmluZ2lmeShhcmdzKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsQXJncyA9IFsnY2FsbF9qc19jb250cmFjdCcsIGVuY29kZWRBcmdzLCBnYXMsIGF0dGFjaGVkRGVwb3NpdCwgbnVsbCwgdHJ1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZnlBcmcgPSBzdHJpbmdpZnkgPT09IHVuZGVmaW5lZCA/IHRyYW5zYWN0aW9uXzEuc3RyaW5naWZ5SnNvbk9yQnl0ZXMgOiBzdHJpbmdpZnk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsQXJncyA9IFttZXRob2ROYW1lLCBhcmdzLCBnYXMsIGF0dGFjaGVkRGVwb3NpdCwgc3RyaW5naWZ5QXJnLCBmYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiBqc0NvbnRyYWN0ID8gdGhpcy5jb25uZWN0aW9uLmpzdm1BY2NvdW50SWQgOiBjb250cmFjdElkLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW3RyYW5zYWN0aW9uXzEuZnVuY3Rpb25DYWxsLmFwcGx5KHZvaWQgMCwgZnVuY3Rpb25DYWxsQXJncyldLFxuICAgICAgICAgICAgICAgIHdhbGxldE1ldGEsXG4gICAgICAgICAgICAgICAgd2FsbGV0Q2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2NvbmNlcHRzL2Jhc2ljcy9hY2NvdW50cy9hY2Nlc3Mta2V5c10oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2NvbmNlcHRzL2Jhc2ljcy9hY2NvdW50cy9hY2Nlc3Mta2V5cylcbiAgICAgKiBAdG9kbyBleHBhbmQgdGhpcyBBUEkgdG8gc3VwcG9ydCBtb3JlIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBBIHB1YmxpYyBrZXkgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSBjb250cmFjdElkIE5FQVIgYWNjb3VudCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gbWV0aG9kTmFtZXMgVGhlIG1ldGhvZCBuYW1lcyBvbiB0aGUgY29udHJhY3QgdGhhdCBzaG91bGQgYmUgYWxsb3dlZCB0byBiZSBjYWxsZWQuIFBhc3MgbnVsbCBmb3Igbm8gbWV0aG9kIG5hbWVzIGFuZCAnJyBvciBbXSBmb3IgYW55IG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcGFyYW0gYW1vdW50IFBheW1lbnQgaW4geW9jdG/ik4MgdGhhdCBpcyBzZW50IHRvIHRoZSBjb250cmFjdCBkdXJpbmcgdGhpcyBmdW5jdGlvbiBjYWxsXG4gICAgICovXG4gICAgYWRkS2V5KHB1YmxpY0tleSwgY29udHJhY3RJZCwgbWV0aG9kTmFtZXMsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFtZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWV0aG9kTmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZXMgPSBbbWV0aG9kTmFtZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFjY2Vzc0tleTtcbiAgICAgICAgICAgIGlmICghY29udHJhY3RJZCkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0tleSA9ICgwLCB0cmFuc2FjdGlvbl8xLmZ1bGxBY2Nlc3NLZXkpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NLZXkgPSAoMCwgdHJhbnNhY3Rpb25fMS5mdW5jdGlvbkNhbGxBY2Nlc3NLZXkpKGNvbnRyYWN0SWQsIG1ldGhvZE5hbWVzLCBhbW91bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogWygwLCB0cmFuc2FjdGlvbl8xLmFkZEtleSkoa2V5X3BhaXJfMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpLCBhY2Nlc3NLZXkpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IHRvIGJlIGRlbGV0ZWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fVxuICAgICAqL1xuICAgIGRlbGV0ZUtleShwdWJsaWNLZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFsoMCwgdHJhbnNhY3Rpb25fMS5kZWxldGVLZXkpKGtleV9wYWlyXzEuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgW2h0dHBzOi8vbmVhci1ub2Rlcy5pby92YWxpZGF0b3Ivc3Rha2luZy1hbmQtZGVsZWdhdGlvbl0oaHR0cHM6Ly9uZWFyLW5vZGVzLmlvL3ZhbGlkYXRvci9zdGFraW5nLWFuZC1kZWxlZ2F0aW9uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSBmb3IgdGhlIGFjY291bnQgdGhhdCdzIHN0YWtpbmdcbiAgICAgKiBAcGFyYW0gYW1vdW50IFRoZSBhY2NvdW50IHRvIHN0YWtlIGluIHlvY3Rv4pODXG4gICAgICovXG4gICAgc3Rha2UocHVibGljS2V5LCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFsoMCwgdHJhbnNhY3Rpb25fMS5zdGFrZSkoYW1vdW50LCBrZXlfcGFpcl8xLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSkpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHZhbGlkYXRlQXJncyhhcmdzKSB7XG4gICAgICAgIGNvbnN0IGlzVWludDhBcnJheSA9IGFyZ3MuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGFyZ3MuYnl0ZUxlbmd0aCA9PT0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChpc1VpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSB8fCB0eXBlb2YgYXJncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Qb3NpdGlvbmFsQXJnc0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlIGEgY29udHJhY3QgdmlldyBmdW5jdGlvbiB1c2luZyB0aGUgUlBDIEFQSS5cbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjY2FsbC1hLWNvbnRyYWN0LWZ1bmN0aW9uXShodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjY2FsbC1hLWNvbnRyYWN0LWZ1bmN0aW9uKVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0SWQgTkVBUiBhY2NvdW50IHdoZXJlIHRoZSBjb250cmFjdCBpcyBkZXBsb3llZFxuICAgICAqIEBwYXJhbSBtZXRob2ROYW1lIFRoZSB2aWV3LW9ubHkgbWV0aG9kIChubyBzdGF0ZSBtdXRhdGlvbnMpIG5hbWUgb24gdGhlIGNvbnRyYWN0IGFzIGl0IGlzIHdyaXR0ZW4gaW4gdGhlIGNvbnRyYWN0IGNvZGVcbiAgICAgKiBAcGFyYW0gYXJncyBBbnkgYXJndW1lbnRzIHRvIHRoZSB2aWV3IGNvbnRyYWN0IG1ldGhvZCwgd3JhcHBlZCBpbiBKU09OXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFyc2UgUGFyc2UgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbC4gUmVjZWl2ZXMgYSBCdWZmZXIgKGJ5dGVzIGFycmF5KSBhbmQgY29udmVydHMgaXQgdG8gYW55IG9iamVjdC4gQnkgZGVmYXVsdCByZXN1bHQgd2lsbCBiZSB0cmVhdGVkIGFzIGpzb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RyaW5naWZ5IENvbnZlcnQgaW5wdXQgYXJndW1lbnRzIGludG8gYSBieXRlcyBhcnJheS4gQnkgZGVmYXVsdCB0aGUgaW5wdXQgaXMgdHJlYXRlZCBhcyBhIEpTT04uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuanNDb250cmFjdCBJcyBjb250cmFjdCBmcm9tIEpTIFNESywgYXV0b21hdGljYWxseSBlbmNvZGVzIGFyZ3MgZnJvbSBKUyBTREsgdG8gYmluYXJ5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJsb2NrUXVlcnkgc3BlY2lmaWVzIHdoaWNoIGJsb2NrIHRvIHF1ZXJ5IHN0YXRlIGF0LiBCeSBkZWZhdWx0IHJldHVybnMgbGFzdCBcIm9wdGltaXN0aWNcIiBibG9jayAoaS5lLiBub3QgbmVjZXNzYXJpbHkgZmluYWxpemVkKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHZpZXdGdW5jdGlvbiguLi5yZXN0QXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN0QXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdElkID0gcmVzdEFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IHJlc3RBcmdzWzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSByZXN0QXJnc1syXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gcmVzdEFyZ3NbM107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudmlld0Z1bmN0aW9uVjEoY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgYXJncywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy52aWV3RnVuY3Rpb25WMihyZXN0QXJnc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aWV3RnVuY3Rpb25WMShjb250cmFjdElkLCBtZXRob2ROYW1lLCBhcmdzID0ge30sIHsgcGFyc2UgPSBwYXJzZUpzb25Gcm9tUmF3UmVzcG9uc2UsIHN0cmluZ2lmeSA9IGJ5dGVzSnNvblN0cmluZ2lmeSwganNDb250cmFjdCA9IGZhbHNlLCBibG9ja1F1ZXJ5ID0geyBmaW5hbGl0eTogJ29wdGltaXN0aWMnIH0gfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkZXByZWNhdGUgPSAoMCwgZGVwZF8xLmRlZmF1bHQpKCdBY2NvdW50LnZpZXdGdW5jdGlvbihjb250cmFjdElkLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRpb25zKScpO1xuICAgICAgICAgICAgZGVwcmVjYXRlKCd1c2UgYEFjY291bnQudmlld0Z1bmN0aW9uKFZpZXdGdW5jdGlvbkNhbGxPcHRpb25zKWAgaW5zdGVhZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld0Z1bmN0aW9uVjIoeyBjb250cmFjdElkLCBtZXRob2ROYW1lLCBhcmdzLCBwYXJzZSwgc3RyaW5naWZ5LCBqc0NvbnRyYWN0LCBibG9ja1F1ZXJ5IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlld0Z1bmN0aW9uVjIoeyBjb250cmFjdElkLCBtZXRob2ROYW1lLCBhcmdzLCBwYXJzZSA9IHBhcnNlSnNvbkZyb21SYXdSZXNwb25zZSwgc3RyaW5naWZ5ID0gYnl0ZXNKc29uU3RyaW5naWZ5LCBqc0NvbnRyYWN0ID0gZmFsc2UsIGJsb2NrUXVlcnkgPSB7IGZpbmFsaXR5OiAnb3B0aW1pc3RpYycgfSB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZW5jb2RlZEFyZ3M7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQXJncyhhcmdzKTtcbiAgICAgICAgICAgIGlmIChqc0NvbnRyYWN0KSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZEFyZ3MgPSB0aGlzLmVuY29kZUpTQ29udHJhY3RBcmdzKGNvbnRyYWN0SWQsIG1ldGhvZE5hbWUsIE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShhcmdzKSA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kZWRBcmdzID0gc3RyaW5naWZ5KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHJlcXVlc3RfdHlwZTogJ2NhbGxfZnVuY3Rpb24nIH0sIGJsb2NrUXVlcnkpLCB7IGFjY291bnRfaWQ6IGpzQ29udHJhY3QgPyB0aGlzLmNvbm5lY3Rpb24uanN2bUFjY291bnRJZCA6IGNvbnRyYWN0SWQsIG1ldGhvZF9uYW1lOiBqc0NvbnRyYWN0ID8gJ3ZpZXdfanNfY29udHJhY3QnIDogbWV0aG9kTmFtZSwgYXJnc19iYXNlNjQ6IGVuY29kZWRBcmdzLnRvU3RyaW5nKCdiYXNlNjQnKSB9KSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmxvZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50TG9ncyhjb250cmFjdElkLCByZXN1bHQubG9ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdCAmJiByZXN1bHQucmVzdWx0Lmxlbmd0aCA+IDAgJiYgcGFyc2UoQnVmZmVyLmZyb20ocmVzdWx0LnJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgKGtleSB2YWx1ZSBwYWlycykgb2YgdGhpcyBhY2NvdW50J3MgY29udHJhY3QgYmFzZWQgb24gdGhlIGtleSBwcmVmaXguXG4gICAgICogUGFzcyBhbiBlbXB0eSBzdHJpbmcgZm9yIHByZWZpeCBpZiB5b3Ugd291bGQgbGlrZSB0byByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZS5cbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjdmlldy1jb250cmFjdC1zdGF0ZV0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvY29udHJhY3RzI3ZpZXctY29udHJhY3Qtc3RhdGUpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJlZml4IGFsbG93cyB0byBmaWx0ZXIgd2hpY2gga2V5cyBzaG91bGQgYmUgcmV0dXJuZWQuIEVtcHR5IHByZWZpeCBtZWFucyBhbGwga2V5cy4gU3RyaW5nIHByZWZpeCBpcyB1dGYtOCBlbmNvZGVkLlxuICAgICAqIEBwYXJhbSBibG9ja1F1ZXJ5IHNwZWNpZmllcyB3aGljaCBibG9jayB0byBxdWVyeSBzdGF0ZSBhdC4gQnkgZGVmYXVsdCByZXR1cm5zIGxhc3QgXCJvcHRpbWlzdGljXCIgYmxvY2sgKGkuZS4gbm90IG5lY2Vzc2FyaWx5IGZpbmFsaXplZCkuXG4gICAgICovXG4gICAgdmlld1N0YXRlKHByZWZpeCwgYmxvY2tRdWVyeSA9IHsgZmluYWxpdHk6ICdvcHRpbWlzdGljJyB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlcyB9ID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHJlcXVlc3RfdHlwZTogJ3ZpZXdfc3RhdGUnIH0sIGJsb2NrUXVlcnkpLCB7IGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkLCBwcmVmaXhfYmFzZTY0OiBCdWZmZXIuZnJvbShwcmVmaXgpLnRvU3RyaW5nKCdiYXNlNjQnKSB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCgoeyBrZXksIHZhbHVlIH0pID0+ICh7XG4gICAgICAgICAgICAgICAga2V5OiBCdWZmZXIuZnJvbShrZXksICdiYXNlNjQnKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBhY2Nlc3Mga2V5cyBmb3IgdGhlIGFjY291bnRcbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9hY2Nlc3Mta2V5cyN2aWV3LWFjY2Vzcy1rZXktbGlzdF0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvYWNjZXNzLWtleXMjdmlldy1hY2Nlc3Mta2V5LWxpc3QpXG4gICAgICovXG4gICAgZ2V0QWNjZXNzS2V5cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIucXVlcnkoe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogJ3ZpZXdfYWNjZXNzX2tleV9saXN0JyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eTogJ29wdGltaXN0aWMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgcmF3IG5vbmNlIGludG8gYSBuZXcgQk5cbiAgICAgICAgICAgIHJldHVybiAoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uua2V5cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoa2V5KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBrZXkpLCB7IGFjY2Vzc19rZXk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwga2V5LmFjY2Vzc19rZXkpLCB7IG5vbmNlOiBuZXcgYm5fanNfMS5kZWZhdWx0KGtleS5hY2Nlc3Nfa2V5Lm5vbmNlKSB9KSB9KSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXV0aG9yaXplZCBhcHBzXG4gICAgICogQHRvZG8gdXBkYXRlIHRoZSByZXNwb25zZSB2YWx1ZSB0byByZXR1cm4gYWxsIHRoZSBkaWZmZXJlbnQga2V5cywgbm90IGp1c3QgYXBwIGtleXMuXG4gICAgICovXG4gICAgZ2V0QWNjb3VudERldGFpbHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB1cGRhdGUgdGhlIHJlc3BvbnNlIHZhbHVlIHRvIHJldHVybiBhbGwgdGhlIGRpZmZlcmVudCBrZXlzLCBub3QganVzdCBhcHAga2V5cy5cbiAgICAgICAgICAgIC8vIEFsc28gaWYgd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLCBvciBnZXRBY2Nlc3NLZXlzIGlzIGdvb2QgZW5vdWdoLlxuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5cyA9IHlpZWxkIHRoaXMuZ2V0QWNjZXNzS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXplZEFwcHMgPSBhY2Nlc3NLZXlzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uYWNjZXNzX2tleS5wZXJtaXNzaW9uICE9PSAnRnVsbEFjY2VzcycpXG4gICAgICAgICAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJtID0gaXRlbS5hY2Nlc3Nfa2V5LnBlcm1pc3Npb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RJZDogcGVybS5GdW5jdGlvbkNhbGwucmVjZWl2ZXJfaWQsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogcGVybS5GdW5jdGlvbkNhbGwuYWxsb3dhbmNlLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IGl0ZW0ucHVibGljX2tleSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBhdXRob3JpemVkQXBwcyB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYWxjdWxhdGVkIGFjY291bnQgYmFsYW5jZVxuICAgICAqL1xuICAgIGdldEFjY291bnRCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25maWcgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuZXhwZXJpbWVudGFsX3Byb3RvY29sQ29uZmlnKHsgZmluYWxpdHk6ICdmaW5hbCcgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHlpZWxkIHRoaXMuc3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvc3RQZXJCeXRlID0gbmV3IGJuX2pzXzEuZGVmYXVsdChwcm90b2NvbENvbmZpZy5ydW50aW1lX2NvbmZpZy5zdG9yYWdlX2Ftb3VudF9wZXJfYnl0ZSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZVN0YWtlZCA9IG5ldyBibl9qc18xLmRlZmF1bHQoc3RhdGUuc3RvcmFnZV91c2FnZSkubXVsKGNvc3RQZXJCeXRlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWtlZCA9IG5ldyBibl9qc18xLmRlZmF1bHQoc3RhdGUubG9ja2VkKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQmFsYW5jZSA9IG5ldyBibl9qc18xLmRlZmF1bHQoc3RhdGUuYW1vdW50KS5hZGQoc3Rha2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZUJhbGFuY2UgPSB0b3RhbEJhbGFuY2Uuc3ViKGJuX2pzXzEuZGVmYXVsdC5tYXgoc3Rha2VkLCBzdGF0ZVN0YWtlZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3RhbDogdG90YWxCYWxhbmNlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3RhdGVTdGFrZWQ6IHN0YXRlU3Rha2VkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3Rha2VkOiBzdGFrZWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGU6IGF2YWlsYWJsZUJhbGFuY2UudG9TdHJpbmcoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5FQVIgdG9rZW5zIGJhbGFuY2UgYW5kIHZhbGlkYXRvcnMgb2YgYSBnaXZlbiBhY2NvdW50IHRoYXQgaXMgZGVsZWdhdGVkIHRvIHRoZSBzdGFraW5nIHBvb2xzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIHZhbGlkYXRvcnMgc2V0IGluIHRoZSBjdXJyZW50IGVwb2NoLlxuICAgICAqXG4gICAgICogTk9URTogSWYgdGhlIHRva2VucyBhcmUgZGVsZWdhdGVkIHRvIGEgc3Rha2luZyBwb29sIHRoYXQgaXMgY3VycmVudGx5IG9uIHBhdXNlIG9yIGRvZXMgbm90IGhhdmUgZW5vdWdoIHRva2VucyB0byBwYXJ0aWNpcGF0ZSBpbiB2YWxpZGF0aW9uLCB0aGV5IHdvbid0IGJlIGFjY291bnRlZCBmb3IuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWN0aXZlRGVsZWdhdGVkU3Rha2VCYWxhbmNlPn1cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVEZWxlZ2F0ZWRTdGFrZUJhbGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gYmxvY2suaGVhZGVyLmhhc2g7XG4gICAgICAgICAgICBjb25zdCBlcG9jaElkID0gYmxvY2suaGVhZGVyLmVwb2NoX2lkO1xuICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50X3ZhbGlkYXRvcnMsIG5leHRfdmFsaWRhdG9ycywgY3VycmVudF9wcm9wb3NhbHMgfSA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci52YWxpZGF0b3JzKGVwb2NoSWQpO1xuICAgICAgICAgICAgY29uc3QgcG9vbHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBbLi4uY3VycmVudF92YWxpZGF0b3JzLCAuLi5uZXh0X3ZhbGlkYXRvcnMsIC4uLmN1cnJlbnRfcHJvcG9zYWxzXVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKCh2YWxpZGF0b3IpID0+IHBvb2xzLmFkZCh2YWxpZGF0b3IuYWNjb3VudF9pZCkpO1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlUG9vbHMgPSBbLi4ucG9vbHNdO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB1bmlxdWVQb29sc1xuICAgICAgICAgICAgICAgIC5tYXAoKHZhbGlkYXRvcikgPT4gKHRoaXMudmlld0Z1bmN0aW9uKHtcbiAgICAgICAgICAgICAgICBjb250cmFjdElkOiB2YWxpZGF0b3IsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogJ2dldF9hY2NvdW50X3RvdGFsX2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHsgYWNjb3VudF9pZDogdGhpcy5hY2NvdW50SWQgfSxcbiAgICAgICAgICAgICAgICBibG9ja1F1ZXJ5OiB7IGJsb2NrSWQ6IGJsb2NrSGFzaCB9XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gICAgICAgICAgICBjb25zdCBoYXNUaW1lb3V0RXJyb3IgPSByZXN1bHRzLnNvbWUoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnICYmIHJlc3VsdC5yZWFzb24udHlwZSA9PT0gJ1RpbWVvdXRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2hlbiBSUEMgaXMgZG93biBhbmQgcmV0dXJuIHRpbWVvdXQgZXJyb3IsIHRocm93IGVycm9yXG4gICAgICAgICAgICBpZiAoaGFzVGltZW91dEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGRlbGVnYXRlZCBzdGFrZSBiYWxhbmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gcmVzdWx0cy5yZWR1Y2UoKHJlc3VsdCwgc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9ySWQgPSB1bmlxdWVQb29sc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJOID0gbmV3IGJuX2pzXzEuZGVmYXVsdChzdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudEJOLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB7IHN0YWtlZFZhbGlkYXRvcnM6IFsuLi5yZXN1bHQuc3Rha2VkVmFsaWRhdG9ycywgeyB2YWxpZGF0b3JJZCwgYW1vdW50OiBjdXJyZW50Qk4udG9TdHJpbmcoKSB9XSwgdG90YWw6IHJlc3VsdC50b3RhbC5hZGQoY3VycmVudEJOKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIHsgZmFpbGVkVmFsaWRhdG9yczogWy4uLnJlc3VsdC5mYWlsZWRWYWxpZGF0b3JzLCB7IHZhbGlkYXRvcklkLCBlcnJvcjogc3RhdGUucmVhc29uIH1dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgeyBzdGFrZWRWYWxpZGF0b3JzOiBbXSwgZmFpbGVkVmFsaWRhdG9yczogW10sIHRvdGFsOiBuZXcgYm5fanNfMS5kZWZhdWx0KDApIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3VtbWFyeSksIHsgdG90YWw6IHN1bW1hcnkudG90YWwudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50ID0gQWNjb3VudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/account_creator.js":
/*!*********************************************************!*\
  !*** ./node_modules/near-api-js/lib/account_creator.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = void 0;\nconst web_1 = __webpack_require__(/*! ./utils/web */ \"(ssr)/./node_modules/near-api-js/lib/utils/web.js\");\n/**\n * Account creator provides an interface for implementations to actually create accounts\n */\nclass AccountCreator {\n}\nexports.AccountCreator = AccountCreator;\nclass LocalAccountCreator extends AccountCreator {\n    constructor(masterAccount, initialBalance) {\n        super();\n        this.masterAccount = masterAccount;\n        this.initialBalance = initialBalance;\n    }\n    /**\n     * Creates an account using a masterAccount, meaning the new account is created from an existing account\n     * @param newAccountId The name of the NEAR account to be created\n     * @param publicKey The public key from the masterAccount used to create this account\n     * @returns {Promise<void>}\n     */\n    createAccount(newAccountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);\n        });\n    }\n}\nexports.LocalAccountCreator = LocalAccountCreator;\nclass UrlAccountCreator extends AccountCreator {\n    constructor(connection, helperUrl) {\n        super();\n        this.connection = connection;\n        this.helperUrl = helperUrl;\n    }\n    /**\n     * Creates an account using a helperUrl\n     * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository\n     * @param newAccountId The name of the NEAR account to be created\n     * @param publicKey The public key from the masterAccount used to create this account\n     * @returns {Promise<void>}\n     */\n    createAccount(newAccountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield (0, web_1.fetchJson)(`${this.helperUrl}/account`, JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }));\n        });\n    }\n}\nexports.UrlAccountCreator = UrlAccountCreator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2FjY291bnRfY3JlYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCO0FBQ2hGLGNBQWMsbUJBQU8sQ0FBQyxzRUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZSw0QkFBNEIseURBQXlEO0FBQzlJLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIvYWNjb3VudF9jcmVhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVybEFjY291bnRDcmVhdG9yID0gZXhwb3J0cy5Mb2NhbEFjY291bnRDcmVhdG9yID0gZXhwb3J0cy5BY2NvdW50Q3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IHdlYl8xID0gcmVxdWlyZShcIi4vdXRpbHMvd2ViXCIpO1xuLyoqXG4gKiBBY2NvdW50IGNyZWF0b3IgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBpbXBsZW1lbnRhdGlvbnMgdG8gYWN0dWFsbHkgY3JlYXRlIGFjY291bnRzXG4gKi9cbmNsYXNzIEFjY291bnRDcmVhdG9yIHtcbn1cbmV4cG9ydHMuQWNjb3VudENyZWF0b3IgPSBBY2NvdW50Q3JlYXRvcjtcbmNsYXNzIExvY2FsQWNjb3VudENyZWF0b3IgZXh0ZW5kcyBBY2NvdW50Q3JlYXRvciB7XG4gICAgY29uc3RydWN0b3IobWFzdGVyQWNjb3VudCwgaW5pdGlhbEJhbGFuY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXN0ZXJBY2NvdW50ID0gbWFzdGVyQWNjb3VudDtcbiAgICAgICAgdGhpcy5pbml0aWFsQmFsYW5jZSA9IGluaXRpYWxCYWxhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFjY291bnQgdXNpbmcgYSBtYXN0ZXJBY2NvdW50LCBtZWFuaW5nIHRoZSBuZXcgYWNjb3VudCBpcyBjcmVhdGVkIGZyb20gYW4gZXhpc3RpbmcgYWNjb3VudFxuICAgICAqIEBwYXJhbSBuZXdBY2NvdW50SWQgVGhlIG5hbWUgb2YgdGhlIE5FQVIgYWNjb3VudCB0byBiZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSBmcm9tIHRoZSBtYXN0ZXJBY2NvdW50IHVzZWQgdG8gY3JlYXRlIHRoaXMgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGNyZWF0ZUFjY291bnQobmV3QWNjb3VudElkLCBwdWJsaWNLZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubWFzdGVyQWNjb3VudC5jcmVhdGVBY2NvdW50KG5ld0FjY291bnRJZCwgcHVibGljS2V5LCB0aGlzLmluaXRpYWxCYWxhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2NhbEFjY291bnRDcmVhdG9yID0gTG9jYWxBY2NvdW50Q3JlYXRvcjtcbmNsYXNzIFVybEFjY291bnRDcmVhdG9yIGV4dGVuZHMgQWNjb3VudENyZWF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGhlbHBlclVybCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmhlbHBlclVybCA9IGhlbHBlclVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhY2NvdW50IHVzaW5nIGEgaGVscGVyVXJsXG4gICAgICogVGhpcyBpcyBbaG9zdGVkIGhlcmVdKGh0dHBzOi8vaGVscGVyLm5lYXJwcm90b2NvbC5jb20pIG9yIHNldCB1cCBsb2NhbGx5IHdpdGggdGhlIFtuZWFyLWNvbnRyYWN0LWhlbHBlcl0oaHR0cHM6Ly9naXRodWIuY29tL25lYXJwcm90b2NvbC9uZWFyLWNvbnRyYWN0LWhlbHBlcikgcmVwb3NpdG9yeVxuICAgICAqIEBwYXJhbSBuZXdBY2NvdW50SWQgVGhlIG5hbWUgb2YgdGhlIE5FQVIgYWNjb3VudCB0byBiZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSBmcm9tIHRoZSBtYXN0ZXJBY2NvdW50IHVzZWQgdG8gY3JlYXRlIHRoaXMgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGNyZWF0ZUFjY291bnQobmV3QWNjb3VudElkLCBwdWJsaWNLZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkICgwLCB3ZWJfMS5mZXRjaEpzb24pKGAke3RoaXMuaGVscGVyVXJsfS9hY2NvdW50YCwgSlNPTi5zdHJpbmdpZnkoeyBuZXdBY2NvdW50SWQsIG5ld0FjY291bnRQdWJsaWNLZXk6IHB1YmxpY0tleS50b1N0cmluZygpIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5VcmxBY2NvdW50Q3JlYXRvciA9IFVybEFjY291bnRDcmVhdG9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/account_creator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/account_multisig.js":
/*!**********************************************************!*\
  !*** ./node_modules/near-api-js/lib/account_multisig.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Account2FA = exports.AccountMultisig = exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/near-api-js/lib/account.js\");\nconst format_1 = __webpack_require__(/*! ./utils/format */ \"(ssr)/./node_modules/near-api-js/lib/utils/format.js\");\nconst key_pair_1 = __webpack_require__(/*! ./utils/key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/near-api-js/lib/transaction.js\");\nconst providers_1 = __webpack_require__(/*! ./providers */ \"(ssr)/./node_modules/near-api-js/lib/providers/index.js\");\nconst web_1 = __webpack_require__(/*! ./utils/web */ \"(ssr)/./node_modules/near-api-js/lib/utils/web.js\");\nexports.MULTISIG_STORAGE_KEY = '__multisigRequest';\nexports.MULTISIG_ALLOWANCE = new bn_js_1.default((0, format_1.parseNearAmount)('1'));\n// TODO: Different gas value for different requests (can reduce gas usage dramatically)\nexports.MULTISIG_GAS = new bn_js_1.default('100000000000000');\nexports.MULTISIG_DEPOSIT = new bn_js_1.default('0');\nexports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];\nexports.MULTISIG_CONFIRM_METHODS = ['confirm'];\nvar MultisigDeleteRequestRejectionError;\n(function (MultisigDeleteRequestRejectionError) {\n    MultisigDeleteRequestRejectionError[\"CANNOT_DESERIALIZE_STATE\"] = \"Cannot deserialize the contract state\";\n    MultisigDeleteRequestRejectionError[\"MULTISIG_NOT_INITIALIZED\"] = \"Smart contract panicked: Multisig contract should be initialized before usage\";\n    MultisigDeleteRequestRejectionError[\"NO_SUCH_REQUEST\"] = \"Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'\";\n    MultisigDeleteRequestRejectionError[\"REQUEST_COOLDOWN_ERROR\"] = \"Request cannot be deleted immediately after creation.\";\n    MultisigDeleteRequestRejectionError[\"METHOD_NOT_FOUND\"] = \"Contract method is not found\";\n})(MultisigDeleteRequestRejectionError = exports.MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = {}));\nvar MultisigStateStatus;\n(function (MultisigStateStatus) {\n    MultisigStateStatus[MultisigStateStatus[\"INVALID_STATE\"] = 0] = \"INVALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"STATE_NOT_INITIALIZED\"] = 1] = \"STATE_NOT_INITIALIZED\";\n    MultisigStateStatus[MultisigStateStatus[\"VALID_STATE\"] = 2] = \"VALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"UNKNOWN_STATE\"] = 3] = \"UNKNOWN_STATE\";\n})(MultisigStateStatus = exports.MultisigStateStatus || (exports.MultisigStateStatus = {}));\nvar MultisigCodeStatus;\n(function (MultisigCodeStatus) {\n    MultisigCodeStatus[MultisigCodeStatus[\"INVALID_CODE\"] = 0] = \"INVALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"VALID_CODE\"] = 1] = \"VALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"UNKNOWN_CODE\"] = 2] = \"UNKNOWN_CODE\";\n})(MultisigCodeStatus || (MultisigCodeStatus = {}));\n// in memory request cache for node w/o localStorage\nconst storageFallback = {\n    [exports.MULTISIG_STORAGE_KEY]: null\n};\nclass AccountMultisig extends account_1.Account {\n    constructor(connection, accountId, options) {\n        super(connection, accountId);\n        this.storage = options.storage;\n        this.onAddRequestResult = options.onAddRequestResult;\n    }\n    signAndSendTransactionWithAccount(receiverId, actions) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            return _super.signAndSendTransaction.call(this, { receiverId, actions });\n        });\n    }\n    signAndSendTransaction({ receiverId, actions }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const args = Buffer.from(JSON.stringify({\n                request: {\n                    receiver_id: receiverId,\n                    actions: convertActions(actions, accountId, receiverId)\n                }\n            }));\n            let result;\n            try {\n                result = yield _super.signAndSendTransaction.call(this, {\n                    receiverId: accountId,\n                    actions: [\n                        (0, transaction_1.functionCall)('add_request_and_confirm', args, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)\n                    ]\n                });\n            }\n            catch (e) {\n                if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {\n                    yield this.deleteUnconfirmedRequests();\n                    return yield this.signAndSendTransaction({ receiverId, actions });\n                }\n                throw e;\n            }\n            // TODO: Are following even needed? Seems like it throws on error already\n            if (!result.status) {\n                throw new Error('Request failed');\n            }\n            const status = Object.assign({}, result.status);\n            if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {\n                throw new Error('Request failed');\n            }\n            this.setRequest({\n                accountId,\n                actions,\n                requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)\n            });\n            if (this.onAddRequestResult) {\n                yield this.onAddRequestResult(result);\n            }\n            // NOTE there is no await on purpose to avoid blocking for 2fa\n            this.deleteUnconfirmedRequests();\n            return result;\n        });\n    }\n    /*\n     * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state\n     * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.\n     * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.\n     */\n    checkMultisigCodeAndStateStatus(contractBytes) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const u32_max = 4294967295;\n            const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;\n            try {\n                if (contractBytes) {\n                    yield _super.signAndSendTransaction.call(this, {\n                        receiverId: this.accountId, actions: [\n                            (0, transaction_1.deployContract)(contractBytes),\n                            (0, transaction_1.functionCall)('delete_request', { request_id: u32_max }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)\n                        ]\n                    });\n                }\n                else {\n                    yield this.deleteRequest(u32_max);\n                }\n                return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: MultisigStateStatus.VALID_STATE };\n            }\n            catch (e) {\n                if (new RegExp(MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.INVALID_STATE };\n                }\n                else if (new RegExp(MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.STATE_NOT_INITIALIZED };\n                }\n                else if (new RegExp(MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.VALID_STATE };\n                }\n                else if (new RegExp(MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {\n                    // not reachable if transaction included a deploy\n                    return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: MultisigStateStatus.UNKNOWN_STATE };\n                }\n                throw e;\n            }\n        });\n    }\n    deleteRequest(request_id) {\n        return super.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [(0, transaction_1.functionCall)('delete_request', { request_id }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n        });\n    }\n    deleteAllRequests() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request_ids = yield this.getRequestIds();\n            if (request_ids.length) {\n                yield Promise.all(request_ids.map((id) => this.deleteRequest(id)));\n            }\n        });\n    }\n    deleteUnconfirmedRequests() {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Delete in batch, don't delete unexpired\n            // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)\n            const request_ids = yield this.getRequestIds();\n            const { requestId } = this.getRequest();\n            for (const requestIdToDelete of request_ids) {\n                if (requestIdToDelete == requestId) {\n                    continue;\n                }\n                try {\n                    yield _super.signAndSendTransaction.call(this, {\n                        receiverId: this.accountId,\n                        actions: [(0, transaction_1.functionCall)('delete_request', { request_id: requestIdToDelete }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n                    });\n                }\n                catch (e) {\n                    console.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');\n                }\n            }\n        });\n    }\n    // helpers\n    getRequestIds() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Read requests from state to allow filtering by expiration time\n            // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84\n            return this.viewFunction(this.accountId, 'list_request_ids');\n        });\n    }\n    getRequest() {\n        if (this.storage) {\n            return JSON.parse(this.storage.getItem(exports.MULTISIG_STORAGE_KEY) || '{}');\n        }\n        return storageFallback[exports.MULTISIG_STORAGE_KEY];\n    }\n    setRequest(data) {\n        if (this.storage) {\n            return this.storage.setItem(exports.MULTISIG_STORAGE_KEY, JSON.stringify(data));\n        }\n        storageFallback[exports.MULTISIG_STORAGE_KEY] = data;\n    }\n}\nexports.AccountMultisig = AccountMultisig;\nclass Account2FA extends AccountMultisig {\n    constructor(connection, accountId, options) {\n        super(connection, accountId, options);\n        this.helperUrl = 'https://helper.testnet.near.org';\n        this.helperUrl = options.helperUrl || this.helperUrl;\n        this.storage = options.storage;\n        this.sendCode = options.sendCode || this.sendCodeDefault;\n        this.getCode = options.getCode || this.getCodeDefault;\n        this.verifyCode = options.verifyCode || this.verifyCodeDefault;\n        this.onConfirmResult = options.onConfirmResult;\n    }\n    /**\n     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.\n     * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}\n     */\n    signAndSendTransaction({ receiverId, actions }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.signAndSendTransaction.call(this, { receiverId, actions });\n            // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?\n            yield this.sendCode();\n            const result = yield this.promptAndVerify();\n            if (this.onConfirmResult) {\n                yield this.onConfirmResult(result);\n            }\n            return result;\n        });\n    }\n    // default helpers for CH deployments of multisig\n    deployMultisig(contractBytes) {\n        const _super = Object.create(null, {\n            signAndSendTransactionWithAccount: { get: () => super.signAndSendTransactionWithAccount }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const seedOrLedgerKey = (yield this.getRecoveryMethods()).data\n                .filter(({ kind, publicKey }) => (kind === 'phrase' || kind === 'ledger') && publicKey !== null)\n                .map((rm) => rm.publicKey);\n            const fak2lak = (yield this.getAccessKeys())\n                .filter(({ public_key, access_key: { permission } }) => permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key))\n                .map((ak) => ak.public_key)\n                .map(toPK);\n            const confirmOnlyKey = toPK((yield this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n            const newArgs = Buffer.from(JSON.stringify({ 'num_confirmations': 2 }));\n            const actions = [\n                ...fak2lak.map((pk) => (0, transaction_1.deleteKey)(pk)),\n                ...fak2lak.map((pk) => (0, transaction_1.addKey)(pk, (0, transaction_1.functionCallAccessKey)(accountId, exports.MULTISIG_CHANGE_METHODS, null))),\n                (0, transaction_1.addKey)(confirmOnlyKey, (0, transaction_1.functionCallAccessKey)(accountId, exports.MULTISIG_CONFIRM_METHODS, null)),\n                (0, transaction_1.deployContract)(contractBytes),\n            ];\n            const newFunctionCallActionBatch = actions.concat((0, transaction_1.functionCall)('new', newArgs, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT));\n            console.log('deploying multisig contract for', accountId);\n            const { stateStatus: multisigStateStatus } = yield this.checkMultisigCodeAndStateStatus(contractBytes);\n            switch (multisigStateStatus) {\n                case MultisigStateStatus.STATE_NOT_INITIALIZED:\n                    return yield _super.signAndSendTransactionWithAccount.call(this, accountId, newFunctionCallActionBatch);\n                case MultisigStateStatus.VALID_STATE:\n                    return yield _super.signAndSendTransactionWithAccount.call(this, accountId, actions);\n                case MultisigStateStatus.INVALID_STATE:\n                    throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState');\n                default:\n                    throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n            }\n        });\n    }\n    disableWithFAK({ contractBytes, cleanupContractBytes }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cleanupActions = [];\n            if (cleanupContractBytes) {\n                yield this.deleteAllRequests().catch(e => e);\n                cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes);\n            }\n            const keyConversionActions = yield this.get2faDisableKeyConversionActions();\n            const actions = [\n                ...cleanupActions,\n                ...keyConversionActions,\n                (0, transaction_1.deployContract)(contractBytes)\n            ];\n            const accessKeyInfo = yield this.findAccessKey(this.accountId, actions);\n            if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== 'FullAccess') {\n                throw new providers_1.TypedError('No full access key found in keystore. Unable to bypass multisig', 'NoFAKFound');\n            }\n            return this.signAndSendTransactionWithAccount(this.accountId, actions);\n        });\n    }\n    get2faDisableCleanupActions(cleanupContractBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentAccountState = yield this.viewState('').catch(error => {\n                const cause = error.cause && error.cause.name;\n                if (cause == 'NO_CONTRACT_CODE') {\n                    return [];\n                }\n                throw cause == 'TOO_LARGE_CONTRACT_STATE'\n                    ? new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState')\n                    : error;\n            });\n            const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString('base64'));\n            return currentAccountState.length ? [\n                (0, transaction_1.deployContract)(cleanupContractBytes),\n                (0, transaction_1.functionCall)('clean', { keys: currentAccountStateKeys }, exports.MULTISIG_GAS, new bn_js_1.default('0'))\n            ] : [];\n        });\n    }\n    get2faDisableKeyConversionActions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const accessKeys = yield this.getAccessKeys();\n            const lak2fak = accessKeys\n                .filter(({ access_key }) => access_key.permission !== 'FullAccess')\n                .filter(({ access_key }) => {\n                const perm = access_key.permission.FunctionCall;\n                return perm.receiver_id === accountId &&\n                    perm.method_names.length === 4 &&\n                    perm.method_names.includes('add_request_and_confirm');\n            });\n            const confirmOnlyKey = key_pair_1.PublicKey.from((yield this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n            return [\n                (0, transaction_1.deleteKey)(confirmOnlyKey),\n                ...lak2fak.map(({ public_key }) => (0, transaction_1.deleteKey)(key_pair_1.PublicKey.from(public_key))),\n                ...lak2fak.map(({ public_key }) => (0, transaction_1.addKey)(key_pair_1.PublicKey.from(public_key), (0, transaction_1.fullAccessKey)()))\n            ];\n        });\n    }\n    /**\n     * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)\n     * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}\n     * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-cleanup/res/state_cleanup.wasm?raw=true}\n     */\n    disable(contractBytes, cleanupContractBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { stateStatus } = yield this.checkMultisigCodeAndStateStatus();\n            if (stateStatus !== MultisigStateStatus.VALID_STATE && stateStatus !== MultisigStateStatus.STATE_NOT_INITIALIZED) {\n                throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n            }\n            let deleteAllRequestsError;\n            yield this.deleteAllRequests().catch(e => deleteAllRequestsError = e);\n            const cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes).catch(e => {\n                if (e.type === 'ContractHasExistingState') {\n                    throw deleteAllRequestsError || e;\n                }\n                throw e;\n            });\n            const actions = [\n                ...cleanupActions,\n                ...(yield this.get2faDisableKeyConversionActions()),\n                (0, transaction_1.deployContract)(contractBytes),\n            ];\n            console.log('disabling 2fa for', this.accountId);\n            return yield this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions\n            });\n        });\n    }\n    sendCodeDefault() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const { requestId } = this.getRequest();\n            const method = yield this.get2faMethod();\n            yield this.postSignedJson('/2fa/send', {\n                accountId,\n                method,\n                requestId,\n            });\n            return requestId;\n        });\n    }\n    getCodeDefault() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is \"email\" or \"phone\".');\n        });\n    }\n    promptAndVerify() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const method = yield this.get2faMethod();\n            const securityCode = yield this.getCode(method);\n            try {\n                const result = yield this.verifyCode(securityCode);\n                // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)\n                return result;\n            }\n            catch (e) {\n                console.warn('Error validating security code:', e);\n                if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {\n                    return yield this.promptAndVerify();\n                }\n                throw e;\n            }\n        });\n    }\n    verifyCodeDefault(securityCode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const request = this.getRequest();\n            if (!request) {\n                throw new Error('no request pending');\n            }\n            const { requestId } = request;\n            return yield this.postSignedJson('/2fa/verify', {\n                accountId,\n                securityCode,\n                requestId\n            });\n        });\n    }\n    getRecoveryMethods() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            return {\n                accountId,\n                data: yield this.postSignedJson('/account/recoveryMethods', { accountId })\n            };\n        });\n    }\n    get2faMethod() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { data } = yield this.getRecoveryMethods();\n            if (data && data.length) {\n                data = data.find((m) => m.kind.indexOf('2fa-') === 0);\n            }\n            if (!data)\n                return null;\n            const { kind, detail } = data;\n            return { kind, detail };\n        });\n    }\n    signatureFor() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockNumber = block.header.height.toString();\n            const signed = yield this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);\n            const blockNumberSignature = Buffer.from(signed.signature).toString('base64');\n            return { blockNumber, blockNumberSignature };\n        });\n    }\n    postSignedJson(path, body) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield (0, web_1.fetchJson)(this.helperUrl + path, JSON.stringify(Object.assign(Object.assign({}, body), (yield this.signatureFor()))));\n        });\n    }\n}\nexports.Account2FA = Account2FA;\n// helpers\nconst toPK = (pk) => key_pair_1.PublicKey.from(pk);\nconst convertPKForContract = (pk) => pk.toString().replace('ed25519:', '');\nconst convertActions = (actions, accountId, receiverId) => actions.map((a) => {\n    const type = a.enum;\n    const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];\n    const action = {\n        type: type[0].toUpperCase() + type.substr(1),\n        gas: (gas && gas.toString()) || undefined,\n        public_key: (publicKey && convertPKForContract(publicKey)) || undefined,\n        method_name: methodName,\n        args: (args && Buffer.from(args).toString('base64')) || undefined,\n        code: (code && Buffer.from(code).toString('base64')) || undefined,\n        amount: (deposit && deposit.toString()) || undefined,\n        deposit: (deposit && deposit.toString()) || '0',\n        permission: undefined,\n    };\n    if (accessKey) {\n        if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {\n            action.permission = {\n                receiver_id: accountId,\n                allowance: exports.MULTISIG_ALLOWANCE.toString(),\n                method_names: exports.MULTISIG_CHANGE_METHODS,\n            };\n        }\n        if (accessKey.permission.enum === 'functionCall') {\n            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;\n            action.permission = {\n                receiver_id,\n                allowance: (allowance && allowance.toString()) || undefined,\n                method_names\n            };\n        }\n    }\n    return action;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2FjY291bnRfbXVsdGlzaWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsdUJBQXVCLEdBQUcsMkJBQTJCLEdBQUcsMkNBQTJDLEdBQUcsZ0NBQWdDLEdBQUcsK0JBQStCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsMEJBQTBCLEdBQUcsNEJBQTRCO0FBQzNTLGdDQUFnQyxtQkFBTyxDQUFDLG1EQUFPO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLGtFQUFXO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFnQjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsMEVBQWU7QUFDN0Msb0JBQW9CLG1CQUFPLENBQUMsNEVBQWE7QUFDekMsY0FBYyxtQkFBTyxDQUFDLHNFQUFhO0FBQ25DLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUI7QUFDQSxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdGQUF3RiwyQ0FBMkMsS0FBSztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RCwyQkFBMkIsS0FBSztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVDtBQUNBLDhEQUE4RCxxQkFBcUI7QUFDbkYsU0FBUztBQUNUO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHFCQUFxQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixxQkFBcUI7QUFDckc7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFlBQVk7QUFDdEYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRiwrQkFBK0I7QUFDckgscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQSw2REFBNkQscUJBQXFCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFNBQVM7QUFDVDtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQixjQUFjO0FBQ25FO0FBQ0E7QUFDQSwwRkFBMEYsV0FBVztBQUNyRyx5REFBeUQsd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixnQkFBZ0IsYUFBYSwwQkFBMEI7QUFDcEo7QUFDQSw2RkFBNkYsZ0JBQWdCLGFBQWEsMEJBQTBCO0FBQ3BKO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixnQkFBZ0IsYUFBYSwwQkFBMEI7QUFDaEo7QUFDQSxhQUFhO0FBQ2IsdUVBQXVFLEtBQUs7QUFDNUU7QUFDQTtBQUNBLDJEQUEyRCwrQkFBK0I7QUFDMUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLCtHQUErRyxXQUFXO0FBQzFIO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QyxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EseUZBQXlGLGdCQUFnQixhQUFhLDBCQUEwQjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSw4RUFBOEUsV0FBVztBQUN6RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxpRUFBaUUsbUJBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xILFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUE2RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFnRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2FjY291bnRfbXVsdGlzaWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjY291bnQyRkEgPSBleHBvcnRzLkFjY291bnRNdWx0aXNpZyA9IGV4cG9ydHMuTXVsdGlzaWdTdGF0ZVN0YXR1cyA9IGV4cG9ydHMuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgPSBleHBvcnRzLk1VTFRJU0lHX0NPTkZJUk1fTUVUSE9EUyA9IGV4cG9ydHMuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFMgPSBleHBvcnRzLk1VTFRJU0lHX0RFUE9TSVQgPSBleHBvcnRzLk1VTFRJU0lHX0dBUyA9IGV4cG9ydHMuTVVMVElTSUdfQUxMT1dBTkNFID0gZXhwb3J0cy5NVUxUSVNJR19TVE9SQUdFX0tFWSA9IHZvaWQgMDtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdFwiKTtcbmNvbnN0IGtleV9wYWlyXzEgPSByZXF1aXJlKFwiLi91dGlscy9rZXlfcGFpclwiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHByb3ZpZGVyc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzXCIpO1xuY29uc3Qgd2ViXzEgPSByZXF1aXJlKFwiLi91dGlscy93ZWJcIik7XG5leHBvcnRzLk1VTFRJU0lHX1NUT1JBR0VfS0VZID0gJ19fbXVsdGlzaWdSZXF1ZXN0JztcbmV4cG9ydHMuTVVMVElTSUdfQUxMT1dBTkNFID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgoMCwgZm9ybWF0XzEucGFyc2VOZWFyQW1vdW50KSgnMScpKTtcbi8vIFRPRE86IERpZmZlcmVudCBnYXMgdmFsdWUgZm9yIGRpZmZlcmVudCByZXF1ZXN0cyAoY2FuIHJlZHVjZSBnYXMgdXNhZ2UgZHJhbWF0aWNhbGx5KVxuZXhwb3J0cy5NVUxUSVNJR19HQVMgPSBuZXcgYm5fanNfMS5kZWZhdWx0KCcxMDAwMDAwMDAwMDAwMDAnKTtcbmV4cG9ydHMuTVVMVElTSUdfREVQT1NJVCA9IG5ldyBibl9qc18xLmRlZmF1bHQoJzAnKTtcbmV4cG9ydHMuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFMgPSBbJ2FkZF9yZXF1ZXN0JywgJ2FkZF9yZXF1ZXN0X2FuZF9jb25maXJtJywgJ2RlbGV0ZV9yZXF1ZXN0JywgJ2NvbmZpcm0nXTtcbmV4cG9ydHMuTVVMVElTSUdfQ09ORklSTV9NRVRIT0RTID0gWydjb25maXJtJ107XG52YXIgTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3I7XG4oZnVuY3Rpb24gKE11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yKSB7XG4gICAgTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3JbXCJDQU5OT1RfREVTRVJJQUxJWkVfU1RBVEVcIl0gPSBcIkNhbm5vdCBkZXNlcmlhbGl6ZSB0aGUgY29udHJhY3Qgc3RhdGVcIjtcbiAgICBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcltcIk1VTFRJU0lHX05PVF9JTklUSUFMSVpFRFwiXSA9IFwiU21hcnQgY29udHJhY3QgcGFuaWNrZWQ6IE11bHRpc2lnIGNvbnRyYWN0IHNob3VsZCBiZSBpbml0aWFsaXplZCBiZWZvcmUgdXNhZ2VcIjtcbiAgICBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcltcIk5PX1NVQ0hfUkVRVUVTVFwiXSA9IFwiU21hcnQgY29udHJhY3QgcGFuaWNrZWQ6IHBhbmlja2VkIGF0ICdObyBzdWNoIHJlcXVlc3Q6IGVpdGhlciB3cm9uZyBudW1iZXIgb3IgYWxyZWFkeSBjb25maXJtZWQnXCI7XG4gICAgTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3JbXCJSRVFVRVNUX0NPT0xET1dOX0VSUk9SXCJdID0gXCJSZXF1ZXN0IGNhbm5vdCBiZSBkZWxldGVkIGltbWVkaWF0ZWx5IGFmdGVyIGNyZWF0aW9uLlwiO1xuICAgIE11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yW1wiTUVUSE9EX05PVF9GT1VORFwiXSA9IFwiQ29udHJhY3QgbWV0aG9kIGlzIG5vdCBmb3VuZFwiO1xufSkoTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgPSBleHBvcnRzLk11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yIHx8IChleHBvcnRzLk11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yID0ge30pKTtcbnZhciBNdWx0aXNpZ1N0YXRlU3RhdHVzO1xuKGZ1bmN0aW9uIChNdWx0aXNpZ1N0YXRlU3RhdHVzKSB7XG4gICAgTXVsdGlzaWdTdGF0ZVN0YXR1c1tNdWx0aXNpZ1N0YXRlU3RhdHVzW1wiSU5WQUxJRF9TVEFURVwiXSA9IDBdID0gXCJJTlZBTElEX1NUQVRFXCI7XG4gICAgTXVsdGlzaWdTdGF0ZVN0YXR1c1tNdWx0aXNpZ1N0YXRlU3RhdHVzW1wiU1RBVEVfTk9UX0lOSVRJQUxJWkVEXCJdID0gMV0gPSBcIlNUQVRFX05PVF9JTklUSUFMSVpFRFwiO1xuICAgIE11bHRpc2lnU3RhdGVTdGF0dXNbTXVsdGlzaWdTdGF0ZVN0YXR1c1tcIlZBTElEX1NUQVRFXCJdID0gMl0gPSBcIlZBTElEX1NUQVRFXCI7XG4gICAgTXVsdGlzaWdTdGF0ZVN0YXR1c1tNdWx0aXNpZ1N0YXRlU3RhdHVzW1wiVU5LTk9XTl9TVEFURVwiXSA9IDNdID0gXCJVTktOT1dOX1NUQVRFXCI7XG59KShNdWx0aXNpZ1N0YXRlU3RhdHVzID0gZXhwb3J0cy5NdWx0aXNpZ1N0YXRlU3RhdHVzIHx8IChleHBvcnRzLk11bHRpc2lnU3RhdGVTdGF0dXMgPSB7fSkpO1xudmFyIE11bHRpc2lnQ29kZVN0YXR1cztcbihmdW5jdGlvbiAoTXVsdGlzaWdDb2RlU3RhdHVzKSB7XG4gICAgTXVsdGlzaWdDb2RlU3RhdHVzW011bHRpc2lnQ29kZVN0YXR1c1tcIklOVkFMSURfQ09ERVwiXSA9IDBdID0gXCJJTlZBTElEX0NPREVcIjtcbiAgICBNdWx0aXNpZ0NvZGVTdGF0dXNbTXVsdGlzaWdDb2RlU3RhdHVzW1wiVkFMSURfQ09ERVwiXSA9IDFdID0gXCJWQUxJRF9DT0RFXCI7XG4gICAgTXVsdGlzaWdDb2RlU3RhdHVzW011bHRpc2lnQ29kZVN0YXR1c1tcIlVOS05PV05fQ09ERVwiXSA9IDJdID0gXCJVTktOT1dOX0NPREVcIjtcbn0pKE11bHRpc2lnQ29kZVN0YXR1cyB8fCAoTXVsdGlzaWdDb2RlU3RhdHVzID0ge30pKTtcbi8vIGluIG1lbW9yeSByZXF1ZXN0IGNhY2hlIGZvciBub2RlIHcvbyBsb2NhbFN0b3JhZ2VcbmNvbnN0IHN0b3JhZ2VGYWxsYmFjayA9IHtcbiAgICBbZXhwb3J0cy5NVUxUSVNJR19TVE9SQUdFX0tFWV06IG51bGxcbn07XG5jbGFzcyBBY2NvdW50TXVsdGlzaWcgZXh0ZW5kcyBhY2NvdW50XzEuQWNjb3VudCB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgYWNjb3VudElkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGNvbm5lY3Rpb24sIGFjY291bnRJZCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZTtcbiAgICAgICAgdGhpcy5vbkFkZFJlcXVlc3RSZXN1bHQgPSBvcHRpb25zLm9uQWRkUmVxdWVzdFJlc3VsdDtcbiAgICB9XG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbldpdGhBY2NvdW50KHJlY2VpdmVySWQsIGFjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uOiB7IGdldDogKCkgPT4gc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmNhbGwodGhpcywgeyByZWNlaXZlcklkLCBhY3Rpb25zIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSkge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IHsgZ2V0OiAoKSA9PiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogY29udmVydEFjdGlvbnMoYWN0aW9ucywgYWNjb3VudElkLCByZWNlaXZlcklkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcklkOiBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCB0cmFuc2FjdGlvbl8xLmZ1bmN0aW9uQ2FsbCkoJ2FkZF9yZXF1ZXN0X2FuZF9jb25maXJtJywgYXJncywgZXhwb3J0cy5NVUxUSVNJR19HQVMsIGV4cG9ydHMuTVVMVElTSUdfREVQT1NJVClcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50b1N0cmluZygpLmluY2x1ZGVzKCdBY2NvdW50IGhhcyB0b28gbWFueSBhY3RpdmUgcmVxdWVzdHMuIENvbmZpcm0gb3IgZGVsZXRlIHNvbWUnKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZVVuY29uZmlybWVkUmVxdWVzdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBBcmUgZm9sbG93aW5nIGV2ZW4gbmVlZGVkPyBTZWVtcyBsaWtlIGl0IHRocm93cyBvbiBlcnJvciBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQuc3RhdHVzKTtcbiAgICAgICAgICAgIGlmICghc3RhdHVzLlN1Y2Nlc3NWYWx1ZSB8fCB0eXBlb2Ygc3RhdHVzLlN1Y2Nlc3NWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcGFyc2VJbnQoQnVmZmVyLmZyb20oc3RhdHVzLlN1Y2Nlc3NWYWx1ZSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpLCAxMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMub25BZGRSZXF1ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5vbkFkZFJlcXVlc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEUgdGhlcmUgaXMgbm8gYXdhaXQgb24gcHVycG9zZSB0byBhdm9pZCBibG9ja2luZyBmb3IgMmZhXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVVuY29uZmlybWVkUmVxdWVzdHMoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFRoaXMgbWV0aG9kIHN1Ym1pdHMgYSBjYW5hcnkgdHJhbnNhY3Rpb24gdGhhdCBpcyBleHBlY3RlZCB0byBhbHdheXMgZmFpbCBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY29udHJhY3QgY3VycmVudGx5IGhhcyB2YWxpZCBtdWx0aXNpZyBzdGF0ZVxuICAgICAqIGFuZCB3aGV0aGVyIGl0IGlzIGluaXRpYWxpemVkLiBUaGUgY2FuYXJ5IHRyYW5zYWN0aW9uIGF0dGVtcHRzIHRvIGRlbGV0ZSBhIHJlcXVlc3QgYXQgaW5kZXggdTMyX21heCBhbmQgd2lsbCBnbyB0aHJvdWdoIGlmIGEgcmVxdWVzdCBleGlzdHMgYXQgdGhhdCBpbmRleC5cbiAgICAgKiBhIHUzMl9tYXggKyAxIGFuZCAtMSB2YWx1ZSBjYW5ub3QgYmUgdXNlZCBmb3IgdGhlIGNhbmFyeSBkdWUgdG8gZXhwZWN0ZWQgdTMyIGVycm9yIHRocm93biBiZWZvcmUgZGVzZXJpYWxpemF0aW9uIGF0dGVtcHQuXG4gICAgICovXG4gICAgY2hlY2tNdWx0aXNpZ0NvZGVBbmRTdGF0ZVN0YXR1cyhjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogeyBnZXQ6ICgpID0+IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMl9tYXggPSA0Mjk0OTY3Mjk1O1xuICAgICAgICAgICAgY29uc3QgdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSA9IGNvbnRyYWN0Qnl0ZXMgPyBNdWx0aXNpZ0NvZGVTdGF0dXMuVU5LTk9XTl9DT0RFIDogTXVsdGlzaWdDb2RlU3RhdHVzLlZBTElEX0NPREU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJJZDogdGhpcy5hY2NvdW50SWQsIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgdHJhbnNhY3Rpb25fMS5kZXBsb3lDb250cmFjdCkoY29udHJhY3RCeXRlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHRyYW5zYWN0aW9uXzEuZnVuY3Rpb25DYWxsKSgnZGVsZXRlX3JlcXVlc3QnLCB7IHJlcXVlc3RfaWQ6IHUzMl9tYXggfSwgZXhwb3J0cy5NVUxUSVNJR19HQVMsIGV4cG9ydHMuTVVMVElTSUdfREVQT1NJVClcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZVJlcXVlc3QodTMyX21heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNvZGVTdGF0dXM6IE11bHRpc2lnQ29kZVN0YXR1cy5WQUxJRF9DT0RFLCBzdGF0ZVN0YXR1czogTXVsdGlzaWdTdGF0ZVN0YXR1cy5WQUxJRF9TVEFURSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvci5DQU5OT1RfREVTRVJJQUxJWkVfU1RBVEUpLnRlc3QoZSAmJiBlLmtpbmQgJiYgZS5raW5kLkV4ZWN1dGlvbkVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjb2RlU3RhdHVzOiB2YWxpZENvZGVTdGF0dXNJZk5vRGVwbG95LCBzdGF0ZVN0YXR1czogTXVsdGlzaWdTdGF0ZVN0YXR1cy5JTlZBTElEX1NUQVRFIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ldyBSZWdFeHAoTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuTVVMVElTSUdfTk9UX0lOSVRJQUxJWkVEKS50ZXN0KGUgJiYgZS5raW5kICYmIGUua2luZC5FeGVjdXRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY29kZVN0YXR1czogdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSwgc3RhdGVTdGF0dXM6IE11bHRpc2lnU3RhdGVTdGF0dXMuU1RBVEVfTk9UX0lOSVRJQUxJWkVEIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ldyBSZWdFeHAoTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuTk9fU1VDSF9SRVFVRVNUKS50ZXN0KGUgJiYgZS5raW5kICYmIGUua2luZC5FeGVjdXRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY29kZVN0YXR1czogdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSwgc3RhdGVTdGF0dXM6IE11bHRpc2lnU3RhdGVTdGF0dXMuVkFMSURfU1RBVEUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3IFJlZ0V4cChNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvci5NRVRIT0RfTk9UX0ZPVU5EKS50ZXN0KGUgJiYgZS5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgcmVhY2hhYmxlIGlmIHRyYW5zYWN0aW9uIGluY2x1ZGVkIGEgZGVwbG95XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNvZGVTdGF0dXM6IE11bHRpc2lnQ29kZVN0YXR1cy5JTlZBTElEX0NPREUsIHN0YXRlU3RhdHVzOiBNdWx0aXNpZ1N0YXRlU3RhdHVzLlVOS05PV05fU1RBVEUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZVJlcXVlc3QocmVxdWVzdF9pZCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgIGFjdGlvbnM6IFsoMCwgdHJhbnNhY3Rpb25fMS5mdW5jdGlvbkNhbGwpKCdkZWxldGVfcmVxdWVzdCcsIHsgcmVxdWVzdF9pZCB9LCBleHBvcnRzLk1VTFRJU0lHX0dBUywgZXhwb3J0cy5NVUxUSVNJR19ERVBPU0lUKV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZUFsbFJlcXVlc3RzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdF9pZHMgPSB5aWVsZCB0aGlzLmdldFJlcXVlc3RJZHMoKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0X2lkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChyZXF1ZXN0X2lkcy5tYXAoKGlkKSA9PiB0aGlzLmRlbGV0ZVJlcXVlc3QoaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGVVbmNvbmZpcm1lZFJlcXVlc3RzKCkge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IHsgZ2V0OiAoKSA9PiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgaW4gYmF0Y2gsIGRvbid0IGRlbGV0ZSB1bmV4cGlyZWRcbiAgICAgICAgICAgIC8vIFRPRE86IERlbGV0ZSBpbiBiYXRjaCwgZG9uJ3QgZGVsZXRlIHVuZXhwaXJlZCAoY2FuIHJlZHVjZSBnYXMgdXNhZ2UgZHJhbWF0aWNhbGx5KVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdF9pZHMgPSB5aWVsZCB0aGlzLmdldFJlcXVlc3RJZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdElkIH0gPSB0aGlzLmdldFJlcXVlc3QoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdElkVG9EZWxldGUgb2YgcmVxdWVzdF9pZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdElkVG9EZWxldGUgPT0gcmVxdWVzdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogWygwLCB0cmFuc2FjdGlvbl8xLmZ1bmN0aW9uQ2FsbCkoJ2RlbGV0ZV9yZXF1ZXN0JywgeyByZXF1ZXN0X2lkOiByZXF1ZXN0SWRUb0RlbGV0ZSB9LCBleHBvcnRzLk1VTFRJU0lHX0dBUywgZXhwb3J0cy5NVUxUSVNJR19ERVBPU0lUKV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQXR0ZW1wdCB0byBkZWxldGUgYW4gZWFybGllciByZXF1ZXN0IGJlZm9yZSAxNSBtaW51dGVzIGZhaWxlZC4gV2lsbCB0cnkgYWdhaW4uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gaGVscGVyc1xuICAgIGdldFJlcXVlc3RJZHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZWFkIHJlcXVlc3RzIGZyb20gc3RhdGUgdG8gYWxsb3cgZmlsdGVyaW5nIGJ5IGV4cGlyYXRpb24gdGltZVxuICAgICAgICAgICAgLy8gVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL25lYXIvY29yZS1jb250cmFjdHMvYmxvYi8zMDVkMWRiNGY0ZjJjZjVjZTRjMWVmMzQ3OWY3NTQ0OTU3MzgxZjExL211bHRpc2lnL3NyYy9saWIucnMjTDg0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3RnVuY3Rpb24odGhpcy5hY2NvdW50SWQsICdsaXN0X3JlcXVlc3RfaWRzJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0SXRlbShleHBvcnRzLk1VTFRJU0lHX1NUT1JBR0VfS0VZKSB8fCAne30nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmFnZUZhbGxiYWNrW2V4cG9ydHMuTVVMVElTSUdfU1RPUkFHRV9LRVldO1xuICAgIH1cbiAgICBzZXRSZXF1ZXN0KGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGV4cG9ydHMuTVVMVElTSUdfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlRmFsbGJhY2tbZXhwb3J0cy5NVUxUSVNJR19TVE9SQUdFX0tFWV0gPSBkYXRhO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudE11bHRpc2lnID0gQWNjb3VudE11bHRpc2lnO1xuY2xhc3MgQWNjb3VudDJGQSBleHRlbmRzIEFjY291bnRNdWx0aXNpZyB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgYWNjb3VudElkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGNvbm5lY3Rpb24sIGFjY291bnRJZCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaGVscGVyVXJsID0gJ2h0dHBzOi8vaGVscGVyLnRlc3RuZXQubmVhci5vcmcnO1xuICAgICAgICB0aGlzLmhlbHBlclVybCA9IG9wdGlvbnMuaGVscGVyVXJsIHx8IHRoaXMuaGVscGVyVXJsO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBvcHRpb25zLnN0b3JhZ2U7XG4gICAgICAgIHRoaXMuc2VuZENvZGUgPSBvcHRpb25zLnNlbmRDb2RlIHx8IHRoaXMuc2VuZENvZGVEZWZhdWx0O1xuICAgICAgICB0aGlzLmdldENvZGUgPSBvcHRpb25zLmdldENvZGUgfHwgdGhpcy5nZXRDb2RlRGVmYXVsdDtcbiAgICAgICAgdGhpcy52ZXJpZnlDb2RlID0gb3B0aW9ucy52ZXJpZnlDb2RlIHx8IHRoaXMudmVyaWZ5Q29kZURlZmF1bHQ7XG4gICAgICAgIHRoaXMub25Db25maXJtUmVzdWx0ID0gb3B0aW9ucy5vbkNvbmZpcm1SZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gYSB0cmFuc2FjdGlvbiB0byBwcmVmb3JtIGEgbGlzdCBvZiBhY3Rpb25zIGFuZCBicm9hZGNhc3QgaXQgdXNpbmcgdGhlIFJQQyBBUEkuXG4gICAgICogQHNlZSB7QGxpbmsgcHJvdmlkZXJzL2pzb24tcnBjLXByb3ZpZGVyIUpzb25ScGNQcm92aWRlciNzZW5kVHJhbnNhY3Rpb24gfCBKc29uUnBjUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oeyByZWNlaXZlcklkLCBhY3Rpb25zIH0pIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uOiB7IGdldDogKCkgPT4gc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgZm9sbG93aW5nIG92ZXJyaWRlIG9uUmVxdWVzdFJlc3VsdCBpbiBzdXBlcmNsYXNzIGluc3RlYWQgb2YgZG9pbmcgY3VzdG9tIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24/XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRDb2RlKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnByb21wdEFuZFZlcmlmeSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Db25maXJtUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5vbkNvbmZpcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBkZWZhdWx0IGhlbHBlcnMgZm9yIENIIGRlcGxveW1lbnRzIG9mIG11bHRpc2lnXG4gICAgZGVwbG95TXVsdGlzaWcoY29udHJhY3RCeXRlcykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudDogeyBnZXQ6ICgpID0+IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudCB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzZWVkT3JMZWRnZXJLZXkgPSAoeWllbGQgdGhpcy5nZXRSZWNvdmVyeU1ldGhvZHMoKSkuZGF0YVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsga2luZCwgcHVibGljS2V5IH0pID0+IChraW5kID09PSAncGhyYXNlJyB8fCBraW5kID09PSAnbGVkZ2VyJykgJiYgcHVibGljS2V5ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIC5tYXAoKHJtKSA9PiBybS5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgZmFrMmxhayA9ICh5aWVsZCB0aGlzLmdldEFjY2Vzc0tleXMoKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh7IHB1YmxpY19rZXksIGFjY2Vzc19rZXk6IHsgcGVybWlzc2lvbiB9IH0pID0+IHBlcm1pc3Npb24gPT09ICdGdWxsQWNjZXNzJyAmJiAhc2VlZE9yTGVkZ2VyS2V5LmluY2x1ZGVzKHB1YmxpY19rZXkpKVxuICAgICAgICAgICAgICAgIC5tYXAoKGFrKSA9PiBhay5wdWJsaWNfa2V5KVxuICAgICAgICAgICAgICAgIC5tYXAodG9QSyk7XG4gICAgICAgICAgICBjb25zdCBjb25maXJtT25seUtleSA9IHRvUEsoKHlpZWxkIHRoaXMucG9zdFNpZ25lZEpzb24oJy8yZmEvZ2V0QWNjZXNzS2V5JywgeyBhY2NvdW50SWQgfSkpLnB1YmxpY0tleSk7XG4gICAgICAgICAgICBjb25zdCBuZXdBcmdzID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoeyAnbnVtX2NvbmZpcm1hdGlvbnMnOiAyIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgLi4uZmFrMmxhay5tYXAoKHBrKSA9PiAoMCwgdHJhbnNhY3Rpb25fMS5kZWxldGVLZXkpKHBrKSksXG4gICAgICAgICAgICAgICAgLi4uZmFrMmxhay5tYXAoKHBrKSA9PiAoMCwgdHJhbnNhY3Rpb25fMS5hZGRLZXkpKHBrLCAoMCwgdHJhbnNhY3Rpb25fMS5mdW5jdGlvbkNhbGxBY2Nlc3NLZXkpKGFjY291bnRJZCwgZXhwb3J0cy5NVUxUSVNJR19DSEFOR0VfTUVUSE9EUywgbnVsbCkpKSxcbiAgICAgICAgICAgICAgICAoMCwgdHJhbnNhY3Rpb25fMS5hZGRLZXkpKGNvbmZpcm1Pbmx5S2V5LCAoMCwgdHJhbnNhY3Rpb25fMS5mdW5jdGlvbkNhbGxBY2Nlc3NLZXkpKGFjY291bnRJZCwgZXhwb3J0cy5NVUxUSVNJR19DT05GSVJNX01FVEhPRFMsIG51bGwpKSxcbiAgICAgICAgICAgICAgICAoMCwgdHJhbnNhY3Rpb25fMS5kZXBsb3lDb250cmFjdCkoY29udHJhY3RCeXRlcyksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgbmV3RnVuY3Rpb25DYWxsQWN0aW9uQmF0Y2ggPSBhY3Rpb25zLmNvbmNhdCgoMCwgdHJhbnNhY3Rpb25fMS5mdW5jdGlvbkNhbGwpKCduZXcnLCBuZXdBcmdzLCBleHBvcnRzLk1VTFRJU0lHX0dBUywgZXhwb3J0cy5NVUxUSVNJR19ERVBPU0lUKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGVwbG95aW5nIG11bHRpc2lnIGNvbnRyYWN0IGZvcicsIGFjY291bnRJZCk7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlU3RhdHVzOiBtdWx0aXNpZ1N0YXRlU3RhdHVzIH0gPSB5aWVsZCB0aGlzLmNoZWNrTXVsdGlzaWdDb2RlQW5kU3RhdGVTdGF0dXMoY29udHJhY3RCeXRlcyk7XG4gICAgICAgICAgICBzd2l0Y2ggKG11bHRpc2lnU3RhdGVTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE11bHRpc2lnU3RhdGVTdGF0dXMuU1RBVEVfTk9UX0lOSVRJQUxJWkVEOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudC5jYWxsKHRoaXMsIGFjY291bnRJZCwgbmV3RnVuY3Rpb25DYWxsQWN0aW9uQmF0Y2gpO1xuICAgICAgICAgICAgICAgIGNhc2UgTXVsdGlzaWdTdGF0ZVN0YXR1cy5WQUxJRF9TVEFURTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uV2l0aEFjY291bnQuY2FsbCh0aGlzLCBhY2NvdW50SWQsIGFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNhc2UgTXVsdGlzaWdTdGF0ZVN0YXR1cy5JTlZBTElEX1NUQVRFOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdmlkZXJzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBkZXBsb3kgYSBjb250cmFjdCB0byBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgdGhlIGFjY291bnQgaGFzIGV4aXN0aW5nIHN0YXRlLmAsICdDb250cmFjdEhhc0V4aXN0aW5nU3RhdGUnKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdmlkZXJzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBkZXBsb3kgYSBjb250cmFjdCB0byBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgdGhlIGFjY291bnQgc3RhdGUgY291bGQgbm90IGJlIHZlcmlmaWVkLmAsICdDb250cmFjdFN0YXRlVW5rbm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzYWJsZVdpdGhGQUsoeyBjb250cmFjdEJ5dGVzLCBjbGVhbnVwQ29udHJhY3RCeXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY2xlYW51cEFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwQ29udHJhY3RCeXRlcykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGVsZXRlQWxsUmVxdWVzdHMoKS5jYXRjaChlID0+IGUpO1xuICAgICAgICAgICAgICAgIGNsZWFudXBBY3Rpb25zID0geWllbGQgdGhpcy5nZXQyZmFEaXNhYmxlQ2xlYW51cEFjdGlvbnMoY2xlYW51cENvbnRyYWN0Qnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5Q29udmVyc2lvbkFjdGlvbnMgPSB5aWVsZCB0aGlzLmdldDJmYURpc2FibGVLZXlDb252ZXJzaW9uQWN0aW9ucygpO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICAuLi5jbGVhbnVwQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAuLi5rZXlDb252ZXJzaW9uQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAoMCwgdHJhbnNhY3Rpb25fMS5kZXBsb3lDb250cmFjdCkoY29udHJhY3RCeXRlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NLZXlJbmZvID0geWllbGQgdGhpcy5maW5kQWNjZXNzS2V5KHRoaXMuYWNjb3VudElkLCBhY3Rpb25zKTtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NLZXlJbmZvICYmIGFjY2Vzc0tleUluZm8uYWNjZXNzS2V5ICYmIGFjY2Vzc0tleUluZm8uYWNjZXNzS2V5LnBlcm1pc3Npb24gIT09ICdGdWxsQWNjZXNzJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm92aWRlcnNfMS5UeXBlZEVycm9yKCdObyBmdWxsIGFjY2VzcyBrZXkgZm91bmQgaW4ga2V5c3RvcmUuIFVuYWJsZSB0byBieXBhc3MgbXVsdGlzaWcnLCAnTm9GQUtGb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbldpdGhBY2NvdW50KHRoaXMuYWNjb3VudElkLCBhY3Rpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldDJmYURpc2FibGVDbGVhbnVwQWN0aW9ucyhjbGVhbnVwQ29udHJhY3RCeXRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEFjY291bnRTdGF0ZSA9IHlpZWxkIHRoaXMudmlld1N0YXRlKCcnKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZSAmJiBlcnJvci5jYXVzZS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChjYXVzZSA9PSAnTk9fQ09OVFJBQ1RfQ09ERScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBjYXVzZSA9PSAnVE9PX0xBUkdFX0NPTlRSQUNUX1NUQVRFJ1xuICAgICAgICAgICAgICAgICAgICA/IG5ldyBwcm92aWRlcnNfMS5UeXBlZEVycm9yKGBDYW4gbm90IGRlcGxveSBhIGNvbnRyYWN0IHRvIGFjY291bnQgJHt0aGlzLmFjY291bnRJZH0gb24gbmV0d29yayAke3RoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWR9LCB0aGUgYWNjb3VudCBoYXMgZXhpc3Rpbmcgc3RhdGUuYCwgJ0NvbnRyYWN0SGFzRXhpc3RpbmdTdGF0ZScpXG4gICAgICAgICAgICAgICAgICAgIDogZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBY2NvdW50U3RhdGVLZXlzID0gY3VycmVudEFjY291bnRTdGF0ZS5tYXAoKHsga2V5IH0pID0+IGtleS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRBY2NvdW50U3RhdGUubGVuZ3RoID8gW1xuICAgICAgICAgICAgICAgICgwLCB0cmFuc2FjdGlvbl8xLmRlcGxveUNvbnRyYWN0KShjbGVhbnVwQ29udHJhY3RCeXRlcyksXG4gICAgICAgICAgICAgICAgKDAsIHRyYW5zYWN0aW9uXzEuZnVuY3Rpb25DYWxsKSgnY2xlYW4nLCB7IGtleXM6IGN1cnJlbnRBY2NvdW50U3RhdGVLZXlzIH0sIGV4cG9ydHMuTVVMVElTSUdfR0FTLCBuZXcgYm5fanNfMS5kZWZhdWx0KCcwJykpXG4gICAgICAgICAgICBdIDogW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQyZmFEaXNhYmxlS2V5Q29udmVyc2lvbkFjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleXMgPSB5aWVsZCB0aGlzLmdldEFjY2Vzc0tleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhazJmYWsgPSBhY2Nlc3NLZXlzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoeyBhY2Nlc3Nfa2V5IH0pID0+IGFjY2Vzc19rZXkucGVybWlzc2lvbiAhPT0gJ0Z1bGxBY2Nlc3MnKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgYWNjZXNzX2tleSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVybSA9IGFjY2Vzc19rZXkucGVybWlzc2lvbi5GdW5jdGlvbkNhbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcm0ucmVjZWl2ZXJfaWQgPT09IGFjY291bnRJZCAmJlxuICAgICAgICAgICAgICAgICAgICBwZXJtLm1ldGhvZF9uYW1lcy5sZW5ndGggPT09IDQgJiZcbiAgICAgICAgICAgICAgICAgICAgcGVybS5tZXRob2RfbmFtZXMuaW5jbHVkZXMoJ2FkZF9yZXF1ZXN0X2FuZF9jb25maXJtJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1Pbmx5S2V5ID0ga2V5X3BhaXJfMS5QdWJsaWNLZXkuZnJvbSgoeWllbGQgdGhpcy5wb3N0U2lnbmVkSnNvbignLzJmYS9nZXRBY2Nlc3NLZXknLCB7IGFjY291bnRJZCB9KSkucHVibGljS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKDAsIHRyYW5zYWN0aW9uXzEuZGVsZXRlS2V5KShjb25maXJtT25seUtleSksXG4gICAgICAgICAgICAgICAgLi4ubGFrMmZhay5tYXAoKHsgcHVibGljX2tleSB9KSA9PiAoMCwgdHJhbnNhY3Rpb25fMS5kZWxldGVLZXkpKGtleV9wYWlyXzEuUHVibGljS2V5LmZyb20ocHVibGljX2tleSkpKSxcbiAgICAgICAgICAgICAgICAuLi5sYWsyZmFrLm1hcCgoeyBwdWJsaWNfa2V5IH0pID0+ICgwLCB0cmFuc2FjdGlvbl8xLmFkZEtleSkoa2V5X3BhaXJfMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNfa2V5KSwgKDAsIHRyYW5zYWN0aW9uXzEuZnVsbEFjY2Vzc0tleSkoKSkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgTEFLcyBiYWNrIHRvIEZBS3MsIGNsZWFycyBzdGF0ZSBhbmQgZGVwbG95cyBhbiAnZW1wdHknIGNvbnRyYWN0IChjb250cmFjdEJ5dGVzIHBhcmFtKVxuICAgICAqIEBwYXJhbSBbY29udHJhY3RCeXRlc117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25lYXIvbmVhci13YWxsZXQvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZnJvbnRlbmQvc3JjL3dhc20vbWFpbi53YXNtP3Jhdz10cnVlfVxuICAgICAqIEBwYXJhbSBbY2xlYW51cENvbnRyYWN0Qnl0ZXNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL2NvcmUtY29udHJhY3RzL2Jsb2IvbWFzdGVyL3N0YXRlLWNsZWFudXAvcmVzL3N0YXRlX2NsZWFudXAud2FzbT9yYXc9dHJ1ZX1cbiAgICAgKi9cbiAgICBkaXNhYmxlKGNvbnRyYWN0Qnl0ZXMsIGNsZWFudXBDb250cmFjdEJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlU3RhdHVzIH0gPSB5aWVsZCB0aGlzLmNoZWNrTXVsdGlzaWdDb2RlQW5kU3RhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZVN0YXR1cyAhPT0gTXVsdGlzaWdTdGF0ZVN0YXR1cy5WQUxJRF9TVEFURSAmJiBzdGF0ZVN0YXR1cyAhPT0gTXVsdGlzaWdTdGF0ZVN0YXR1cy5TVEFURV9OT1RfSU5JVElBTElaRUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdmlkZXJzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBkZXBsb3kgYSBjb250cmFjdCB0byBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgdGhlIGFjY291bnQgc3RhdGUgY291bGQgbm90IGJlIHZlcmlmaWVkLmAsICdDb250cmFjdFN0YXRlVW5rbm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlbGV0ZUFsbFJlcXVlc3RzRXJyb3I7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZUFsbFJlcXVlc3RzKCkuY2F0Y2goZSA9PiBkZWxldGVBbGxSZXF1ZXN0c0Vycm9yID0gZSk7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwQWN0aW9ucyA9IHlpZWxkIHRoaXMuZ2V0MmZhRGlzYWJsZUNsZWFudXBBY3Rpb25zKGNsZWFudXBDb250cmFjdEJ5dGVzKS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnQ29udHJhY3RIYXNFeGlzdGluZ1N0YXRlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZWxldGVBbGxSZXF1ZXN0c0Vycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY2xlYW51cEFjdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4uKHlpZWxkIHRoaXMuZ2V0MmZhRGlzYWJsZUtleUNvbnZlcnNpb25BY3Rpb25zKCkpLFxuICAgICAgICAgICAgICAgICgwLCB0cmFuc2FjdGlvbl8xLmRlcGxveUNvbnRyYWN0KShjb250cmFjdEJ5dGVzKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGlzYWJsaW5nIDJmYSBmb3InLCB0aGlzLmFjY291bnRJZCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRDb2RlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0SWQgfSA9IHRoaXMuZ2V0UmVxdWVzdCgpO1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0geWllbGQgdGhpcy5nZXQyZmFNZXRob2QoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucG9zdFNpZ25lZEpzb24oJy8yZmEvc2VuZCcsIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RJZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvZGVEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBnZXRDb2RlIGNhbGxiYWNrIHByb3ZpZGVkLiBQbGVhc2UgcHJvdmlkZSB5b3VyIG93biBpbiBBY2NvdW50TXVsdGlzaWcgY29uc3RydWN0b3Igb3B0aW9ucy4gSXQgaGFzIGEgcGFyYW1ldGVyIG1ldGhvZCB3aGVyZSBtZXRob2Qua2luZCBpcyBcImVtYWlsXCIgb3IgXCJwaG9uZVwiLicpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvbXB0QW5kVmVyaWZ5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0geWllbGQgdGhpcy5nZXQyZmFNZXRob2QoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3VyaXR5Q29kZSA9IHlpZWxkIHRoaXMuZ2V0Q29kZShtZXRob2QpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnZlcmlmeUNvZGUoc2VjdXJpdHlDb2RlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBQYXJzZSBlcnJvciBmcm9tIHJlc3VsdCBmb3IgcmVhbCAobGlrZSBpbiBub3JtYWwgYWNjb3VudC5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgdmFsaWRhdGluZyBzZWN1cml0eSBjb2RlOicsIGUpO1xuICAgICAgICAgICAgICAgIGlmIChlLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ2ludmFsaWQgMmZhIGNvZGUgcHJvdmlkZWQnKSB8fCBlLnRvU3RyaW5nKCkuaW5jbHVkZXMoJzJmYSBjb2RlIG5vdCB2YWxpZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb21wdEFuZFZlcmlmeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmVyaWZ5Q29kZURlZmF1bHQoc2VjdXJpdHlDb2RlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJlcXVlc3QoKTtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcmVxdWVzdCBwZW5kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RJZCB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnBvc3RTaWduZWRKc29uKCcvMmZhL3ZlcmlmeScsIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb2RlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZWNvdmVyeU1ldGhvZHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGRhdGE6IHlpZWxkIHRoaXMucG9zdFNpZ25lZEpzb24oJy9hY2NvdW50L3JlY292ZXJ5TWV0aG9kcycsIHsgYWNjb3VudElkIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0MmZhTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHsgZGF0YSB9ID0geWllbGQgdGhpcy5nZXRSZWNvdmVyeU1ldGhvZHMoKTtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuZmluZCgobSkgPT4gbS5raW5kLmluZGV4T2YoJzJmYS0nKSA9PT0gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IGtpbmQsIGRldGFpbCB9ID0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB7IGtpbmQsIGRldGFpbCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbmF0dXJlRm9yKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBibG9jay5oZWFkZXIuaGVpZ2h0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24uc2lnbmVyLnNpZ25NZXNzYWdlKEJ1ZmZlci5mcm9tKGJsb2NrTnVtYmVyKSwgYWNjb3VudElkLCB0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyU2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2lnbmVkLnNpZ25hdHVyZSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgYmxvY2tOdW1iZXIsIGJsb2NrTnVtYmVyU2lnbmF0dXJlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3N0U2lnbmVkSnNvbihwYXRoLCBib2R5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgKDAsIHdlYl8xLmZldGNoSnNvbikodGhpcy5oZWxwZXJVcmwgKyBwYXRoLCBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJvZHkpLCAoeWllbGQgdGhpcy5zaWduYXR1cmVGb3IoKSkpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudDJGQSA9IEFjY291bnQyRkE7XG4vLyBoZWxwZXJzXG5jb25zdCB0b1BLID0gKHBrKSA9PiBrZXlfcGFpcl8xLlB1YmxpY0tleS5mcm9tKHBrKTtcbmNvbnN0IGNvbnZlcnRQS0ZvckNvbnRyYWN0ID0gKHBrKSA9PiBway50b1N0cmluZygpLnJlcGxhY2UoJ2VkMjU1MTk6JywgJycpO1xuY29uc3QgY29udmVydEFjdGlvbnMgPSAoYWN0aW9ucywgYWNjb3VudElkLCByZWNlaXZlcklkKSA9PiBhY3Rpb25zLm1hcCgoYSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBhLmVudW07XG4gICAgY29uc3QgeyBnYXMsIHB1YmxpY0tleSwgbWV0aG9kTmFtZSwgYXJncywgZGVwb3NpdCwgYWNjZXNzS2V5LCBjb2RlIH0gPSBhW3R5cGVdO1xuICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgdHlwZTogdHlwZVswXS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSksXG4gICAgICAgIGdhczogKGdhcyAmJiBnYXMudG9TdHJpbmcoKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBwdWJsaWNfa2V5OiAocHVibGljS2V5ICYmIGNvbnZlcnRQS0ZvckNvbnRyYWN0KHB1YmxpY0tleSkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbWV0aG9kX25hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIGFyZ3M6IChhcmdzICYmIEJ1ZmZlci5mcm9tKGFyZ3MpLnRvU3RyaW5nKCdiYXNlNjQnKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiAoY29kZSAmJiBCdWZmZXIuZnJvbShjb2RlKS50b1N0cmluZygnYmFzZTY0JykpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgYW1vdW50OiAoZGVwb3NpdCAmJiBkZXBvc2l0LnRvU3RyaW5nKCkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgZGVwb3NpdDogKGRlcG9zaXQgJiYgZGVwb3NpdC50b1N0cmluZygpKSB8fCAnMCcsXG4gICAgICAgIHBlcm1pc3Npb246IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChhY2Nlc3NLZXkpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVySWQgPT09IGFjY291bnRJZCAmJiBhY2Nlc3NLZXkucGVybWlzc2lvbi5lbnVtICE9PSAnZnVsbEFjY2VzcycpIHtcbiAgICAgICAgICAgIGFjdGlvbi5wZXJtaXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyX2lkOiBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWxsb3dhbmNlOiBleHBvcnRzLk1VTFRJU0lHX0FMTE9XQU5DRS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1ldGhvZF9uYW1lczogZXhwb3J0cy5NVUxUSVNJR19DSEFOR0VfTUVUSE9EUyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjY2Vzc0tleS5wZXJtaXNzaW9uLmVudW0gPT09ICdmdW5jdGlvbkNhbGwnKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlY2VpdmVySWQ6IHJlY2VpdmVyX2lkLCBtZXRob2ROYW1lczogbWV0aG9kX25hbWVzLCBhbGxvd2FuY2UgfSA9IGFjY2Vzc0tleS5wZXJtaXNzaW9uLmZ1bmN0aW9uQ2FsbDtcbiAgICAgICAgICAgIGFjdGlvbi5wZXJtaXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyX2lkLFxuICAgICAgICAgICAgICAgIGFsbG93YW5jZTogKGFsbG93YW5jZSAmJiBhbGxvd2FuY2UudG9TdHJpbmcoKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1ldGhvZF9uYW1lc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uO1xufSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/account_multisig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/common-index.js":
/*!******************************************************!*\
  !*** ./node_modules/near-api-js/lib/common-index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletConnection = exports.ConnectedWalletAccount = exports.Near = exports.KeyPair = exports.Signer = exports.InMemorySigner = exports.Contract = exports.Connection = exports.Account = exports.multisig = exports.validators = exports.transactions = exports.utils = exports.providers = exports.accountCreator = void 0;\n/** @hidden @module */\nconst providers = __importStar(__webpack_require__(/*! ./providers */ \"(ssr)/./node_modules/near-api-js/lib/providers/index.js\"));\nexports.providers = providers;\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/near-api-js/lib/utils/index.js\"));\nexports.utils = utils;\nconst transactions = __importStar(__webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/near-api-js/lib/transaction.js\"));\nexports.transactions = transactions;\nconst validators = __importStar(__webpack_require__(/*! ./validators */ \"(ssr)/./node_modules/near-api-js/lib/validators.js\"));\nexports.validators = validators;\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/near-api-js/lib/account.js\");\nObject.defineProperty(exports, \"Account\", ({ enumerable: true, get: function () { return account_1.Account; } }));\nconst multisig = __importStar(__webpack_require__(/*! ./account_multisig */ \"(ssr)/./node_modules/near-api-js/lib/account_multisig.js\"));\nexports.multisig = multisig;\nconst accountCreator = __importStar(__webpack_require__(/*! ./account_creator */ \"(ssr)/./node_modules/near-api-js/lib/account_creator.js\"));\nexports.accountCreator = accountCreator;\nconst connection_1 = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/near-api-js/lib/connection.js\");\nObject.defineProperty(exports, \"Connection\", ({ enumerable: true, get: function () { return connection_1.Connection; } }));\nconst signer_1 = __webpack_require__(/*! ./signer */ \"(ssr)/./node_modules/near-api-js/lib/signer.js\");\nObject.defineProperty(exports, \"Signer\", ({ enumerable: true, get: function () { return signer_1.Signer; } }));\nObject.defineProperty(exports, \"InMemorySigner\", ({ enumerable: true, get: function () { return signer_1.InMemorySigner; } }));\nconst contract_1 = __webpack_require__(/*! ./contract */ \"(ssr)/./node_modules/near-api-js/lib/contract.js\");\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return contract_1.Contract; } }));\nconst key_pair_1 = __webpack_require__(/*! ./utils/key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\nObject.defineProperty(exports, \"KeyPair\", ({ enumerable: true, get: function () { return key_pair_1.KeyPair; } }));\nconst near_1 = __webpack_require__(/*! ./near */ \"(ssr)/./node_modules/near-api-js/lib/near.js\");\nObject.defineProperty(exports, \"Near\", ({ enumerable: true, get: function () { return near_1.Near; } }));\nconst wallet_account_1 = __webpack_require__(/*! ./wallet-account */ \"(ssr)/./node_modules/near-api-js/lib/wallet-account.js\");\nObject.defineProperty(exports, \"ConnectedWalletAccount\", ({ enumerable: true, get: function () { return wallet_account_1.ConnectedWalletAccount; } }));\nObject.defineProperty(exports, \"WalletConnection\", ({ enumerable: true, get: function () { return wallet_account_1.WalletConnection; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2NvbW1vbi1pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsOEJBQThCLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsc0JBQXNCLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0I7QUFDMVQ7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw0RUFBYTtBQUNwRCxpQkFBaUI7QUFDakIsMkJBQTJCLG1CQUFPLENBQUMsb0VBQVM7QUFDNUMsYUFBYTtBQUNiLGtDQUFrQyxtQkFBTyxDQUFDLDBFQUFlO0FBQ3pELG9CQUFvQjtBQUNwQixnQ0FBZ0MsbUJBQU8sQ0FBQyx3RUFBYztBQUN0RCxrQkFBa0I7QUFDbEIsa0JBQWtCLG1CQUFPLENBQUMsa0VBQVc7QUFDckMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLDhCQUE4QixtQkFBTyxDQUFDLG9GQUFvQjtBQUMxRCxnQkFBZ0I7QUFDaEIsb0NBQW9DLG1CQUFPLENBQUMsa0ZBQW1CO0FBQy9ELHNCQUFzQjtBQUN0QixxQkFBcUIsbUJBQU8sQ0FBQyx3RUFBYztBQUMzQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgsaUJBQWlCLG1CQUFPLENBQUMsZ0VBQVU7QUFDbkMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLGtEQUFpRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM1SCxtQkFBbUIsbUJBQU8sQ0FBQyxvRUFBWTtBQUN2Qyw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzdDLDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCxlQUFlLG1CQUFPLENBQUMsNERBQVE7QUFDL0Isd0NBQXVDLEVBQUUscUNBQXFDLHVCQUF1QixFQUFDO0FBQ3RHLHlCQUF5QixtQkFBTyxDQUFDLGdGQUFrQjtBQUNuRCwwREFBeUQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDcEosb0RBQW1ELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIvY29tbW9uLWluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhbGxldENvbm5lY3Rpb24gPSBleHBvcnRzLkNvbm5lY3RlZFdhbGxldEFjY291bnQgPSBleHBvcnRzLk5lYXIgPSBleHBvcnRzLktleVBhaXIgPSBleHBvcnRzLlNpZ25lciA9IGV4cG9ydHMuSW5NZW1vcnlTaWduZXIgPSBleHBvcnRzLkNvbnRyYWN0ID0gZXhwb3J0cy5Db25uZWN0aW9uID0gZXhwb3J0cy5BY2NvdW50ID0gZXhwb3J0cy5tdWx0aXNpZyA9IGV4cG9ydHMudmFsaWRhdG9ycyA9IGV4cG9ydHMudHJhbnNhY3Rpb25zID0gZXhwb3J0cy51dGlscyA9IGV4cG9ydHMucHJvdmlkZXJzID0gZXhwb3J0cy5hY2NvdW50Q3JlYXRvciA9IHZvaWQgMDtcbi8qKiBAaGlkZGVuIEBtb2R1bGUgKi9cbmNvbnN0IHByb3ZpZGVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlcnNcIikpO1xuZXhwb3J0cy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XG5jb25zdCB0cmFuc2FjdGlvbnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIikpO1xuZXhwb3J0cy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG5jb25zdCB2YWxpZGF0b3JzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnNcIikpO1xuZXhwb3J0cy52YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbmNvbnN0IGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50XzEuQWNjb3VudDsgfSB9KTtcbmNvbnN0IG11bHRpc2lnID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRfbXVsdGlzaWdcIikpO1xuZXhwb3J0cy5tdWx0aXNpZyA9IG11bHRpc2lnO1xuY29uc3QgYWNjb3VudENyZWF0b3IgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYWNjb3VudF9jcmVhdG9yXCIpKTtcbmV4cG9ydHMuYWNjb3VudENyZWF0b3IgPSBhY2NvdW50Q3JlYXRvcjtcbmNvbnN0IGNvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbjsgfSB9KTtcbmNvbnN0IHNpZ25lcl8xID0gcmVxdWlyZShcIi4vc2lnbmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWduZXJfMS5TaWduZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbk1lbW9yeVNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmVyXzEuSW5NZW1vcnlTaWduZXI7IH0gfSk7XG5jb25zdCBjb250cmFjdF8xID0gcmVxdWlyZShcIi4vY29udHJhY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfMS5Db250cmFjdDsgfSB9KTtcbmNvbnN0IGtleV9wYWlyXzEgPSByZXF1aXJlKFwiLi91dGlscy9rZXlfcGFpclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleVBhaXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleV9wYWlyXzEuS2V5UGFpcjsgfSB9KTtcbmNvbnN0IG5lYXJfMSA9IHJlcXVpcmUoXCIuL25lYXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZWFyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZWFyXzEuTmVhcjsgfSB9KTtcbmNvbnN0IHdhbGxldF9hY2NvdW50XzEgPSByZXF1aXJlKFwiLi93YWxsZXQtYWNjb3VudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3RlZFdhbGxldEFjY291bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdhbGxldF9hY2NvdW50XzEuQ29ubmVjdGVkV2FsbGV0QWNjb3VudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldhbGxldENvbm5lY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdhbGxldF9hY2NvdW50XzEuV2FsbGV0Q29ubmVjdGlvbjsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/common-index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/near-api-js/lib/connect.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.connect = void 0;\n/**\n * Connect to NEAR using the provided configuration.\n *\n * {@link ConnectConfig.networkId} and {@link ConnectConfig.nodeUrl} are required.\n *\n * To sign transactions you can also pass:\n * 1. {@link ConnectConfig.keyStore}\n * 2. {@link ConnectConfig.keyPath}\n *\n * If all three are passed they are prioritize in that order.\n *\n * @see {@link ConnectConfig}\n * @example\n * ```js\n * async function initNear() {\n *   const near = await connect({\n *      networkId: 'testnet',\n *      nodeUrl: 'https://rpc.testnet.near.org'\n *   })\n * }\n * ```\n * @module connect\n */\nconst unencrypted_file_system_keystore_1 = __webpack_require__(/*! ./key_stores/unencrypted_file_system_keystore */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/unencrypted_file_system_keystore.js\");\nconst key_stores_1 = __webpack_require__(/*! ./key_stores */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/index.js\");\nconst near_1 = __webpack_require__(/*! ./near */ \"(ssr)/./node_modules/near-api-js/lib/near.js\");\nconst setup_node_fetch_1 = __importDefault(__webpack_require__(/*! ./utils/setup-node-fetch */ \"(ssr)/./node_modules/near-api-js/lib/utils/setup-node-fetch.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/near-api-js/lib/utils/index.js\");\nglobal.fetch = setup_node_fetch_1.default;\n/**\n * Initialize connection to Near network.\n */\nfunction connect(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Try to find extra key in `KeyPath` if provided.\n        if (config.keyPath && config.keyStore) {\n            try {\n                const accountKeyFile = yield (0, unencrypted_file_system_keystore_1.readKeyFile)(config.keyPath);\n                if (accountKeyFile[0]) {\n                    // TODO: Only load key if network ID matches\n                    const keyPair = accountKeyFile[1];\n                    const keyPathStore = new key_stores_1.InMemoryKeyStore();\n                    yield keyPathStore.setKey(config.networkId, accountKeyFile[0], keyPair);\n                    if (!config.masterAccount) {\n                        config.masterAccount = accountKeyFile[0];\n                    }\n                    config.keyStore = new key_stores_1.MergeKeyStore([\n                        keyPathStore,\n                        config.keyStore\n                    ], { writeKeyStoreIndex: 1 });\n                    if (!process.env['NEAR_NO_LOGS']) {\n                        console.log(`Loaded master account ${accountKeyFile[0]} key from ${config.keyPath} with public key = ${keyPair.getPublicKey()}`);\n                    }\n                }\n            }\n            catch (error) {\n                (0, utils_1.logWarning)(`Failed to load master account key from ${config.keyPath}: ${error}`);\n            }\n        }\n        return new near_1.Near(config);\n    });\n}\nexports.connect = connect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLElBQUksK0JBQStCLEtBQUssNkJBQTZCO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUJBQU8sQ0FBQywwSUFBK0M7QUFDbEcscUJBQXFCLG1CQUFPLENBQUMsOEVBQWM7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLDREQUFRO0FBQy9CLDJDQUEyQyxtQkFBTyxDQUFDLGdHQUEwQjtBQUM3RSxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsNkRBQTZELG1CQUFtQixXQUFXLGdCQUFnQixvQkFBb0IsdUJBQXVCO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGVBQWUsSUFBSSxNQUFNO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi9jb25uZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbm5lY3QgPSB2b2lkIDA7XG4vKipcbiAqIENvbm5lY3QgdG8gTkVBUiB1c2luZyB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbi5cbiAqXG4gKiB7QGxpbmsgQ29ubmVjdENvbmZpZy5uZXR3b3JrSWR9IGFuZCB7QGxpbmsgQ29ubmVjdENvbmZpZy5ub2RlVXJsfSBhcmUgcmVxdWlyZWQuXG4gKlxuICogVG8gc2lnbiB0cmFuc2FjdGlvbnMgeW91IGNhbiBhbHNvIHBhc3M6XG4gKiAxLiB7QGxpbmsgQ29ubmVjdENvbmZpZy5rZXlTdG9yZX1cbiAqIDIuIHtAbGluayBDb25uZWN0Q29uZmlnLmtleVBhdGh9XG4gKlxuICogSWYgYWxsIHRocmVlIGFyZSBwYXNzZWQgdGhleSBhcmUgcHJpb3JpdGl6ZSBpbiB0aGF0IG9yZGVyLlxuICpcbiAqIEBzZWUge0BsaW5rIENvbm5lY3RDb25maWd9XG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGFzeW5jIGZ1bmN0aW9uIGluaXROZWFyKCkge1xuICogICBjb25zdCBuZWFyID0gYXdhaXQgY29ubmVjdCh7XG4gKiAgICAgIG5ldHdvcmtJZDogJ3Rlc3RuZXQnLFxuICogICAgICBub2RlVXJsOiAnaHR0cHM6Ly9ycGMudGVzdG5ldC5uZWFyLm9yZydcbiAqICAgfSlcbiAqIH1cbiAqIGBgYFxuICogQG1vZHVsZSBjb25uZWN0XG4gKi9cbmNvbnN0IHVuZW5jcnlwdGVkX2ZpbGVfc3lzdGVtX2tleXN0b3JlXzEgPSByZXF1aXJlKFwiLi9rZXlfc3RvcmVzL3VuZW5jcnlwdGVkX2ZpbGVfc3lzdGVtX2tleXN0b3JlXCIpO1xuY29uc3Qga2V5X3N0b3Jlc18xID0gcmVxdWlyZShcIi4va2V5X3N0b3Jlc1wiKTtcbmNvbnN0IG5lYXJfMSA9IHJlcXVpcmUoXCIuL25lYXJcIik7XG5jb25zdCBzZXR1cF9ub2RlX2ZldGNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvc2V0dXAtbm9kZS1mZXRjaFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5nbG9iYWwuZmV0Y2ggPSBzZXR1cF9ub2RlX2ZldGNoXzEuZGVmYXVsdDtcbi8qKlxuICogSW5pdGlhbGl6ZSBjb25uZWN0aW9uIHRvIE5lYXIgbmV0d29yay5cbiAqL1xuZnVuY3Rpb24gY29ubmVjdChjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBleHRyYSBrZXkgaW4gYEtleVBhdGhgIGlmIHByb3ZpZGVkLlxuICAgICAgICBpZiAoY29uZmlnLmtleVBhdGggJiYgY29uZmlnLmtleVN0b3JlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRLZXlGaWxlID0geWllbGQgKDAsIHVuZW5jcnlwdGVkX2ZpbGVfc3lzdGVtX2tleXN0b3JlXzEucmVhZEtleUZpbGUpKGNvbmZpZy5rZXlQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWNjb3VudEtleUZpbGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogT25seSBsb2FkIGtleSBpZiBuZXR3b3JrIElEIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5UGFpciA9IGFjY291bnRLZXlGaWxlWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlQYXRoU3RvcmUgPSBuZXcga2V5X3N0b3Jlc18xLkluTWVtb3J5S2V5U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQga2V5UGF0aFN0b3JlLnNldEtleShjb25maWcubmV0d29ya0lkLCBhY2NvdW50S2V5RmlsZVswXSwga2V5UGFpcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLm1hc3RlckFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXN0ZXJBY2NvdW50ID0gYWNjb3VudEtleUZpbGVbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmtleVN0b3JlID0gbmV3IGtleV9zdG9yZXNfMS5NZXJnZUtleVN0b3JlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGhTdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5rZXlTdG9yZVxuICAgICAgICAgICAgICAgICAgICBdLCB7IHdyaXRlS2V5U3RvcmVJbmRleDogMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzLmVudlsnTkVBUl9OT19MT0dTJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgbWFzdGVyIGFjY291bnQgJHthY2NvdW50S2V5RmlsZVswXX0ga2V5IGZyb20gJHtjb25maWcua2V5UGF0aH0gd2l0aCBwdWJsaWMga2V5ID0gJHtrZXlQYWlyLmdldFB1YmxpY0tleSgpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEubG9nV2FybmluZykoYEZhaWxlZCB0byBsb2FkIG1hc3RlciBhY2NvdW50IGtleSBmcm9tICR7Y29uZmlnLmtleVBhdGh9OiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbmVhcl8xLk5lYXIoY29uZmlnKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29ubmVjdCA9IGNvbm5lY3Q7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/connection.js":
/*!****************************************************!*\
  !*** ./node_modules/near-api-js/lib/connection.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connection = void 0;\nconst providers_1 = __webpack_require__(/*! ./providers */ \"(ssr)/./node_modules/near-api-js/lib/providers/index.js\");\nconst signer_1 = __webpack_require__(/*! ./signer */ \"(ssr)/./node_modules/near-api-js/lib/signer.js\");\n/**\n * @param config Contains connection info details\n * @returns {Provider}\n */\nfunction getProvider(config) {\n    switch (config.type) {\n        case undefined:\n            return config;\n        case 'JsonRpcProvider': return new providers_1.JsonRpcProvider(Object.assign({}, config.args));\n        default: throw new Error(`Unknown provider type ${config.type}`);\n    }\n}\n/**\n * @param config Contains connection info details\n * @returns {Signer}\n */\nfunction getSigner(config) {\n    switch (config.type) {\n        case undefined:\n            return config;\n        case 'InMemorySigner': {\n            return new signer_1.InMemorySigner(config.keyStore);\n        }\n        default: throw new Error(`Unknown signer type ${config.type}`);\n    }\n}\n/**\n * Connects an account to a given network via a given provider\n */\nclass Connection {\n    constructor(networkId, provider, signer, jsvmAccountId) {\n        this.networkId = networkId;\n        this.provider = provider;\n        this.signer = signer;\n        this.jsvmAccountId = jsvmAccountId;\n    }\n    /**\n     * @param config Contains connection info details\n     */\n    static fromConfig(config) {\n        const provider = getProvider(config.provider);\n        const signer = getSigner(config.signer);\n        return new Connection(config.networkId, provider, signer, config.jsvmAccountId);\n    }\n}\nexports.Connection = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFVO0FBQ25DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RiwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIvY29ubmVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHByb3ZpZGVyc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzXCIpO1xuY29uc3Qgc2lnbmVyXzEgPSByZXF1aXJlKFwiLi9zaWduZXJcIik7XG4vKipcbiAqIEBwYXJhbSBjb25maWcgQ29udGFpbnMgY29ubmVjdGlvbiBpbmZvIGRldGFpbHNcbiAqIEByZXR1cm5zIHtQcm92aWRlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdmlkZXIoY29uZmlnKSB7XG4gICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIGNhc2UgJ0pzb25ScGNQcm92aWRlcic6IHJldHVybiBuZXcgcHJvdmlkZXJzXzEuSnNvblJwY1Byb3ZpZGVyKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy5hcmdzKSk7XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwcm92aWRlciB0eXBlICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gY29uZmlnIENvbnRhaW5zIGNvbm5lY3Rpb24gaW5mbyBkZXRhaWxzXG4gKiBAcmV0dXJucyB7U2lnbmVyfVxuICovXG5mdW5jdGlvbiBnZXRTaWduZXIoY29uZmlnKSB7XG4gICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIGNhc2UgJ0luTWVtb3J5U2lnbmVyJzoge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzaWduZXJfMS5Jbk1lbW9yeVNpZ25lcihjb25maWcua2V5U3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzaWduZXIgdHlwZSAke2NvbmZpZy50eXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQ29ubmVjdHMgYW4gYWNjb3VudCB0byBhIGdpdmVuIG5ldHdvcmsgdmlhIGEgZ2l2ZW4gcHJvdmlkZXJcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmV0d29ya0lkLCBwcm92aWRlciwgc2lnbmVyLCBqc3ZtQWNjb3VudElkKSB7XG4gICAgICAgIHRoaXMubmV0d29ya0lkID0gbmV0d29ya0lkO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICB0aGlzLmpzdm1BY2NvdW50SWQgPSBqc3ZtQWNjb3VudElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbnRhaW5zIGNvbm5lY3Rpb24gaW5mbyBkZXRhaWxzXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29uZmlnLnByb3ZpZGVyKTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gZ2V0U2lnbmVyKGNvbmZpZy5zaWduZXIpO1xuICAgICAgICByZXR1cm4gbmV3IENvbm5lY3Rpb24oY29uZmlnLm5ldHdvcmtJZCwgcHJvdmlkZXIsIHNpZ25lciwgY29uZmlnLmpzdm1BY2NvdW50SWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/near-api-js/lib/constants.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_FUNCTION_CALL_GAS = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\n// Default amount of gas to be sent with the function calls. Used to pay for the fees\n// incurred while running the contract execution. The unused amount will be refunded back to\n// the originator.\n// Due to protocol changes that charge upfront for the maximum possible gas price inflation due to\n// full blocks, the price of max_prepaid_gas is decreased to `300 * 10**12`.\n// For discussion see https://github.com/nearprotocol/NEPs/issues/67\nexports.DEFAULT_FUNCTION_CALL_GAS = new bn_js_1.default('30000000000000');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQztBQUNqQyxnQ0FBZ0MsbUJBQU8sQ0FBQyxtREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfRlVOQ1RJT05fQ0FMTF9HQVMgPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG4vLyBEZWZhdWx0IGFtb3VudCBvZiBnYXMgdG8gYmUgc2VudCB3aXRoIHRoZSBmdW5jdGlvbiBjYWxscy4gVXNlZCB0byBwYXkgZm9yIHRoZSBmZWVzXG4vLyBpbmN1cnJlZCB3aGlsZSBydW5uaW5nIHRoZSBjb250cmFjdCBleGVjdXRpb24uIFRoZSB1bnVzZWQgYW1vdW50IHdpbGwgYmUgcmVmdW5kZWQgYmFjayB0b1xuLy8gdGhlIG9yaWdpbmF0b3IuXG4vLyBEdWUgdG8gcHJvdG9jb2wgY2hhbmdlcyB0aGF0IGNoYXJnZSB1cGZyb250IGZvciB0aGUgbWF4aW11bSBwb3NzaWJsZSBnYXMgcHJpY2UgaW5mbGF0aW9uIGR1ZSB0b1xuLy8gZnVsbCBibG9ja3MsIHRoZSBwcmljZSBvZiBtYXhfcHJlcGFpZF9nYXMgaXMgZGVjcmVhc2VkIHRvIGAzMDAgKiAxMCoqMTJgLlxuLy8gRm9yIGRpc2N1c3Npb24gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFycHJvdG9jb2wvTkVQcy9pc3N1ZXMvNjdcbmV4cG9ydHMuREVGQVVMVF9GVU5DVElPTl9DQUxMX0dBUyA9IG5ldyBibl9qc18xLmRlZmF1bHQoJzMwMDAwMDAwMDAwMDAwJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/contract.js":
/*!**************************************************!*\
  !*** ./node_modules/near-api-js/lib/contract.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Contract = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nconst depd_1 = __importDefault(__webpack_require__(/*! depd */ \"(ssr)/./node_modules/depd/index.js\"));\nconst providers_1 = __webpack_require__(/*! ./providers */ \"(ssr)/./node_modules/near-api-js/lib/providers/index.js\");\nconst errors_1 = __webpack_require__(/*! ./utils/errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/errors.js\");\n// Makes `function.name` return given name\nfunction nameFunction(name, body) {\n    return {\n        [name](...args) {\n            return body(...args);\n        }\n    }[name];\n}\nconst isUint8Array = (x) => x && x.byteLength !== undefined && x.byteLength === x.length;\nconst isObject = (x) => Object.prototype.toString.call(x) === '[object Object]';\n/**\n * Defines a smart contract on NEAR including the change (mutable) and view (non-mutable) methods\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#contract](https://docs.near.org/tools/near-api-js/quick-reference#contract)\n * @example\n * ```js\n * import { Contract } from 'near-api-js';\n *\n * async function contractExample() {\n *   const methodOptions = {\n *     viewMethods: ['getMessageByAccountId'],\n *     changeMethods: ['addMessage']\n *   };\n *   const contract = new Contract(\n *     wallet.account(),\n *     'contract-id.testnet',\n *     methodOptions\n *   );\n *\n *   // use a contract view method\n *   const messages = await contract.getMessages({\n *     accountId: 'example-account.testnet'\n *   });\n *\n *   // use a contract change method\n *   await contract.addMessage({\n *      meta: 'some info',\n *      callbackUrl: 'https://example.com/callback',\n *      args: { text: 'my message' },\n *      amount: 1\n *   })\n * }\n * ```\n */\nclass Contract {\n    /**\n     * @param account NEAR account to sign change method transactions\n     * @param contractId NEAR account id where the contract is deployed\n     * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`\n     */\n    constructor(account, contractId, options) {\n        this.account = account;\n        this.contractId = contractId;\n        const { viewMethods = [], changeMethods = [] } = options;\n        viewMethods.forEach((methodName) => {\n            Object.defineProperty(this, methodName, {\n                writable: false,\n                enumerable: true,\n                value: nameFunction(methodName, (args = {}, options = {}, ...ignored) => __awaiter(this, void 0, void 0, function* () {\n                    if (ignored.length || !(isObject(args) || isUint8Array(args)) || !isObject(options)) {\n                        throw new errors_1.PositionalArgsError();\n                    }\n                    return this.account.viewFunction(this.contractId, methodName, args, options);\n                }))\n            });\n        });\n        changeMethods.forEach((methodName) => {\n            Object.defineProperty(this, methodName, {\n                writable: false,\n                enumerable: true,\n                value: nameFunction(methodName, (...args) => __awaiter(this, void 0, void 0, function* () {\n                    if (args.length && (args.length > 3 || !(isObject(args[0]) || isUint8Array(args[0])))) {\n                        throw new errors_1.PositionalArgsError();\n                    }\n                    if (args.length > 1 || !(args[0] && args[0].args)) {\n                        const deprecate = (0, depd_1.default)('contract.methodName(args, gas, amount)');\n                        deprecate('use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead');\n                        return this._changeMethod({\n                            methodName,\n                            args: args[0],\n                            gas: args[1],\n                            amount: args[2]\n                        });\n                    }\n                    return this._changeMethod(Object.assign({ methodName }, args[0]));\n                }))\n            });\n        });\n    }\n    _changeMethod({ args, methodName, gas, amount, meta, callbackUrl }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            validateBNLike({ gas, amount });\n            const rawResult = yield this.account.functionCall({\n                contractId: this.contractId,\n                methodName,\n                args,\n                gas,\n                attachedDeposit: amount,\n                walletMeta: meta,\n                walletCallbackUrl: callbackUrl\n            });\n            return (0, providers_1.getTransactionLastResult)(rawResult);\n        });\n    }\n}\nexports.Contract = Contract;\n/**\n * Validation on arguments being a big number from bn.js\n * Throws if an argument is not in BN format or otherwise invalid\n * @param argMap\n */\nfunction validateBNLike(argMap) {\n    const bnLike = 'number, decimal string or BN';\n    for (const argName of Object.keys(argMap)) {\n        const argValue = argMap[argName];\n        if (argValue && !bn_js_1.default.isBN(argValue) && isNaN(argValue)) {\n            throw new errors_1.ArgumentTypeError(argName, bnLike, argValue);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2NvbnRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixnQ0FBZ0MsbUJBQU8sQ0FBQyxtREFBTztBQUMvQywrQkFBK0IsbUJBQU8sQ0FBQyxnREFBTTtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBYTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMENBQTBDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSw4REFBOEQsWUFBWTtBQUMxRSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixrREFBa0Q7QUFDdEU7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2NvbnRyYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyYWN0ID0gdm9pZCAwO1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuY29uc3QgZGVwZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZXBkXCIpKTtcbmNvbnN0IHByb3ZpZGVyc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi91dGlscy9lcnJvcnNcIik7XG4vLyBNYWtlcyBgZnVuY3Rpb24ubmFtZWAgcmV0dXJuIGdpdmVuIG5hbWVcbmZ1bmN0aW9uIG5hbWVGdW5jdGlvbihuYW1lLCBib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW25hbWVdKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5KC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVtuYW1lXTtcbn1cbmNvbnN0IGlzVWludDhBcnJheSA9ICh4KSA9PiB4ICYmIHguYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHguYnl0ZUxlbmd0aCA9PT0geC5sZW5ndGg7XG5jb25zdCBpc09iamVjdCA9ICh4KSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuLyoqXG4gKiBEZWZpbmVzIGEgc21hcnQgY29udHJhY3Qgb24gTkVBUiBpbmNsdWRpbmcgdGhlIGNoYW5nZSAobXV0YWJsZSkgYW5kIHZpZXcgKG5vbi1tdXRhYmxlKSBtZXRob2RzXG4gKlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSNjb250cmFjdF0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSNjb250cmFjdClcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tICduZWFyLWFwaS1qcyc7XG4gKlxuICogYXN5bmMgZnVuY3Rpb24gY29udHJhY3RFeGFtcGxlKCkge1xuICogICBjb25zdCBtZXRob2RPcHRpb25zID0ge1xuICogICAgIHZpZXdNZXRob2RzOiBbJ2dldE1lc3NhZ2VCeUFjY291bnRJZCddLFxuICogICAgIGNoYW5nZU1ldGhvZHM6IFsnYWRkTWVzc2FnZSddXG4gKiAgIH07XG4gKiAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFxuICogICAgIHdhbGxldC5hY2NvdW50KCksXG4gKiAgICAgJ2NvbnRyYWN0LWlkLnRlc3RuZXQnLFxuICogICAgIG1ldGhvZE9wdGlvbnNcbiAqICAgKTtcbiAqXG4gKiAgIC8vIHVzZSBhIGNvbnRyYWN0IHZpZXcgbWV0aG9kXG4gKiAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgY29udHJhY3QuZ2V0TWVzc2FnZXMoe1xuICogICAgIGFjY291bnRJZDogJ2V4YW1wbGUtYWNjb3VudC50ZXN0bmV0J1xuICogICB9KTtcbiAqXG4gKiAgIC8vIHVzZSBhIGNvbnRyYWN0IGNoYW5nZSBtZXRob2RcbiAqICAgYXdhaXQgY29udHJhY3QuYWRkTWVzc2FnZSh7XG4gKiAgICAgIG1ldGE6ICdzb21lIGluZm8nLFxuICogICAgICBjYWxsYmFja1VybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vY2FsbGJhY2snLFxuICogICAgICBhcmdzOiB7IHRleHQ6ICdteSBtZXNzYWdlJyB9LFxuICogICAgICBhbW91bnQ6IDFcbiAqICAgfSlcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBDb250cmFjdCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFjY291bnQgTkVBUiBhY2NvdW50IHRvIHNpZ24gY2hhbmdlIG1ldGhvZCB0cmFuc2FjdGlvbnNcbiAgICAgKiBAcGFyYW0gY29udHJhY3RJZCBORUFSIGFjY291bnQgaWQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMgTkVBUiBzbWFydCBjb250cmFjdCBtZXRob2RzIHRoYXQgeW91ciBhcHBsaWNhdGlvbiB3aWxsIHVzZS4gVGhlc2Ugd2lsbCBiZSBhdmFpbGFibGUgYXMgYGNvbnRyYWN0Lm1ldGhvZE5hbWVgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWNjb3VudCwgY29udHJhY3RJZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgICAgICB0aGlzLmNvbnRyYWN0SWQgPSBjb250cmFjdElkO1xuICAgICAgICBjb25zdCB7IHZpZXdNZXRob2RzID0gW10sIGNoYW5nZU1ldGhvZHMgPSBbXSB9ID0gb3B0aW9ucztcbiAgICAgICAgdmlld01ldGhvZHMuZm9yRWFjaCgobWV0aG9kTmFtZSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZUZ1bmN0aW9uKG1ldGhvZE5hbWUsIChhcmdzID0ge30sIG9wdGlvbnMgPSB7fSwgLi4uaWdub3JlZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlZC5sZW5ndGggfHwgIShpc09iamVjdChhcmdzKSB8fCBpc1VpbnQ4QXJyYXkoYXJncykpIHx8ICFpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBvc2l0aW9uYWxBcmdzRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50LnZpZXdGdW5jdGlvbih0aGlzLmNvbnRyYWN0SWQsIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFuZ2VNZXRob2RzLmZvckVhY2goKG1ldGhvZE5hbWUpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBtZXRob2ROYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVGdW5jdGlvbihtZXRob2ROYW1lLCAoLi4uYXJncykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggJiYgKGFyZ3MubGVuZ3RoID4gMyB8fCAhKGlzT2JqZWN0KGFyZ3NbMF0pIHx8IGlzVWludDhBcnJheShhcmdzWzBdKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUG9zaXRpb25hbEFyZ3NFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEgfHwgIShhcmdzWzBdICYmIGFyZ3NbMF0uYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcHJlY2F0ZSA9ICgwLCBkZXBkXzEuZGVmYXVsdCkoJ2NvbnRyYWN0Lm1ldGhvZE5hbWUoYXJncywgZ2FzLCBhbW91bnQpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGUoJ3VzZSBgY29udHJhY3QubWV0aG9kTmFtZSh7IGFyZ3MsIGdhcz8sIGFtb3VudD8sIGNhbGxiYWNrVXJsPywgbWV0YT8gfSlgIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VNZXRob2Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXM6IGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBhcmdzWzJdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlTWV0aG9kKE9iamVjdC5hc3NpZ24oeyBtZXRob2ROYW1lIH0sIGFyZ3NbMF0pKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NoYW5nZU1ldGhvZCh7IGFyZ3MsIG1ldGhvZE5hbWUsIGdhcywgYW1vdW50LCBtZXRhLCBjYWxsYmFja1VybCB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUJOTGlrZSh7IGdhcywgYW1vdW50IH0pO1xuICAgICAgICAgICAgY29uc3QgcmF3UmVzdWx0ID0geWllbGQgdGhpcy5hY2NvdW50LmZ1bmN0aW9uQ2FsbCh7XG4gICAgICAgICAgICAgICAgY29udHJhY3RJZDogdGhpcy5jb250cmFjdElkLFxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICBnYXMsXG4gICAgICAgICAgICAgICAgYXR0YWNoZWREZXBvc2l0OiBhbW91bnQsXG4gICAgICAgICAgICAgICAgd2FsbGV0TWV0YTogbWV0YSxcbiAgICAgICAgICAgICAgICB3YWxsZXRDYWxsYmFja1VybDogY2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwcm92aWRlcnNfMS5nZXRUcmFuc2FjdGlvbkxhc3RSZXN1bHQpKHJhd1Jlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3QgPSBDb250cmFjdDtcbi8qKlxuICogVmFsaWRhdGlvbiBvbiBhcmd1bWVudHMgYmVpbmcgYSBiaWcgbnVtYmVyIGZyb20gYm4uanNcbiAqIFRocm93cyBpZiBhbiBhcmd1bWVudCBpcyBub3QgaW4gQk4gZm9ybWF0IG9yIG90aGVyd2lzZSBpbnZhbGlkXG4gKiBAcGFyYW0gYXJnTWFwXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQk5MaWtlKGFyZ01hcCkge1xuICAgIGNvbnN0IGJuTGlrZSA9ICdudW1iZXIsIGRlY2ltYWwgc3RyaW5nIG9yIEJOJztcbiAgICBmb3IgKGNvbnN0IGFyZ05hbWUgb2YgT2JqZWN0LmtleXMoYXJnTWFwKSkge1xuICAgICAgICBjb25zdCBhcmdWYWx1ZSA9IGFyZ01hcFthcmdOYW1lXTtcbiAgICAgICAgaWYgKGFyZ1ZhbHVlICYmICFibl9qc18xLmRlZmF1bHQuaXNCTihhcmdWYWx1ZSkgJiYgaXNOYU4oYXJnVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRUeXBlRXJyb3IoYXJnTmFtZSwgYm5MaWtlLCBhcmdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/generated/rpc_error_schema.json":
/*!**********************************************************************!*\
  !*** ./node_modules/near-api-js/lib/generated/rpc_error_schema.json ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"schema":{"BadUTF16":{"name":"BadUTF16","subtypes":[],"props":{}},"BadUTF8":{"name":"BadUTF8","subtypes":[],"props":{}},"BalanceExceeded":{"name":"BalanceExceeded","subtypes":[],"props":{}},"BreakpointTrap":{"name":"BreakpointTrap","subtypes":[],"props":{}},"CacheError":{"name":"CacheError","subtypes":["ReadError","WriteError","DeserializationError","SerializationError"],"props":{}},"CallIndirectOOB":{"name":"CallIndirectOOB","subtypes":[],"props":{}},"CannotAppendActionToJointPromise":{"name":"CannotAppendActionToJointPromise","subtypes":[],"props":{}},"CannotReturnJointPromise":{"name":"CannotReturnJointPromise","subtypes":[],"props":{}},"CodeDoesNotExist":{"name":"CodeDoesNotExist","subtypes":[],"props":{"account_id":""}},"CompilationError":{"name":"CompilationError","subtypes":["CodeDoesNotExist","PrepareError","WasmerCompileError"],"props":{}},"ContractSizeExceeded":{"name":"ContractSizeExceeded","subtypes":[],"props":{"limit":"","size":""}},"Deprecated":{"name":"Deprecated","subtypes":[],"props":{"method_name":""}},"Deserialization":{"name":"Deserialization","subtypes":[],"props":{}},"DeserializationError":{"name":"DeserializationError","subtypes":[],"props":{}},"EmptyMethodName":{"name":"EmptyMethodName","subtypes":[],"props":{}},"FunctionCallError":{"name":"FunctionCallError","subtypes":["CompilationError","LinkError","MethodResolveError","WasmTrap","WasmUnknownError","HostError","EvmError"],"props":{}},"GasExceeded":{"name":"GasExceeded","subtypes":[],"props":{}},"GasInstrumentation":{"name":"GasInstrumentation","subtypes":[],"props":{}},"GasLimitExceeded":{"name":"GasLimitExceeded","subtypes":[],"props":{}},"GenericTrap":{"name":"GenericTrap","subtypes":[],"props":{}},"GuestPanic":{"name":"GuestPanic","subtypes":[],"props":{"panic_msg":""}},"HostError":{"name":"HostError","subtypes":["BadUTF16","BadUTF8","GasExceeded","GasLimitExceeded","BalanceExceeded","EmptyMethodName","GuestPanic","IntegerOverflow","InvalidPromiseIndex","CannotAppendActionToJointPromise","CannotReturnJointPromise","InvalidPromiseResultIndex","InvalidRegisterId","IteratorWasInvalidated","MemoryAccessViolation","InvalidReceiptIndex","InvalidIteratorIndex","InvalidAccountId","InvalidMethodName","InvalidPublicKey","ProhibitedInView","NumberOfLogsExceeded","KeyLengthExceeded","ValueLengthExceeded","TotalLogLengthExceeded","NumberPromisesExceeded","NumberInputDataDependenciesExceeded","ReturnedValueLengthExceeded","ContractSizeExceeded","Deprecated"],"props":{}},"IllegalArithmetic":{"name":"IllegalArithmetic","subtypes":[],"props":{}},"IncorrectCallIndirectSignature":{"name":"IncorrectCallIndirectSignature","subtypes":[],"props":{}},"Instantiate":{"name":"Instantiate","subtypes":[],"props":{}},"IntegerOverflow":{"name":"IntegerOverflow","subtypes":[],"props":{}},"InternalMemoryDeclared":{"name":"InternalMemoryDeclared","subtypes":[],"props":{}},"InvalidAccountId":{"name":"InvalidAccountId","subtypes":[],"props":{"account_id":""}},"InvalidIteratorIndex":{"name":"InvalidIteratorIndex","subtypes":[],"props":{"iterator_index":""}},"InvalidMethodName":{"name":"InvalidMethodName","subtypes":[],"props":{}},"InvalidPromiseIndex":{"name":"InvalidPromiseIndex","subtypes":[],"props":{"promise_idx":""}},"InvalidPromiseResultIndex":{"name":"InvalidPromiseResultIndex","subtypes":[],"props":{"result_idx":""}},"InvalidPublicKey":{"name":"InvalidPublicKey","subtypes":[],"props":{}},"InvalidReceiptIndex":{"name":"InvalidReceiptIndex","subtypes":[],"props":{"receipt_index":""}},"InvalidRegisterId":{"name":"InvalidRegisterId","subtypes":[],"props":{"register_id":""}},"IteratorWasInvalidated":{"name":"IteratorWasInvalidated","subtypes":[],"props":{"iterator_index":""}},"KeyLengthExceeded":{"name":"KeyLengthExceeded","subtypes":[],"props":{"length":"","limit":""}},"LinkError":{"name":"LinkError","subtypes":[],"props":{"msg":""}},"Memory":{"name":"Memory","subtypes":[],"props":{}},"MemoryAccessViolation":{"name":"MemoryAccessViolation","subtypes":[],"props":{}},"MemoryOutOfBounds":{"name":"MemoryOutOfBounds","subtypes":[],"props":{}},"MethodEmptyName":{"name":"MethodEmptyName","subtypes":[],"props":{}},"MethodInvalidSignature":{"name":"MethodInvalidSignature","subtypes":[],"props":{}},"MethodNotFound":{"name":"MethodNotFound","subtypes":[],"props":{}},"MethodResolveError":{"name":"MethodResolveError","subtypes":["MethodEmptyName","MethodUTF8Error","MethodNotFound","MethodInvalidSignature"],"props":{}},"MethodUTF8Error":{"name":"MethodUTF8Error","subtypes":[],"props":{}},"MisalignedAtomicAccess":{"name":"MisalignedAtomicAccess","subtypes":[],"props":{}},"NumberInputDataDependenciesExceeded":{"name":"NumberInputDataDependenciesExceeded","subtypes":[],"props":{"limit":"","number_of_input_data_dependencies":""}},"NumberOfLogsExceeded":{"name":"NumberOfLogsExceeded","subtypes":[],"props":{"limit":""}},"NumberPromisesExceeded":{"name":"NumberPromisesExceeded","subtypes":[],"props":{"limit":"","number_of_promises":""}},"PrepareError":{"name":"PrepareError","subtypes":["Serialization","Deserialization","InternalMemoryDeclared","GasInstrumentation","StackHeightInstrumentation","Instantiate","Memory"],"props":{}},"ProhibitedInView":{"name":"ProhibitedInView","subtypes":[],"props":{"method_name":""}},"ReadError":{"name":"ReadError","subtypes":[],"props":{}},"ReturnedValueLengthExceeded":{"name":"ReturnedValueLengthExceeded","subtypes":[],"props":{"length":"","limit":""}},"Serialization":{"name":"Serialization","subtypes":[],"props":{}},"SerializationError":{"name":"SerializationError","subtypes":[],"props":{"hash":""}},"StackHeightInstrumentation":{"name":"StackHeightInstrumentation","subtypes":[],"props":{}},"StackOverflow":{"name":"StackOverflow","subtypes":[],"props":{}},"TotalLogLengthExceeded":{"name":"TotalLogLengthExceeded","subtypes":[],"props":{"length":"","limit":""}},"Unreachable":{"name":"Unreachable","subtypes":[],"props":{}},"ValueLengthExceeded":{"name":"ValueLengthExceeded","subtypes":[],"props":{"length":"","limit":""}},"WasmTrap":{"name":"WasmTrap","subtypes":["Unreachable","IncorrectCallIndirectSignature","MemoryOutOfBounds","CallIndirectOOB","IllegalArithmetic","MisalignedAtomicAccess","BreakpointTrap","StackOverflow","GenericTrap"],"props":{}},"WasmUnknownError":{"name":"WasmUnknownError","subtypes":[],"props":{}},"WasmerCompileError":{"name":"WasmerCompileError","subtypes":[],"props":{"msg":""}},"WriteError":{"name":"WriteError","subtypes":[],"props":{}},"AccessKeyNotFound":{"name":"AccessKeyNotFound","subtypes":[],"props":{"account_id":"","public_key":""}},"AccountAlreadyExists":{"name":"AccountAlreadyExists","subtypes":[],"props":{"account_id":""}},"AccountDoesNotExist":{"name":"AccountDoesNotExist","subtypes":[],"props":{"account_id":""}},"ActionError":{"name":"ActionError","subtypes":["AccountAlreadyExists","AccountDoesNotExist","CreateAccountOnlyByRegistrar","CreateAccountNotAllowed","ActorNoPermission","DeleteKeyDoesNotExist","AddKeyAlreadyExists","DeleteAccountStaking","LackBalanceForState","TriesToUnstake","TriesToStake","InsufficientStake","FunctionCallError","NewReceiptValidationError","OnlyImplicitAccountCreationAllowed"],"props":{"index":""}},"ActionsValidationError":{"name":"ActionsValidationError","subtypes":["DeleteActionMustBeFinal","TotalPrepaidGasExceeded","TotalNumberOfActionsExceeded","AddKeyMethodNamesNumberOfBytesExceeded","AddKeyMethodNameLengthExceeded","IntegerOverflow","InvalidAccountId","ContractSizeExceeded","FunctionCallMethodNameLengthExceeded","FunctionCallArgumentsLengthExceeded","UnsuitableStakingKey","FunctionCallZeroAttachedGas"],"props":{}},"ActorNoPermission":{"name":"ActorNoPermission","subtypes":[],"props":{"account_id":"","actor_id":""}},"AddKeyAlreadyExists":{"name":"AddKeyAlreadyExists","subtypes":[],"props":{"account_id":"","public_key":""}},"AddKeyMethodNameLengthExceeded":{"name":"AddKeyMethodNameLengthExceeded","subtypes":[],"props":{"length":"","limit":""}},"AddKeyMethodNamesNumberOfBytesExceeded":{"name":"AddKeyMethodNamesNumberOfBytesExceeded","subtypes":[],"props":{"limit":"","total_number_of_bytes":""}},"BalanceMismatchError":{"name":"BalanceMismatchError","subtypes":[],"props":{"final_accounts_balance":"","final_postponed_receipts_balance":"","incoming_receipts_balance":"","incoming_validator_rewards":"","initial_accounts_balance":"","initial_postponed_receipts_balance":"","new_delayed_receipts_balance":"","other_burnt_amount":"","outgoing_receipts_balance":"","processed_delayed_receipts_balance":"","slashed_burnt_amount":"","tx_burnt_amount":""}},"CostOverflow":{"name":"CostOverflow","subtypes":[],"props":{}},"CreateAccountNotAllowed":{"name":"CreateAccountNotAllowed","subtypes":[],"props":{"account_id":"","predecessor_id":""}},"CreateAccountOnlyByRegistrar":{"name":"CreateAccountOnlyByRegistrar","subtypes":[],"props":{"account_id":"","predecessor_id":"","registrar_account_id":""}},"DeleteAccountStaking":{"name":"DeleteAccountStaking","subtypes":[],"props":{"account_id":""}},"DeleteActionMustBeFinal":{"name":"DeleteActionMustBeFinal","subtypes":[],"props":{}},"DeleteKeyDoesNotExist":{"name":"DeleteKeyDoesNotExist","subtypes":[],"props":{"account_id":"","public_key":""}},"DepositWithFunctionCall":{"name":"DepositWithFunctionCall","subtypes":[],"props":{}},"Expired":{"name":"Expired","subtypes":[],"props":{}},"FunctionCallArgumentsLengthExceeded":{"name":"FunctionCallArgumentsLengthExceeded","subtypes":[],"props":{"length":"","limit":""}},"FunctionCallMethodNameLengthExceeded":{"name":"FunctionCallMethodNameLengthExceeded","subtypes":[],"props":{"length":"","limit":""}},"FunctionCallZeroAttachedGas":{"name":"FunctionCallZeroAttachedGas","subtypes":[],"props":{}},"InsufficientStake":{"name":"InsufficientStake","subtypes":[],"props":{"account_id":"","minimum_stake":"","stake":""}},"InvalidAccessKeyError":{"name":"InvalidAccessKeyError","subtypes":["AccessKeyNotFound","ReceiverMismatch","MethodNameMismatch","RequiresFullAccess","NotEnoughAllowance","DepositWithFunctionCall"],"props":{}},"InvalidChain":{"name":"InvalidChain","subtypes":[],"props":{}},"InvalidDataReceiverId":{"name":"InvalidDataReceiverId","subtypes":[],"props":{"account_id":""}},"InvalidNonce":{"name":"InvalidNonce","subtypes":[],"props":{"ak_nonce":"","tx_nonce":""}},"InvalidPredecessorId":{"name":"InvalidPredecessorId","subtypes":[],"props":{"account_id":""}},"InvalidReceiverId":{"name":"InvalidReceiverId","subtypes":[],"props":{"account_id":""}},"InvalidSignature":{"name":"InvalidSignature","subtypes":[],"props":{}},"InvalidSignerId":{"name":"InvalidSignerId","subtypes":[],"props":{"account_id":""}},"InvalidTxError":{"name":"InvalidTxError","subtypes":["InvalidAccessKeyError","InvalidSignerId","SignerDoesNotExist","InvalidNonce","InvalidReceiverId","InvalidSignature","NotEnoughBalance","LackBalanceForState","CostOverflow","InvalidChain","Expired","ActionsValidation"],"props":{}},"LackBalanceForState":{"name":"LackBalanceForState","subtypes":[],"props":{"account_id":"","amount":""}},"MethodNameMismatch":{"name":"MethodNameMismatch","subtypes":[],"props":{"method_name":""}},"NotEnoughAllowance":{"name":"NotEnoughAllowance","subtypes":[],"props":{"account_id":"","allowance":"","cost":"","public_key":""}},"NotEnoughBalance":{"name":"NotEnoughBalance","subtypes":[],"props":{"balance":"","cost":"","signer_id":""}},"OnlyImplicitAccountCreationAllowed":{"name":"OnlyImplicitAccountCreationAllowed","subtypes":[],"props":{"account_id":""}},"ReceiptValidationError":{"name":"ReceiptValidationError","subtypes":["InvalidPredecessorId","InvalidReceiverId","InvalidSignerId","InvalidDataReceiverId","ReturnedValueLengthExceeded","NumberInputDataDependenciesExceeded","ActionsValidation"],"props":{}},"ReceiverMismatch":{"name":"ReceiverMismatch","subtypes":[],"props":{"ak_receiver":"","tx_receiver":""}},"RequiresFullAccess":{"name":"RequiresFullAccess","subtypes":[],"props":{}},"SignerDoesNotExist":{"name":"SignerDoesNotExist","subtypes":[],"props":{"signer_id":""}},"TotalNumberOfActionsExceeded":{"name":"TotalNumberOfActionsExceeded","subtypes":[],"props":{"limit":"","total_number_of_actions":""}},"TotalPrepaidGasExceeded":{"name":"TotalPrepaidGasExceeded","subtypes":[],"props":{"limit":"","total_prepaid_gas":""}},"TriesToStake":{"name":"TriesToStake","subtypes":[],"props":{"account_id":"","balance":"","locked":"","stake":""}},"TriesToUnstake":{"name":"TriesToUnstake","subtypes":[],"props":{"account_id":""}},"TxExecutionError":{"name":"TxExecutionError","subtypes":["ActionError","InvalidTxError"],"props":{}},"UnsuitableStakingKey":{"name":"UnsuitableStakingKey","subtypes":[],"props":{"public_key":""}},"Closed":{"name":"Closed","subtypes":[],"props":{}},"InternalError":{"name":"InternalError","subtypes":[],"props":{}},"ServerError":{"name":"ServerError","subtypes":["TxExecutionError","Timeout","Closed","InternalError"],"props":{}},"Timeout":{"name":"Timeout","subtypes":[],"props":{}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/near-api-js/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keyStores = void 0;\n/** @ignore @module */\nexports.keyStores = __importStar(__webpack_require__(/*! ./key_stores/index */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/index.js\"));\n__exportStar(__webpack_require__(/*! ./common-index */ \"(ssr)/./node_modules/near-api-js/lib/common-index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./connect */ \"(ssr)/./node_modules/near-api-js/lib/connect.js\"), exports);\n__exportStar(__webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/near-api-js/lib/constants.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUIsZ0JBQWdCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDckMsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBYSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5rZXlTdG9yZXMgPSB2b2lkIDA7XG4vKiogQGlnbm9yZSBAbW9kdWxlICovXG5leHBvcnRzLmtleVN0b3JlcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9rZXlfc3RvcmVzL2luZGV4XCIpKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb24taW5kZXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nvbm5lY3RcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js":
/*!************************************************************************************!*\
  !*** ./node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserLocalStorageKeyStore = void 0;\nconst keystore_1 = __webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/keystore.js\");\nconst key_pair_1 = __webpack_require__(/*! ../utils/key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\nconst LOCAL_STORAGE_KEY_PREFIX = 'near-api-js:keystore:';\n/**\n * This class is used to store keys in the browsers local storage.\n *\n * @see [https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store](https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store)\n * @example\n * ```js\n * import { connect, keyStores } from 'near-api-js';\n *\n * const keyStore = new keyStores.BrowserLocalStorageKeyStore();\n * const config = {\n *   keyStore, // instance of BrowserLocalStorageKeyStore\n *   networkId: 'testnet',\n *   nodeUrl: 'https://rpc.testnet.near.org',\n *   walletUrl: 'https://wallet.testnet.near.org',\n *   helperUrl: 'https://helper.testnet.near.org',\n *   explorerUrl: 'https://explorer.testnet.near.org'\n * };\n *\n * // inside an async function\n * const near = await connect(config)\n * ```\n */\nclass BrowserLocalStorageKeyStore extends keystore_1.KeyStore {\n    /**\n     * @param localStorage defaults to window.localStorage\n     * @param prefix defaults to `near-api-js:keystore:`\n     */\n    constructor(localStorage = window.localStorage, prefix = LOCAL_STORAGE_KEY_PREFIX) {\n        super();\n        this.localStorage = localStorage;\n        this.prefix = prefix;\n    }\n    /**\n     * Stores a {@link utils/key_pair!KeyPair} in local storage.\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     * @param keyPair The key pair to store in local storage\n     */\n    setKey(networkId, accountId, keyPair) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localStorage.setItem(this.storageKeyForSecretKey(networkId, accountId), keyPair.toString());\n        });\n    }\n    /**\n     * Gets a {@link utils/key_pair!KeyPair} from local storage\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     * @returns {Promise<KeyPair>}\n     */\n    getKey(networkId, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const value = this.localStorage.getItem(this.storageKeyForSecretKey(networkId, accountId));\n            if (!value) {\n                return null;\n            }\n            return key_pair_1.KeyPair.fromString(value);\n        });\n    }\n    /**\n     * Removes a {@link utils/key_pair!KeyPair} from local storage\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     */\n    removeKey(networkId, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localStorage.removeItem(this.storageKeyForSecretKey(networkId, accountId));\n        });\n    }\n    /**\n     * Removes all items that start with `prefix` from local storage\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const key of this.storageKeys()) {\n                if (key.startsWith(this.prefix)) {\n                    this.localStorage.removeItem(key);\n                }\n            }\n        });\n    }\n    /**\n     * Get the network(s) from local storage\n     * @returns {Promise<string[]>}\n     */\n    getNetworks() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = new Set();\n            for (const key of this.storageKeys()) {\n                if (key.startsWith(this.prefix)) {\n                    const parts = key.substring(this.prefix.length).split(':');\n                    result.add(parts[1]);\n                }\n            }\n            return Array.from(result.values());\n        });\n    }\n    /**\n     * Gets the account(s) from local storage\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     */\n    getAccounts(networkId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = new Array();\n            for (const key of this.storageKeys()) {\n                if (key.startsWith(this.prefix)) {\n                    const parts = key.substring(this.prefix.length).split(':');\n                    if (parts[1] === networkId) {\n                        result.push(parts[0]);\n                    }\n                }\n            }\n            return result;\n        });\n    }\n    /**\n     * @hidden\n     * Helper function to retrieve a local storage key\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the storage keythat's sought\n     * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`\n     */\n    storageKeyForSecretKey(networkId, accountId) {\n        return `${this.prefix}${accountId}:${networkId}`;\n    }\n    /** @hidden */\n    *storageKeys() {\n        for (let i = 0; i < this.localStorage.length; i++) {\n            yield this.localStorage.key(i);\n        }\n    }\n}\nexports.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2tleV9zdG9yZXMvYnJvd3Nlcl9sb2NhbF9zdG9yYWdlX2tleV9zdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCLFlBQVksRUFBRSxVQUFVLEdBQUcsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIva2V5X3N0b3Jlcy9icm93c2VyX2xvY2FsX3N0b3JhZ2Vfa2V5X3N0b3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IGtleXN0b3JlXzEgPSByZXF1aXJlKFwiLi9rZXlzdG9yZVwiKTtcbmNvbnN0IGtleV9wYWlyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMva2V5X3BhaXJcIik7XG5jb25zdCBMT0NBTF9TVE9SQUdFX0tFWV9QUkVGSVggPSAnbmVhci1hcGktanM6a2V5c3RvcmU6Jztcbi8qKlxuICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIHN0b3JlIGtleXMgaW4gdGhlIGJyb3dzZXJzIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvZGV2ZWxvcC9mcm9udC1lbmQvbmFqLXF1aWNrLXJlZmVyZW5jZSNrZXktc3RvcmVdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9kb2NzL2RldmVsb3AvZnJvbnQtZW5kL25hai1xdWljay1yZWZlcmVuY2Uja2V5LXN0b3JlKVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBjb25uZWN0LCBrZXlTdG9yZXMgfSBmcm9tICduZWFyLWFwaS1qcyc7XG4gKlxuICogY29uc3Qga2V5U3RvcmUgPSBuZXcga2V5U3RvcmVzLkJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZSgpO1xuICogY29uc3QgY29uZmlnID0ge1xuICogICBrZXlTdG9yZSwgLy8gaW5zdGFuY2Ugb2YgQnJvd3NlckxvY2FsU3RvcmFnZUtleVN0b3JlXG4gKiAgIG5ldHdvcmtJZDogJ3Rlc3RuZXQnLFxuICogICBub2RlVXJsOiAnaHR0cHM6Ly9ycGMudGVzdG5ldC5uZWFyLm9yZycsXG4gKiAgIHdhbGxldFVybDogJ2h0dHBzOi8vd2FsbGV0LnRlc3RuZXQubmVhci5vcmcnLFxuICogICBoZWxwZXJVcmw6ICdodHRwczovL2hlbHBlci50ZXN0bmV0Lm5lYXIub3JnJyxcbiAqICAgZXhwbG9yZXJVcmw6ICdodHRwczovL2V4cGxvcmVyLnRlc3RuZXQubmVhci5vcmcnXG4gKiB9O1xuICpcbiAqIC8vIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblxuICogY29uc3QgbmVhciA9IGF3YWl0IGNvbm5lY3QoY29uZmlnKVxuICogYGBgXG4gKi9cbmNsYXNzIEJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZSBleHRlbmRzIGtleXN0b3JlXzEuS2V5U3RvcmUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsb2NhbFN0b3JhZ2UgZGVmYXVsdHMgdG8gd2luZG93LmxvY2FsU3RvcmFnZVxuICAgICAqIEBwYXJhbSBwcmVmaXggZGVmYXVsdHMgdG8gYG5lYXItYXBpLWpzOmtleXN0b3JlOmBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlLCBwcmVmaXggPSBMT0NBTF9TVE9SQUdFX0tFWV9QUkVGSVgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2U7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgYSB7QGxpbmsgdXRpbHMva2V5X3BhaXIhS2V5UGFpcn0gaW4gbG9jYWwgc3RvcmFnZS5cbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIFRoZSB0YXJnZXRlZCBuZXR3b3JrLiAoZXguIGRlZmF1bHQsIGJldGFuZXQsIGV0Y+KApilcbiAgICAgKiBAcGFyYW0gYWNjb3VudElkIFRoZSBORUFSIGFjY291bnQgdGllZCB0byB0aGUga2V5IHBhaXJcbiAgICAgKiBAcGFyYW0ga2V5UGFpciBUaGUga2V5IHBhaXIgdG8gc3RvcmUgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIHNldEtleShuZXR3b3JrSWQsIGFjY291bnRJZCwga2V5UGFpcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXlGb3JTZWNyZXRLZXkobmV0d29ya0lkLCBhY2NvdW50SWQpLCBrZXlQYWlyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHtAbGluayB1dGlscy9rZXlfcGFpciFLZXlQYWlyfSBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIFRoZSB0YXJnZXRlZCBuZXR3b3JrLiAoZXguIGRlZmF1bHQsIGJldGFuZXQsIGV0Y+KApilcbiAgICAgKiBAcGFyYW0gYWNjb3VudElkIFRoZSBORUFSIGFjY291bnQgdGllZCB0byB0aGUga2V5IHBhaXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXlQYWlyPn1cbiAgICAgKi9cbiAgICBnZXRLZXkobmV0d29ya0lkLCBhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXlGb3JTZWNyZXRLZXkobmV0d29ya0lkLCBhY2NvdW50SWQpKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlfcGFpcl8xLktleVBhaXIuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEge0BsaW5rIHV0aWxzL2tleV9wYWlyIUtleVBhaXJ9IGZyb20gbG9jYWwgc3RvcmFnZVxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0aWVkIHRvIHRoZSBrZXkgcGFpclxuICAgICAqL1xuICAgIHJlbW92ZUtleShuZXR3b3JrSWQsIGFjY291bnRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXlGb3JTZWNyZXRLZXkobmV0d29ya0lkLCBhY2NvdW50SWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGl0ZW1zIHRoYXQgc3RhcnQgd2l0aCBgcHJlZml4YCBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuc3RvcmFnZUtleXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCh0aGlzLnByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV0d29yayhzKSBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59XG4gICAgICovXG4gICAgZ2V0TmV0d29ya3MoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLnN0b3JhZ2VLZXlzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgodGhpcy5wcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnN1YnN0cmluZyh0aGlzLnByZWZpeC5sZW5ndGgpLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQocGFydHNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJlc3VsdC52YWx1ZXMoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhY2NvdW50KHMpIGZyb20gbG9jYWwgc3RvcmFnZVxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqL1xuICAgIGdldEFjY291bnRzKG5ldHdvcmtJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLnN0b3JhZ2VLZXlzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgodGhpcy5wcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnN1YnN0cmluZyh0aGlzLnByZWZpeC5sZW5ndGgpLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1sxXSA9PT0gbmV0d29ya0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byByZXRyaWV2ZSBhIGxvY2FsIHN0b3JhZ2Uga2V5XG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCBUaGUgdGFyZ2V0ZWQgbmV0d29yay4gKGV4LiBkZWZhdWx0LCBiZXRhbmV0LCBldGPigKYpXG4gICAgICogQHBhcmFtIGFjY291bnRJZCBUaGUgTkVBUiBhY2NvdW50IHRpZWQgdG8gdGhlIHN0b3JhZ2Uga2V5dGhhdCdzIHNvdWdodFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEFuIGV4YW1wbGUgbWlnaHQgYmU6IGBuZWFyLWFwaS1qczprZXlzdG9yZTpuZWFyLWZyaWVuZDpkZWZhdWx0YFxuICAgICAqL1xuICAgIHN0b3JhZ2VLZXlGb3JTZWNyZXRLZXkobmV0d29ya0lkLCBhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fSR7YWNjb3VudElkfToke25ldHdvcmtJZH1gO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgICpzdG9yYWdlS2V5cygpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5sb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmUgPSBCcm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/key_stores/in_memory_key_store.js":
/*!************************************************************************!*\
  !*** ./node_modules/near-api-js/lib/key_stores/in_memory_key_store.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryKeyStore = void 0;\nconst keystore_1 = __webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/keystore.js\");\nconst key_pair_1 = __webpack_require__(/*! ../utils/key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\n/**\n * Simple in-memory keystore for mainly for testing purposes.\n *\n * @see [https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store](https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store)\n * @example\n * ```js\n * import { connect, keyStores, utils } from 'near-api-js';\n *\n * const privateKey = '.......';\n * const keyPair = utils.KeyPair.fromString(privateKey);\n *\n * const keyStore = new keyStores.InMemoryKeyStore();\n * keyStore.setKey('testnet', 'example-account.testnet', keyPair);\n *\n * const config = {\n *   keyStore, // instance of InMemoryKeyStore\n *   networkId: 'testnet',\n *   nodeUrl: 'https://rpc.testnet.near.org',\n *   walletUrl: 'https://wallet.testnet.near.org',\n *   helperUrl: 'https://helper.testnet.near.org',\n *   explorerUrl: 'https://explorer.testnet.near.org'\n * };\n *\n * // inside an async function\n * const near = await connect(config)\n * ```\n */\nclass InMemoryKeyStore extends keystore_1.KeyStore {\n    constructor() {\n        super();\n        this.keys = {};\n    }\n    /**\n     * Stores a {@link utils/key_pair!KeyPair} in in-memory storage item\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     * @param keyPair The key pair to store in local storage\n     */\n    setKey(networkId, accountId, keyPair) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.keys[`${accountId}:${networkId}`] = keyPair.toString();\n        });\n    }\n    /**\n     * Gets a {@link utils/key_pair!KeyPair} from in-memory storage\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     * @returns {Promise<KeyPair>}\n     */\n    getKey(networkId, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const value = this.keys[`${accountId}:${networkId}`];\n            if (!value) {\n                return null;\n            }\n            return key_pair_1.KeyPair.fromString(value);\n        });\n    }\n    /**\n     * Removes a {@link utils/key_pair!KeyPair} from in-memory storage\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     */\n    removeKey(networkId, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            delete this.keys[`${accountId}:${networkId}`];\n        });\n    }\n    /**\n     * Removes all {@link utils/key_pair!KeyPair} from in-memory storage\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.keys = {};\n        });\n    }\n    /**\n     * Get the network(s) from in-memory storage\n     * @returns {Promise<string[]>}\n     */\n    getNetworks() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = new Set();\n            Object.keys(this.keys).forEach((key) => {\n                const parts = key.split(':');\n                result.add(parts[1]);\n            });\n            return Array.from(result.values());\n        });\n    }\n    /**\n     * Gets the account(s) from in-memory storage\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     */\n    getAccounts(networkId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = new Array();\n            Object.keys(this.keys).forEach((key) => {\n                const parts = key.split(':');\n                if (parts[parts.length - 1] === networkId) {\n                    result.push(parts.slice(0, parts.length - 1).join(':'));\n                }\n            });\n            return result;\n        });\n    }\n    /** @hidden */\n    toString() {\n        return 'InMemoryKeyStore';\n    }\n}\nexports.InMemoryKeyStore = InMemoryKeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2tleV9zdG9yZXMvaW5fbWVtb3J5X2tleV9zdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVSxHQUFHLFVBQVU7QUFDaEQsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVLEdBQUcsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyxVQUFVO0FBQ3ZELFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIva2V5X3N0b3Jlcy9pbl9tZW1vcnlfa2V5X3N0b3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluTWVtb3J5S2V5U3RvcmUgPSB2b2lkIDA7XG5jb25zdCBrZXlzdG9yZV8xID0gcmVxdWlyZShcIi4va2V5c3RvcmVcIik7XG5jb25zdCBrZXlfcGFpcl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL2tleV9wYWlyXCIpO1xuLyoqXG4gKiBTaW1wbGUgaW4tbWVtb3J5IGtleXN0b3JlIGZvciBtYWlubHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvZGV2ZWxvcC9mcm9udC1lbmQvbmFqLXF1aWNrLXJlZmVyZW5jZSNrZXktc3RvcmVdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9kb2NzL2RldmVsb3AvZnJvbnQtZW5kL25hai1xdWljay1yZWZlcmVuY2Uja2V5LXN0b3JlKVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBjb25uZWN0LCBrZXlTdG9yZXMsIHV0aWxzIH0gZnJvbSAnbmVhci1hcGktanMnO1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSAnLi4uLi4uLic7XG4gKiBjb25zdCBrZXlQYWlyID0gdXRpbHMuS2V5UGFpci5mcm9tU3RyaW5nKHByaXZhdGVLZXkpO1xuICpcbiAqIGNvbnN0IGtleVN0b3JlID0gbmV3IGtleVN0b3Jlcy5Jbk1lbW9yeUtleVN0b3JlKCk7XG4gKiBrZXlTdG9yZS5zZXRLZXkoJ3Rlc3RuZXQnLCAnZXhhbXBsZS1hY2NvdW50LnRlc3RuZXQnLCBrZXlQYWlyKTtcbiAqXG4gKiBjb25zdCBjb25maWcgPSB7XG4gKiAgIGtleVN0b3JlLCAvLyBpbnN0YW5jZSBvZiBJbk1lbW9yeUtleVN0b3JlXG4gKiAgIG5ldHdvcmtJZDogJ3Rlc3RuZXQnLFxuICogICBub2RlVXJsOiAnaHR0cHM6Ly9ycGMudGVzdG5ldC5uZWFyLm9yZycsXG4gKiAgIHdhbGxldFVybDogJ2h0dHBzOi8vd2FsbGV0LnRlc3RuZXQubmVhci5vcmcnLFxuICogICBoZWxwZXJVcmw6ICdodHRwczovL2hlbHBlci50ZXN0bmV0Lm5lYXIub3JnJyxcbiAqICAgZXhwbG9yZXJVcmw6ICdodHRwczovL2V4cGxvcmVyLnRlc3RuZXQubmVhci5vcmcnXG4gKiB9O1xuICpcbiAqIC8vIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblxuICogY29uc3QgbmVhciA9IGF3YWl0IGNvbm5lY3QoY29uZmlnKVxuICogYGBgXG4gKi9cbmNsYXNzIEluTWVtb3J5S2V5U3RvcmUgZXh0ZW5kcyBrZXlzdG9yZV8xLktleVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5rZXlzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlcyBhIHtAbGluayB1dGlscy9rZXlfcGFpciFLZXlQYWlyfSBpbiBpbi1tZW1vcnkgc3RvcmFnZSBpdGVtXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCBUaGUgdGFyZ2V0ZWQgbmV0d29yay4gKGV4LiBkZWZhdWx0LCBiZXRhbmV0LCBldGPigKYpXG4gICAgICogQHBhcmFtIGFjY291bnRJZCBUaGUgTkVBUiBhY2NvdW50IHRpZWQgdG8gdGhlIGtleSBwYWlyXG4gICAgICogQHBhcmFtIGtleVBhaXIgVGhlIGtleSBwYWlyIHRvIHN0b3JlIGluIGxvY2FsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBzZXRLZXkobmV0d29ya0lkLCBhY2NvdW50SWQsIGtleVBhaXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMua2V5c1tgJHthY2NvdW50SWR9OiR7bmV0d29ya0lkfWBdID0ga2V5UGFpci50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHtAbGluayB1dGlscy9rZXlfcGFpciFLZXlQYWlyfSBmcm9tIGluLW1lbW9yeSBzdG9yYWdlXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCBUaGUgdGFyZ2V0ZWQgbmV0d29yay4gKGV4LiBkZWZhdWx0LCBiZXRhbmV0LCBldGPigKYpXG4gICAgICogQHBhcmFtIGFjY291bnRJZCBUaGUgTkVBUiBhY2NvdW50IHRpZWQgdG8gdGhlIGtleSBwYWlyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8S2V5UGFpcj59XG4gICAgICovXG4gICAgZ2V0S2V5KG5ldHdvcmtJZCwgYWNjb3VudElkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMua2V5c1tgJHthY2NvdW50SWR9OiR7bmV0d29ya0lkfWBdO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleV9wYWlyXzEuS2V5UGFpci5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB7QGxpbmsgdXRpbHMva2V5X3BhaXIhS2V5UGFpcn0gZnJvbSBpbi1tZW1vcnkgc3RvcmFnZVxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0aWVkIHRvIHRoZSBrZXkgcGFpclxuICAgICAqL1xuICAgIHJlbW92ZUtleShuZXR3b3JrSWQsIGFjY291bnRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMua2V5c1tgJHthY2NvdW50SWR9OiR7bmV0d29ya0lkfWBdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwge0BsaW5rIHV0aWxzL2tleV9wYWlyIUtleVBhaXJ9IGZyb20gaW4tbWVtb3J5IHN0b3JhZ2VcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IHt9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXR3b3JrKHMpIGZyb20gaW4tbWVtb3J5IHN0b3JhZ2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59XG4gICAgICovXG4gICAgZ2V0TmV0d29ya3MoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmtleXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZChwYXJ0c1sxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJlc3VsdC52YWx1ZXMoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhY2NvdW50KHMpIGZyb20gaW4tbWVtb3J5IHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIFRoZSB0YXJnZXRlZCBuZXR3b3JrLiAoZXguIGRlZmF1bHQsIGJldGFuZXQsIGV0Y+KApilcbiAgICAgKi9cbiAgICBnZXRBY2NvdW50cyhuZXR3b3JrSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5rZXlzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PT0gbmV0d29ya0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnRzLnNsaWNlKDAsIHBhcnRzLmxlbmd0aCAtIDEpLmpvaW4oJzonKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdJbk1lbW9yeUtleVN0b3JlJztcbiAgICB9XG59XG5leHBvcnRzLkluTWVtb3J5S2V5U3RvcmUgPSBJbk1lbW9yeUtleVN0b3JlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/key_stores/in_memory_key_store.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/key_stores/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/near-api-js/lib/key_stores/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MergeKeyStore = exports.UnencryptedFileSystemKeyStore = exports.BrowserLocalStorageKeyStore = exports.InMemoryKeyStore = exports.KeyStore = void 0;\n/** @ignore @module */\nconst keystore_1 = __webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/keystore.js\");\nObject.defineProperty(exports, \"KeyStore\", ({ enumerable: true, get: function () { return keystore_1.KeyStore; } }));\nconst in_memory_key_store_1 = __webpack_require__(/*! ./in_memory_key_store */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/in_memory_key_store.js\");\nObject.defineProperty(exports, \"InMemoryKeyStore\", ({ enumerable: true, get: function () { return in_memory_key_store_1.InMemoryKeyStore; } }));\nconst browser_local_storage_key_store_1 = __webpack_require__(/*! ./browser_local_storage_key_store */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js\");\nObject.defineProperty(exports, \"BrowserLocalStorageKeyStore\", ({ enumerable: true, get: function () { return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore; } }));\nconst unencrypted_file_system_keystore_1 = __webpack_require__(/*! ./unencrypted_file_system_keystore */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/unencrypted_file_system_keystore.js\");\nObject.defineProperty(exports, \"UnencryptedFileSystemKeyStore\", ({ enumerable: true, get: function () { return unencrypted_file_system_keystore_1.UnencryptedFileSystemKeyStore; } }));\nconst merge_key_store_1 = __webpack_require__(/*! ./merge_key_store */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/merge_key_store.js\");\nObject.defineProperty(exports, \"MergeKeyStore\", ({ enumerable: true, get: function () { return merge_key_store_1.MergeKeyStore; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2tleV9zdG9yZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUNBQXFDLEdBQUcsbUNBQW1DLEdBQUcsd0JBQXdCLEdBQUcsZ0JBQWdCO0FBQ2pKO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsK0VBQVk7QUFDdkMsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILDhCQUE4QixtQkFBTyxDQUFDLHFHQUF1QjtBQUM3RCxvREFBbUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDN0ksMENBQTBDLG1CQUFPLENBQUMsNkhBQW1DO0FBQ3JGLCtEQUE4RCxFQUFFLHFDQUFxQyx5RUFBeUUsRUFBQztBQUMvSywyQ0FBMkMsbUJBQU8sQ0FBQywrSEFBb0M7QUFDdkYsaUVBQWdFLEVBQUUscUNBQXFDLDRFQUE0RSxFQUFDO0FBQ3BMLDBCQUEwQixtQkFBTyxDQUFDLDZGQUFtQjtBQUNyRCxpREFBZ0QsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi9rZXlfc3RvcmVzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXJnZUtleVN0b3JlID0gZXhwb3J0cy5VbmVuY3J5cHRlZEZpbGVTeXN0ZW1LZXlTdG9yZSA9IGV4cG9ydHMuQnJvd3NlckxvY2FsU3RvcmFnZUtleVN0b3JlID0gZXhwb3J0cy5Jbk1lbW9yeUtleVN0b3JlID0gZXhwb3J0cy5LZXlTdG9yZSA9IHZvaWQgMDtcbi8qKiBAaWdub3JlIEBtb2R1bGUgKi9cbmNvbnN0IGtleXN0b3JlXzEgPSByZXF1aXJlKFwiLi9rZXlzdG9yZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleVN0b3JlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlzdG9yZV8xLktleVN0b3JlOyB9IH0pO1xuY29uc3QgaW5fbWVtb3J5X2tleV9zdG9yZV8xID0gcmVxdWlyZShcIi4vaW5fbWVtb3J5X2tleV9zdG9yZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluTWVtb3J5S2V5U3RvcmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluX21lbW9yeV9rZXlfc3RvcmVfMS5Jbk1lbW9yeUtleVN0b3JlOyB9IH0pO1xuY29uc3QgYnJvd3Nlcl9sb2NhbF9zdG9yYWdlX2tleV9zdG9yZV8xID0gcmVxdWlyZShcIi4vYnJvd3Nlcl9sb2NhbF9zdG9yYWdlX2tleV9zdG9yZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnJvd3Nlcl9sb2NhbF9zdG9yYWdlX2tleV9zdG9yZV8xLkJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZTsgfSB9KTtcbmNvbnN0IHVuZW5jcnlwdGVkX2ZpbGVfc3lzdGVtX2tleXN0b3JlXzEgPSByZXF1aXJlKFwiLi91bmVuY3J5cHRlZF9maWxlX3N5c3RlbV9rZXlzdG9yZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZW5jcnlwdGVkRmlsZVN5c3RlbUtleVN0b3JlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmVuY3J5cHRlZF9maWxlX3N5c3RlbV9rZXlzdG9yZV8xLlVuZW5jcnlwdGVkRmlsZVN5c3RlbUtleVN0b3JlOyB9IH0pO1xuY29uc3QgbWVyZ2Vfa2V5X3N0b3JlXzEgPSByZXF1aXJlKFwiLi9tZXJnZV9rZXlfc3RvcmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXJnZUtleVN0b3JlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXJnZV9rZXlfc3RvcmVfMS5NZXJnZUtleVN0b3JlOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/key_stores/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/key_stores/keystore.js":
/*!*************************************************************!*\
  !*** ./node_modules/near-api-js/lib/key_stores/keystore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyStore = void 0;\n/**\n * KeyStores are passed to {@link near!Near} via {@link near!NearConfig}\n * and are used by the {@link signer!InMemorySigner} to sign transactions.\n *\n * @see {@link connect}\n */\nclass KeyStore {\n}\nexports.KeyStore = KeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2tleV9zdG9yZXMva2V5c3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCO0FBQ0EsNEJBQTRCLGlCQUFpQixLQUFLO0FBQ2xELHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIva2V5X3N0b3Jlcy9rZXlzdG9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2V5U3RvcmUgPSB2b2lkIDA7XG4vKipcbiAqIEtleVN0b3JlcyBhcmUgcGFzc2VkIHRvIHtAbGluayBuZWFyIU5lYXJ9IHZpYSB7QGxpbmsgbmVhciFOZWFyQ29uZmlnfVxuICogYW5kIGFyZSB1c2VkIGJ5IHRoZSB7QGxpbmsgc2lnbmVyIUluTWVtb3J5U2lnbmVyfSB0byBzaWduIHRyYW5zYWN0aW9ucy5cbiAqXG4gKiBAc2VlIHtAbGluayBjb25uZWN0fVxuICovXG5jbGFzcyBLZXlTdG9yZSB7XG59XG5leHBvcnRzLktleVN0b3JlID0gS2V5U3RvcmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/key_stores/keystore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/key_stores/merge_key_store.js":
/*!********************************************************************!*\
  !*** ./node_modules/near-api-js/lib/key_stores/merge_key_store.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MergeKeyStore = void 0;\nconst keystore_1 = __webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/keystore.js\");\nclass MergeKeyStore extends keystore_1.KeyStore {\n    /**\n     * @param keyStores read calls are attempted from start to end of array\n     * @param options.writeKeyStoreIndex the keystore index that will receive all write calls\n     */\n    constructor(keyStores, options = { writeKeyStoreIndex: 0 }) {\n        super();\n        this.options = options;\n        this.keyStores = keyStores;\n    }\n    /**\n     * Store a {@link utils/key_pair!KeyPair} to the first index of a key store array\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     * @param keyPair The key pair to store in local storage\n     */\n    setKey(networkId, accountId, keyPair) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.keyStores[this.options.writeKeyStoreIndex].setKey(networkId, accountId, keyPair);\n        });\n    }\n    /**\n     * Gets a {@link utils/key_pair!KeyPair} from the array of key stores\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     * @returns {Promise<KeyPair>}\n     */\n    getKey(networkId, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const keyStore of this.keyStores) {\n                const keyPair = yield keyStore.getKey(networkId, accountId);\n                if (keyPair) {\n                    return keyPair;\n                }\n            }\n            return null;\n        });\n    }\n    /**\n     * Removes a {@link utils/key_pair!KeyPair} from the array of key stores\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     */\n    removeKey(networkId, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const keyStore of this.keyStores) {\n                yield keyStore.removeKey(networkId, accountId);\n            }\n        });\n    }\n    /**\n     * Removes all items from each key store\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const keyStore of this.keyStores) {\n                yield keyStore.clear();\n            }\n        });\n    }\n    /**\n     * Get the network(s) from the array of key stores\n     * @returns {Promise<string[]>}\n     */\n    getNetworks() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = new Set();\n            for (const keyStore of this.keyStores) {\n                for (const network of yield keyStore.getNetworks()) {\n                    result.add(network);\n                }\n            }\n            return Array.from(result);\n        });\n    }\n    /**\n     * Gets the account(s) from the array of key stores\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     */\n    getAccounts(networkId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = new Set();\n            for (const keyStore of this.keyStores) {\n                for (const account of yield keyStore.getAccounts(networkId)) {\n                    result.add(account);\n                }\n            }\n            return Array.from(result);\n        });\n    }\n    /** @hidden */\n    toString() {\n        return `MergeKeyStore(${this.keyStores.join(', ')})`;\n    }\n}\nexports.MergeKeyStore = MergeKeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2tleV9zdG9yZXMvbWVyZ2Vfa2V5X3N0b3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsbUJBQW1CLG1CQUFPLENBQUMsK0VBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIva2V5X3N0b3Jlcy9tZXJnZV9rZXlfc3RvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVyZ2VLZXlTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IGtleXN0b3JlXzEgPSByZXF1aXJlKFwiLi9rZXlzdG9yZVwiKTtcbmNsYXNzIE1lcmdlS2V5U3RvcmUgZXh0ZW5kcyBrZXlzdG9yZV8xLktleVN0b3JlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ga2V5U3RvcmVzIHJlYWQgY2FsbHMgYXJlIGF0dGVtcHRlZCBmcm9tIHN0YXJ0IHRvIGVuZCBvZiBhcnJheVxuICAgICAqIEBwYXJhbSBvcHRpb25zLndyaXRlS2V5U3RvcmVJbmRleCB0aGUga2V5c3RvcmUgaW5kZXggdGhhdCB3aWxsIHJlY2VpdmUgYWxsIHdyaXRlIGNhbGxzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5U3RvcmVzLCBvcHRpb25zID0geyB3cml0ZUtleVN0b3JlSW5kZXg6IDAgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmtleVN0b3JlcyA9IGtleVN0b3JlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmUgYSB7QGxpbmsgdXRpbHMva2V5X3BhaXIhS2V5UGFpcn0gdG8gdGhlIGZpcnN0IGluZGV4IG9mIGEga2V5IHN0b3JlIGFycmF5XG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCBUaGUgdGFyZ2V0ZWQgbmV0d29yay4gKGV4LiBkZWZhdWx0LCBiZXRhbmV0LCBldGPigKYpXG4gICAgICogQHBhcmFtIGFjY291bnRJZCBUaGUgTkVBUiBhY2NvdW50IHRpZWQgdG8gdGhlIGtleSBwYWlyXG4gICAgICogQHBhcmFtIGtleVBhaXIgVGhlIGtleSBwYWlyIHRvIHN0b3JlIGluIGxvY2FsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBzZXRLZXkobmV0d29ya0lkLCBhY2NvdW50SWQsIGtleVBhaXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMua2V5U3RvcmVzW3RoaXMub3B0aW9ucy53cml0ZUtleVN0b3JlSW5kZXhdLnNldEtleShuZXR3b3JrSWQsIGFjY291bnRJZCwga2V5UGFpcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEge0BsaW5rIHV0aWxzL2tleV9wYWlyIUtleVBhaXJ9IGZyb20gdGhlIGFycmF5IG9mIGtleSBzdG9yZXNcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIFRoZSB0YXJnZXRlZCBuZXR3b3JrLiAoZXguIGRlZmF1bHQsIGJldGFuZXQsIGV0Y+KApilcbiAgICAgKiBAcGFyYW0gYWNjb3VudElkIFRoZSBORUFSIGFjY291bnQgdGllZCB0byB0aGUga2V5IHBhaXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXlQYWlyPn1cbiAgICAgKi9cbiAgICBnZXRLZXkobmV0d29ya0lkLCBhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5U3RvcmUgb2YgdGhpcy5rZXlTdG9yZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlQYWlyID0geWllbGQga2V5U3RvcmUuZ2V0S2V5KG5ldHdvcmtJZCwgYWNjb3VudElkKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5UGFpcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5UGFpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB7QGxpbmsgdXRpbHMva2V5X3BhaXIhS2V5UGFpcn0gZnJvbSB0aGUgYXJyYXkgb2Yga2V5IHN0b3Jlc1xuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0aWVkIHRvIHRoZSBrZXkgcGFpclxuICAgICAqL1xuICAgIHJlbW92ZUtleShuZXR3b3JrSWQsIGFjY291bnRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXlTdG9yZSBvZiB0aGlzLmtleVN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHlpZWxkIGtleVN0b3JlLnJlbW92ZUtleShuZXR3b3JrSWQsIGFjY291bnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBpdGVtcyBmcm9tIGVhY2gga2V5IHN0b3JlXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleVN0b3JlIG9mIHRoaXMua2V5U3RvcmVzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQga2V5U3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV0d29yayhzKSBmcm9tIHRoZSBhcnJheSBvZiBrZXkgc3RvcmVzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fVxuICAgICAqL1xuICAgIGdldE5ldHdvcmtzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXlTdG9yZSBvZiB0aGlzLmtleVN0b3Jlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmV0d29yayBvZiB5aWVsZCBrZXlTdG9yZS5nZXROZXR3b3JrcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQobmV0d29yayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjY291bnQocykgZnJvbSB0aGUgYXJyYXkgb2Yga2V5IHN0b3Jlc1xuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqL1xuICAgIGdldEFjY291bnRzKG5ldHdvcmtJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXlTdG9yZSBvZiB0aGlzLmtleVN0b3Jlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiB5aWVsZCBrZXlTdG9yZS5nZXRBY2NvdW50cyhuZXR3b3JrSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgTWVyZ2VLZXlTdG9yZSgke3RoaXMua2V5U3RvcmVzLmpvaW4oJywgJyl9KWA7XG4gICAgfVxufVxuZXhwb3J0cy5NZXJnZUtleVN0b3JlID0gTWVyZ2VLZXlTdG9yZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/key_stores/merge_key_store.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/key_stores/unencrypted_file_system_keystore.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/near-api-js/lib/key_stores/unencrypted_file_system_keystore.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnencryptedFileSystemKeyStore = exports.readKeyFile = exports.loadJsonFile = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst key_pair_1 = __webpack_require__(/*! ../utils/key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\nconst keystore_1 = __webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/keystore.js\");\nconst promisify = (fn) => {\n    if (!fn) {\n        return () => {\n            throw new Error('Trying to use unimplemented function. `fs` module not available in web build?');\n        };\n    }\n    return (0, util_1.promisify)(fn);\n};\nconst exists = promisify(fs_1.default.exists);\nconst readFile = promisify(fs_1.default.readFile);\nconst writeFile = promisify(fs_1.default.writeFile);\nconst unlink = promisify(fs_1.default.unlink);\nconst readdir = promisify(fs_1.default.readdir);\nconst mkdir = promisify(fs_1.default.mkdir);\n/** @hidden */\nfunction loadJsonFile(filename) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const content = yield readFile(filename);\n        return JSON.parse(content.toString());\n    });\n}\nexports.loadJsonFile = loadJsonFile;\nfunction ensureDir(dir) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield mkdir(dir, { recursive: true });\n        }\n        catch (err) {\n            if (err.code !== 'EEXIST') {\n                throw err;\n            }\n        }\n    });\n}\n/** @hidden */\nfunction readKeyFile(filename) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const accountInfo = yield loadJsonFile(filename);\n        // The private key might be in private_key or secret_key field.\n        let privateKey = accountInfo.private_key;\n        if (!privateKey && accountInfo.secret_key) {\n            privateKey = accountInfo.secret_key;\n        }\n        return [accountInfo.account_id, key_pair_1.KeyPair.fromString(privateKey)];\n    });\n}\nexports.readKeyFile = readKeyFile;\n/**\n * This class is used to store keys on the file system.\n *\n * @see [https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store](https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store)\n * @example\n * ```js\n * const { homedir } = require('os');\n * const { connect, keyStores } = require('near-api-js');\n *\n * const keyStore = new keyStores.UnencryptedFileSystemKeyStore(`${homedir()}/.near-credentials`);\n * const config = {\n *   keyStore, // instance of UnencryptedFileSystemKeyStore\n *   networkId: 'testnet',\n *   nodeUrl: 'https://rpc.testnet.near.org',\n *   walletUrl: 'https://wallet.testnet.near.org',\n *   helperUrl: 'https://helper.testnet.near.org',\n *   explorerUrl: 'https://explorer.testnet.near.org'\n * };\n *\n * // inside an async function\n * const near = await connect(config)\n * ```\n */\nclass UnencryptedFileSystemKeyStore extends keystore_1.KeyStore {\n    /**\n     * @param keyDir base directory for key storage. Keys will be stored in `keyDir/networkId/accountId.json`\n     */\n    constructor(keyDir) {\n        super();\n        this.keyDir = path_1.default.resolve(keyDir);\n    }\n    /**\n     * Store a {@link utils/key_pair!KeyPair} in an unencrypted file\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     * @param keyPair The key pair to store in local storage\n     */\n    setKey(networkId, accountId, keyPair) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield ensureDir(`${this.keyDir}/${networkId}`);\n            const content = { account_id: accountId, public_key: keyPair.getPublicKey().toString(), private_key: keyPair.toString() };\n            yield writeFile(this.getKeyFilePath(networkId, accountId), JSON.stringify(content), { mode: 0o600 });\n        });\n    }\n    /**\n     * Gets a {@link utils/key_pair!KeyPair} from an unencrypted file\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     * @returns {Promise<KeyPair>}\n     */\n    getKey(networkId, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Find key / account id.\n            if (!(yield exists(this.getKeyFilePath(networkId, accountId)))) {\n                return null;\n            }\n            const accountKeyPair = yield readKeyFile(this.getKeyFilePath(networkId, accountId));\n            return accountKeyPair[1];\n        });\n    }\n    /**\n     * Deletes an unencrypted file holding a {@link utils/key_pair!KeyPair}\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account tied to the key pair\n     */\n    removeKey(networkId, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (yield exists(this.getKeyFilePath(networkId, accountId))) {\n                yield unlink(this.getKeyFilePath(networkId, accountId));\n            }\n        });\n    }\n    /**\n     * Deletes all unencrypted files from the `keyDir` path.\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const network of yield this.getNetworks()) {\n                for (const account of yield this.getAccounts(network)) {\n                    yield this.removeKey(network, account);\n                }\n            }\n        });\n    }\n    /** @hidden */\n    getKeyFilePath(networkId, accountId) {\n        return `${this.keyDir}/${networkId}/${accountId}.json`;\n    }\n    /**\n     * Get the network(s) from files in `keyDir`\n     * @returns {Promise<string[]>}\n     */\n    getNetworks() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const files = yield readdir(this.keyDir);\n            const result = new Array();\n            files.forEach((item) => {\n                result.push(item);\n            });\n            return result;\n        });\n    }\n    /**\n     * Gets the account(s) files in `keyDir/networkId`\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     */\n    getAccounts(networkId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(yield exists(`${this.keyDir}/${networkId}`))) {\n                return [];\n            }\n            const files = yield readdir(`${this.keyDir}/${networkId}`);\n            return files\n                .filter(file => file.endsWith('.json'))\n                .map(file => file.replace(/.json$/, ''));\n        });\n    }\n    /** @hidden */\n    toString() {\n        return `UnencryptedFileSystemKeyStore(${this.keyDir})`;\n    }\n}\nexports.UnencryptedFileSystemKeyStore = UnencryptedFileSystemKeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2tleV9zdG9yZXMvdW5lbmNyeXB0ZWRfZmlsZV9zeXN0ZW1fa2V5c3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CO0FBQ2xGLDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekMsK0JBQStCLG1CQUFPLENBQUMsa0JBQU07QUFDN0MsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFtQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQywrRUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLHFCQUFxQjtBQUNoQztBQUNBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxHQUFHLFVBQVU7QUFDeEQsOEJBQThCO0FBQzlCLGtHQUFrRyxhQUFhO0FBQy9HLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVksR0FBRyxVQUFVLEdBQUcsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWSxHQUFHLFVBQVU7QUFDM0Q7QUFDQTtBQUNBLDJDQUEyQyxZQUFZLEdBQUcsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL2tleV9zdG9yZXMvdW5lbmNyeXB0ZWRfZmlsZV9zeXN0ZW1fa2V5c3RvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5lbmNyeXB0ZWRGaWxlU3lzdGVtS2V5U3RvcmUgPSBleHBvcnRzLnJlYWRLZXlGaWxlID0gZXhwb3J0cy5sb2FkSnNvbkZpbGUgPSB2b2lkIDA7XG5jb25zdCBmc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBwYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBhdGhcIikpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBrZXlfcGFpcl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL2tleV9wYWlyXCIpO1xuY29uc3Qga2V5c3RvcmVfMSA9IHJlcXVpcmUoXCIuL2tleXN0b3JlXCIpO1xuY29uc3QgcHJvbWlzaWZ5ID0gKGZuKSA9PiB7XG4gICAgaWYgKCFmbikge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gdXNlIHVuaW1wbGVtZW50ZWQgZnVuY3Rpb24uIGBmc2AgbW9kdWxlIG5vdCBhdmFpbGFibGUgaW4gd2ViIGJ1aWxkPycpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHV0aWxfMS5wcm9taXNpZnkpKGZuKTtcbn07XG5jb25zdCBleGlzdHMgPSBwcm9taXNpZnkoZnNfMS5kZWZhdWx0LmV4aXN0cyk7XG5jb25zdCByZWFkRmlsZSA9IHByb21pc2lmeShmc18xLmRlZmF1bHQucmVhZEZpbGUpO1xuY29uc3Qgd3JpdGVGaWxlID0gcHJvbWlzaWZ5KGZzXzEuZGVmYXVsdC53cml0ZUZpbGUpO1xuY29uc3QgdW5saW5rID0gcHJvbWlzaWZ5KGZzXzEuZGVmYXVsdC51bmxpbmspO1xuY29uc3QgcmVhZGRpciA9IHByb21pc2lmeShmc18xLmRlZmF1bHQucmVhZGRpcik7XG5jb25zdCBta2RpciA9IHByb21pc2lmeShmc18xLmRlZmF1bHQubWtkaXIpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGxvYWRKc29uRmlsZShmaWxlbmFtZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB5aWVsZCByZWFkRmlsZShmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQudG9TdHJpbmcoKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRKc29uRmlsZSA9IGxvYWRKc29uRmlsZTtcbmZ1bmN0aW9uIGVuc3VyZURpcihkaXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgeWllbGQgbWtkaXIoZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFRVhJU1QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gcmVhZEtleUZpbGUoZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBhY2NvdW50SW5mbyA9IHlpZWxkIGxvYWRKc29uRmlsZShmaWxlbmFtZSk7XG4gICAgICAgIC8vIFRoZSBwcml2YXRlIGtleSBtaWdodCBiZSBpbiBwcml2YXRlX2tleSBvciBzZWNyZXRfa2V5IGZpZWxkLlxuICAgICAgICBsZXQgcHJpdmF0ZUtleSA9IGFjY291bnRJbmZvLnByaXZhdGVfa2V5O1xuICAgICAgICBpZiAoIXByaXZhdGVLZXkgJiYgYWNjb3VudEluZm8uc2VjcmV0X2tleSkge1xuICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGFjY291bnRJbmZvLnNlY3JldF9rZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthY2NvdW50SW5mby5hY2NvdW50X2lkLCBrZXlfcGFpcl8xLktleVBhaXIuZnJvbVN0cmluZyhwcml2YXRlS2V5KV07XG4gICAgfSk7XG59XG5leHBvcnRzLnJlYWRLZXlGaWxlID0gcmVhZEtleUZpbGU7XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBzdG9yZSBrZXlzIG9uIHRoZSBmaWxlIHN5c3RlbS5cbiAqXG4gKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9kZXZlbG9wL2Zyb250LWVuZC9uYWotcXVpY2stcmVmZXJlbmNlI2tleS1zdG9yZV0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvZGV2ZWxvcC9mcm9udC1lbmQvbmFqLXF1aWNrLXJlZmVyZW5jZSNrZXktc3RvcmUpXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IHsgaG9tZWRpciB9ID0gcmVxdWlyZSgnb3MnKTtcbiAqIGNvbnN0IHsgY29ubmVjdCwga2V5U3RvcmVzIH0gPSByZXF1aXJlKCduZWFyLWFwaS1qcycpO1xuICpcbiAqIGNvbnN0IGtleVN0b3JlID0gbmV3IGtleVN0b3Jlcy5VbmVuY3J5cHRlZEZpbGVTeXN0ZW1LZXlTdG9yZShgJHtob21lZGlyKCl9Ly5uZWFyLWNyZWRlbnRpYWxzYCk7XG4gKiBjb25zdCBjb25maWcgPSB7XG4gKiAgIGtleVN0b3JlLCAvLyBpbnN0YW5jZSBvZiBVbmVuY3J5cHRlZEZpbGVTeXN0ZW1LZXlTdG9yZVxuICogICBuZXR3b3JrSWQ6ICd0ZXN0bmV0JyxcbiAqICAgbm9kZVVybDogJ2h0dHBzOi8vcnBjLnRlc3RuZXQubmVhci5vcmcnLFxuICogICB3YWxsZXRVcmw6ICdodHRwczovL3dhbGxldC50ZXN0bmV0Lm5lYXIub3JnJyxcbiAqICAgaGVscGVyVXJsOiAnaHR0cHM6Ly9oZWxwZXIudGVzdG5ldC5uZWFyLm9yZycsXG4gKiAgIGV4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci50ZXN0bmV0Lm5lYXIub3JnJ1xuICogfTtcbiAqXG4gKiAvLyBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cbiAqIGNvbnN0IG5lYXIgPSBhd2FpdCBjb25uZWN0KGNvbmZpZylcbiAqIGBgYFxuICovXG5jbGFzcyBVbmVuY3J5cHRlZEZpbGVTeXN0ZW1LZXlTdG9yZSBleHRlbmRzIGtleXN0b3JlXzEuS2V5U3RvcmUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBrZXlEaXIgYmFzZSBkaXJlY3RvcnkgZm9yIGtleSBzdG9yYWdlLiBLZXlzIHdpbGwgYmUgc3RvcmVkIGluIGBrZXlEaXIvbmV0d29ya0lkL2FjY291bnRJZC5qc29uYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGtleURpcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleURpciA9IHBhdGhfMS5kZWZhdWx0LnJlc29sdmUoa2V5RGlyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmUgYSB7QGxpbmsgdXRpbHMva2V5X3BhaXIhS2V5UGFpcn0gaW4gYW4gdW5lbmNyeXB0ZWQgZmlsZVxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0aWVkIHRvIHRoZSBrZXkgcGFpclxuICAgICAqIEBwYXJhbSBrZXlQYWlyIFRoZSBrZXkgcGFpciB0byBzdG9yZSBpbiBsb2NhbCBzdG9yYWdlXG4gICAgICovXG4gICAgc2V0S2V5KG5ldHdvcmtJZCwgYWNjb3VudElkLCBrZXlQYWlyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCBlbnN1cmVEaXIoYCR7dGhpcy5rZXlEaXJ9LyR7bmV0d29ya0lkfWApO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHsgYWNjb3VudF9pZDogYWNjb3VudElkLCBwdWJsaWNfa2V5OiBrZXlQYWlyLmdldFB1YmxpY0tleSgpLnRvU3RyaW5nKCksIHByaXZhdGVfa2V5OiBrZXlQYWlyLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgIHlpZWxkIHdyaXRlRmlsZSh0aGlzLmdldEtleUZpbGVQYXRoKG5ldHdvcmtJZCwgYWNjb3VudElkKSwgSlNPTi5zdHJpbmdpZnkoY29udGVudCksIHsgbW9kZTogMG82MDAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEge0BsaW5rIHV0aWxzL2tleV9wYWlyIUtleVBhaXJ9IGZyb20gYW4gdW5lbmNyeXB0ZWQgZmlsZVxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0aWVkIHRvIHRoZSBrZXkgcGFpclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEtleVBhaXI+fVxuICAgICAqL1xuICAgIGdldEtleShuZXR3b3JrSWQsIGFjY291bnRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gRmluZCBrZXkgLyBhY2NvdW50IGlkLlxuICAgICAgICAgICAgaWYgKCEoeWllbGQgZXhpc3RzKHRoaXMuZ2V0S2V5RmlsZVBhdGgobmV0d29ya0lkLCBhY2NvdW50SWQpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRLZXlQYWlyID0geWllbGQgcmVhZEtleUZpbGUodGhpcy5nZXRLZXlGaWxlUGF0aChuZXR3b3JrSWQsIGFjY291bnRJZCkpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRLZXlQYWlyWzFdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbiB1bmVuY3J5cHRlZCBmaWxlIGhvbGRpbmcgYSB7QGxpbmsgdXRpbHMva2V5X3BhaXIhS2V5UGFpcn1cbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIFRoZSB0YXJnZXRlZCBuZXR3b3JrLiAoZXguIGRlZmF1bHQsIGJldGFuZXQsIGV0Y+KApilcbiAgICAgKiBAcGFyYW0gYWNjb3VudElkIFRoZSBORUFSIGFjY291bnQgdGllZCB0byB0aGUga2V5IHBhaXJcbiAgICAgKi9cbiAgICByZW1vdmVLZXkobmV0d29ya0lkLCBhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh5aWVsZCBleGlzdHModGhpcy5nZXRLZXlGaWxlUGF0aChuZXR3b3JrSWQsIGFjY291bnRJZCkpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdW5saW5rKHRoaXMuZ2V0S2V5RmlsZVBhdGgobmV0d29ya0lkLCBhY2NvdW50SWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYWxsIHVuZW5jcnlwdGVkIGZpbGVzIGZyb20gdGhlIGBrZXlEaXJgIHBhdGguXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgeWllbGQgdGhpcy5nZXROZXR3b3JrcygpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIHlpZWxkIHRoaXMuZ2V0QWNjb3VudHMobmV0d29yaykpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5yZW1vdmVLZXkobmV0d29yaywgYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBnZXRLZXlGaWxlUGF0aChuZXR3b3JrSWQsIGFjY291bnRJZCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5rZXlEaXJ9LyR7bmV0d29ya0lkfS8ke2FjY291bnRJZH0uanNvbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV0d29yayhzKSBmcm9tIGZpbGVzIGluIGBrZXlEaXJgXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fVxuICAgICAqL1xuICAgIGdldE5ldHdvcmtzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSB5aWVsZCByZWFkZGlyKHRoaXMua2V5RGlyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWNjb3VudChzKSBmaWxlcyBpbiBga2V5RGlyL25ldHdvcmtJZGBcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIFRoZSB0YXJnZXRlZCBuZXR3b3JrLiAoZXguIGRlZmF1bHQsIGJldGFuZXQsIGV0Y+KApilcbiAgICAgKi9cbiAgICBnZXRBY2NvdW50cyhuZXR3b3JrSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghKHlpZWxkIGV4aXN0cyhgJHt0aGlzLmtleURpcn0vJHtuZXR3b3JrSWR9YCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSB5aWVsZCByZWFkZGlyKGAke3RoaXMua2V5RGlyfS8ke25ldHdvcmtJZH1gKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsZSA9PiBmaWxlLmVuZHNXaXRoKCcuanNvbicpKVxuICAgICAgICAgICAgICAgIC5tYXAoZmlsZSA9PiBmaWxlLnJlcGxhY2UoLy5qc29uJC8sICcnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFVuZW5jcnlwdGVkRmlsZVN5c3RlbUtleVN0b3JlKCR7dGhpcy5rZXlEaXJ9KWA7XG4gICAgfVxufVxuZXhwb3J0cy5VbmVuY3J5cHRlZEZpbGVTeXN0ZW1LZXlTdG9yZSA9IFVuZW5jcnlwdGVkRmlsZVN5c3RlbUtleVN0b3JlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/key_stores/unencrypted_file_system_keystore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/near.js":
/*!**********************************************!*\
  !*** ./node_modules/near-api-js/lib/near.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Near = void 0;\n/**\n * This module contains the main class developers will use to interact with NEAR.\n * The {@link Near} class is used to interact with {@link account!Account | Accounts} through the {@link providers/json-rpc-provider!JsonRpcProvider}.\n * It is configured via the {@link NearConfig}.\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#account](https://docs.near.org/tools/near-api-js/quick-reference#account)\n *\n * @module near\n */\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/near-api-js/lib/account.js\");\nconst connection_1 = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/near-api-js/lib/connection.js\");\nconst account_creator_1 = __webpack_require__(/*! ./account_creator */ \"(ssr)/./node_modules/near-api-js/lib/account_creator.js\");\n/**\n * This is the main class developers should use to interact with NEAR.\n * @example\n * ```js\n * const near = new Near(config);\n * ```\n */\nclass Near {\n    constructor(config) {\n        this.config = config;\n        this.connection = connection_1.Connection.fromConfig({\n            networkId: config.networkId,\n            provider: { type: 'JsonRpcProvider', args: { url: config.nodeUrl, headers: config.headers } },\n            signer: config.signer || { type: 'InMemorySigner', keyStore: config.keyStore },\n            jsvmAccountId: config.jsvmAccountId || `jsvm.${config.networkId}`\n        });\n        if (config.masterAccount) {\n            // TODO: figure out better way of specifiying initial balance.\n            // Hardcoded number below must be enough to pay the gas cost to dev-deploy with near-shell for multiple times\n            const initialBalance = config.initialBalance ? new bn_js_1.default(config.initialBalance) : new bn_js_1.default('500000000000000000000000000');\n            this.accountCreator = new account_creator_1.LocalAccountCreator(new account_1.Account(this.connection, config.masterAccount), initialBalance);\n        }\n        else if (config.helperUrl) {\n            this.accountCreator = new account_creator_1.UrlAccountCreator(this.connection, config.helperUrl);\n        }\n        else {\n            this.accountCreator = null;\n        }\n    }\n    /**\n     * @param accountId near accountId used to interact with the network.\n     */\n    account(accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const account = new account_1.Account(this.connection, accountId);\n            return account;\n        });\n    }\n    /**\n     * Create an account using the {@link account_creator!AccountCreator}. Either:\n     * * using a masterAccount with {@link account_creator!LocalAccountCreator}\n     * * using the helperUrl with {@link account_creator!UrlAccountCreator}\n     * @see {@link NearConfig.masterAccount} and {@link NearConfig.helperUrl}\n     *\n     * @param accountId\n     * @param publicKey\n     */\n    createAccount(accountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.accountCreator) {\n                throw new Error('Must specify account creator, either via masterAccount or helperUrl configuration settings.');\n            }\n            yield this.accountCreator.createAccount(accountId, publicKey);\n            return new account_1.Account(this.connection, accountId);\n        });\n    }\n}\nexports.Near = Near;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL25lYXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaO0FBQ0E7QUFDQSxRQUFRLFlBQVksZ0NBQWdDLGtDQUFrQyxhQUFhLGtEQUFrRDtBQUNySiw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQyxtREFBTztBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBVztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyx3RUFBYztBQUMzQywwQkFBMEIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQyxnREFBZ0Q7QUFDekcsdUNBQXVDLG1EQUFtRDtBQUMxRiwyREFBMkQsaUJBQWlCO0FBQzVFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQ0FBb0MscUNBQXFDO0FBQ3pFLHFDQUFxQztBQUNyQyxtQ0FBbUM7QUFDbkMsYUFBYSxnQ0FBZ0MsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIvbmVhci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZWFyID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyB0aGUgbWFpbiBjbGFzcyBkZXZlbG9wZXJzIHdpbGwgdXNlIHRvIGludGVyYWN0IHdpdGggTkVBUi5cbiAqIFRoZSB7QGxpbmsgTmVhcn0gY2xhc3MgaXMgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHtAbGluayBhY2NvdW50IUFjY291bnQgfCBBY2NvdW50c30gdGhyb3VnaCB0aGUge0BsaW5rIHByb3ZpZGVycy9qc29uLXJwYy1wcm92aWRlciFKc29uUnBjUHJvdmlkZXJ9LlxuICogSXQgaXMgY29uZmlndXJlZCB2aWEgdGhlIHtAbGluayBOZWFyQ29uZmlnfS5cbiAqXG4gKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvdG9vbHMvbmVhci1hcGktanMvcXVpY2stcmVmZXJlbmNlI2FjY291bnRdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2UjYWNjb3VudClcbiAqXG4gKiBAbW9kdWxlIG5lYXJcbiAqL1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuY29uc3QgYWNjb3VudF8xID0gcmVxdWlyZShcIi4vYWNjb3VudFwiKTtcbmNvbnN0IGNvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb25cIik7XG5jb25zdCBhY2NvdW50X2NyZWF0b3JfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRfY3JlYXRvclwiKTtcbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBjbGFzcyBkZXZlbG9wZXJzIHNob3VsZCB1c2UgdG8gaW50ZXJhY3Qgd2l0aCBORUFSLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBuZWFyID0gbmV3IE5lYXIoY29uZmlnKTtcbiAqIGBgYFxuICovXG5jbGFzcyBOZWFyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uLmZyb21Db25maWcoe1xuICAgICAgICAgICAgbmV0d29ya0lkOiBjb25maWcubmV0d29ya0lkLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHsgdHlwZTogJ0pzb25ScGNQcm92aWRlcicsIGFyZ3M6IHsgdXJsOiBjb25maWcubm9kZVVybCwgaGVhZGVyczogY29uZmlnLmhlYWRlcnMgfSB9LFxuICAgICAgICAgICAgc2lnbmVyOiBjb25maWcuc2lnbmVyIHx8IHsgdHlwZTogJ0luTWVtb3J5U2lnbmVyJywga2V5U3RvcmU6IGNvbmZpZy5rZXlTdG9yZSB9LFxuICAgICAgICAgICAganN2bUFjY291bnRJZDogY29uZmlnLmpzdm1BY2NvdW50SWQgfHwgYGpzdm0uJHtjb25maWcubmV0d29ya0lkfWBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcubWFzdGVyQWNjb3VudCkge1xuICAgICAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBiZXR0ZXIgd2F5IG9mIHNwZWNpZml5aW5nIGluaXRpYWwgYmFsYW5jZS5cbiAgICAgICAgICAgIC8vIEhhcmRjb2RlZCBudW1iZXIgYmVsb3cgbXVzdCBiZSBlbm91Z2ggdG8gcGF5IHRoZSBnYXMgY29zdCB0byBkZXYtZGVwbG95IHdpdGggbmVhci1zaGVsbCBmb3IgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxCYWxhbmNlID0gY29uZmlnLmluaXRpYWxCYWxhbmNlID8gbmV3IGJuX2pzXzEuZGVmYXVsdChjb25maWcuaW5pdGlhbEJhbGFuY2UpIDogbmV3IGJuX2pzXzEuZGVmYXVsdCgnNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gICAgICAgICAgICB0aGlzLmFjY291bnRDcmVhdG9yID0gbmV3IGFjY291bnRfY3JlYXRvcl8xLkxvY2FsQWNjb3VudENyZWF0b3IobmV3IGFjY291bnRfMS5BY2NvdW50KHRoaXMuY29ubmVjdGlvbiwgY29uZmlnLm1hc3RlckFjY291bnQpLCBpbml0aWFsQmFsYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLmhlbHBlclVybCkge1xuICAgICAgICAgICAgdGhpcy5hY2NvdW50Q3JlYXRvciA9IG5ldyBhY2NvdW50X2NyZWF0b3JfMS5VcmxBY2NvdW50Q3JlYXRvcih0aGlzLmNvbm5lY3Rpb24sIGNvbmZpZy5oZWxwZXJVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY2NvdW50Q3JlYXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFjY291bnRJZCBuZWFyIGFjY291bnRJZCB1c2VkIHRvIGludGVyYWN0IHdpdGggdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgYWNjb3VudChhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBuZXcgYWNjb3VudF8xLkFjY291bnQodGhpcy5jb25uZWN0aW9uLCBhY2NvdW50SWQpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gYWNjb3VudCB1c2luZyB0aGUge0BsaW5rIGFjY291bnRfY3JlYXRvciFBY2NvdW50Q3JlYXRvcn0uIEVpdGhlcjpcbiAgICAgKiAqIHVzaW5nIGEgbWFzdGVyQWNjb3VudCB3aXRoIHtAbGluayBhY2NvdW50X2NyZWF0b3IhTG9jYWxBY2NvdW50Q3JlYXRvcn1cbiAgICAgKiAqIHVzaW5nIHRoZSBoZWxwZXJVcmwgd2l0aCB7QGxpbmsgYWNjb3VudF9jcmVhdG9yIVVybEFjY291bnRDcmVhdG9yfVxuICAgICAqIEBzZWUge0BsaW5rIE5lYXJDb25maWcubWFzdGVyQWNjb3VudH0gYW5kIHtAbGluayBOZWFyQ29uZmlnLmhlbHBlclVybH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2NvdW50SWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5XG4gICAgICovXG4gICAgY3JlYXRlQWNjb3VudChhY2NvdW50SWQsIHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjY291bnRDcmVhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgYWNjb3VudCBjcmVhdG9yLCBlaXRoZXIgdmlhIG1hc3RlckFjY291bnQgb3IgaGVscGVyVXJsIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmFjY291bnRDcmVhdG9yLmNyZWF0ZUFjY291bnQoYWNjb3VudElkLCBwdWJsaWNLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhY2NvdW50XzEuQWNjb3VudCh0aGlzLmNvbm5lY3Rpb24sIGFjY291bnRJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhciA9IE5lYXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/near.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/providers/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/near-api-js/lib/providers/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/** @hidden @module */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ErrorContext = exports.TypedError = exports.getTransactionLastResult = exports.FinalExecutionStatusBasic = exports.JsonRpcProvider = exports.Provider = void 0;\nconst provider_1 = __webpack_require__(/*! ./provider */ \"(ssr)/./node_modules/near-api-js/lib/providers/provider.js\");\nObject.defineProperty(exports, \"Provider\", ({ enumerable: true, get: function () { return provider_1.Provider; } }));\nObject.defineProperty(exports, \"getTransactionLastResult\", ({ enumerable: true, get: function () { return provider_1.getTransactionLastResult; } }));\nObject.defineProperty(exports, \"FinalExecutionStatusBasic\", ({ enumerable: true, get: function () { return provider_1.FinalExecutionStatusBasic; } }));\nconst json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/near-api-js/lib/providers/json-rpc-provider.js\");\nObject.defineProperty(exports, \"JsonRpcProvider\", ({ enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcProvider; } }));\nObject.defineProperty(exports, \"TypedError\", ({ enumerable: true, get: function () { return json_rpc_provider_1.TypedError; } }));\nObject.defineProperty(exports, \"ErrorContext\", ({ enumerable: true, get: function () { return json_rpc_provider_1.ErrorContext; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3Byb3ZpZGVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLGdDQUFnQyxHQUFHLGlDQUFpQyxHQUFHLHVCQUF1QixHQUFHLGdCQUFnQjtBQUM3SixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBWTtBQUN2Qyw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsNERBQTJELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ2xKLDZEQUE0RCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUNwSiw0QkFBNEIsbUJBQU8sQ0FBQyxnR0FBcUI7QUFDekQsbURBQWtELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ3pJLDhDQUE2QyxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUMvSCxnREFBK0MsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi9wcm92aWRlcnMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQGhpZGRlbiBAbW9kdWxlICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVycm9yQ29udGV4dCA9IGV4cG9ydHMuVHlwZWRFcnJvciA9IGV4cG9ydHMuZ2V0VHJhbnNhY3Rpb25MYXN0UmVzdWx0ID0gZXhwb3J0cy5GaW5hbEV4ZWN1dGlvblN0YXR1c0Jhc2ljID0gZXhwb3J0cy5Kc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLlByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyXzEuUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRUcmFuc2FjdGlvbkxhc3RSZXN1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyXzEuZ2V0VHJhbnNhY3Rpb25MYXN0UmVzdWx0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmluYWxFeGVjdXRpb25TdGF0dXNCYXNpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfMS5GaW5hbEV4ZWN1dGlvblN0YXR1c0Jhc2ljOyB9IH0pO1xuY29uc3QganNvbl9ycGNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2pzb24tcnBjLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNvblJwY1Byb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX3JwY19wcm92aWRlcl8xLkpzb25ScGNQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVkRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fcnBjX3Byb3ZpZGVyXzEuVHlwZWRFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yQ29udGV4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9ycGNfcHJvdmlkZXJfMS5FcnJvckNvbnRleHQ7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/providers/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/providers/json-rpc-provider.js":
/*!*********************************************************************!*\
  !*** ./node_modules/near-api-js/lib/providers/json-rpc-provider.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonRpcProvider = exports.ErrorContext = exports.TypedError = void 0;\n/**\n * @module\n * @description\n * This module contains the {@link JsonRpcProvider} client class\n * which can be used to interact with the [NEAR RPC API](https://docs.near.org/api/rpc/introduction).\n * @see {@link providers/provider | providers} for a list of request and response types\n */\nconst provider_1 = __webpack_require__(/*! ./provider */ \"(ssr)/./node_modules/near-api-js/lib/providers/provider.js\");\nconst web_1 = __webpack_require__(/*! ../utils/web */ \"(ssr)/./node_modules/near-api-js/lib/utils/web.js\");\nconst errors_1 = __webpack_require__(/*! ../utils/errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/errors.js\");\nObject.defineProperty(exports, \"TypedError\", ({ enumerable: true, get: function () { return errors_1.TypedError; } }));\nObject.defineProperty(exports, \"ErrorContext\", ({ enumerable: true, get: function () { return errors_1.ErrorContext; } }));\nconst borsh_1 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\nconst exponential_backoff_1 = __importDefault(__webpack_require__(/*! ../utils/exponential-backoff */ \"(ssr)/./node_modules/near-api-js/lib/utils/exponential-backoff.js\"));\nconst rpc_errors_1 = __webpack_require__(/*! ../utils/rpc_errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/rpc_errors.js\");\n// Default number of retries before giving up on a request.\nconst REQUEST_RETRY_NUMBER = 12;\n// Default wait until next retry in millis.\nconst REQUEST_RETRY_WAIT = 500;\n// Exponential back off for waiting to retry.\nconst REQUEST_RETRY_WAIT_BACKOFF = 1.5;\n/// Keep ids unique across all connections.\nlet _nextId = 123;\n/**\n * Client class to interact with the [NEAR RPC API](https://docs.near.org/api/rpc/introduction).\n * @see [https://github.com/near/nearcore/tree/master/chain/jsonrpc](https://github.com/near/nearcore/tree/master/chain/jsonrpc)\n */\nclass JsonRpcProvider extends provider_1.Provider {\n    /**\n     * @param connectionInfo Connection info\n     */\n    constructor(connectionInfo) {\n        super();\n        this.connection = connectionInfo || { url: '' };\n    }\n    /**\n     * Gets the RPC's status\n     * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)\n     */\n    status() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.sendJsonRpc('status', []);\n        });\n    }\n    /**\n     * Sends a signed transaction to the RPC and waits until transaction is fully complete\n     * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)\n     *\n     * @param signedTransaction The signed transaction being sent\n     */\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bytes = signedTransaction.encode();\n            return this.sendJsonRpc('broadcast_tx_commit', [Buffer.from(bytes).toString('base64')]);\n        });\n    }\n    /**\n     * Sends a signed transaction to the RPC and immediately returns transaction hash\n     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)\n     * @param signedTransaction The signed transaction being sent\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    sendTransactionAsync(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bytes = signedTransaction.encode();\n            return this.sendJsonRpc('broadcast_tx_async', [Buffer.from(bytes).toString('base64')]);\n        });\n    }\n    /**\n     * Gets a transaction's status from the RPC\n     * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)\n     *\n     * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string\n     * @param accountId The NEAR account that signed the transaction\n     */\n    txStatus(txHash, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof txHash === 'string') {\n                return this.txStatusString(txHash, accountId);\n            }\n            else {\n                return this.txStatusUint8Array(txHash, accountId);\n            }\n        });\n    }\n    txStatusUint8Array(txHash, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.sendJsonRpc('tx', [(0, borsh_1.baseEncode)(txHash), accountId]);\n        });\n    }\n    txStatusString(txHash, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.sendJsonRpc('tx', [txHash, accountId]);\n        });\n    }\n    /**\n     * Gets a transaction's status from the RPC with receipts\n     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)\n     * @param txHash The hash of the transaction\n     * @param accountId The NEAR account that signed the transaction\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    txStatusReceipts(txHash, accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof txHash === 'string') {\n                return this.sendJsonRpc('EXPERIMENTAL_tx_status', [txHash, accountId]);\n            }\n            else {\n                return this.sendJsonRpc('EXPERIMENTAL_tx_status', [(0, borsh_1.baseEncode)(txHash), accountId]);\n            }\n        });\n    }\n    /**\n     * Query the RPC by passing an {@link providers/provider!RpcQueryRequest}\n     * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)\n     *\n     * @typeParam T the shape of the returned query response\n     */\n    query(...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result;\n            if (args.length === 1) {\n                const _a = args[0], { block_id, blockId } = _a, otherParams = __rest(_a, [\"block_id\", \"blockId\"]);\n                result = yield this.sendJsonRpc('query', Object.assign(Object.assign({}, otherParams), { block_id: block_id || blockId }));\n            }\n            else {\n                const [path, data] = args;\n                result = yield this.sendJsonRpc('query', [path, data]);\n            }\n            if (result && result.error) {\n                throw new errors_1.TypedError(`Querying failed: ${result.error}.\\n${JSON.stringify(result, null, 2)}`, result.error.name);\n            }\n            return result;\n        });\n    }\n    /**\n     * Query for block info from the RPC\n     * pass block_id OR finality as blockQuery, not both\n     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)\n     *\n     * @param blockQuery {@link providers/provider!BlockReference} (passing a {@link providers/provider!BlockId} is deprecated)\n     */\n    block(blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { finality } = blockQuery;\n            const { blockId } = blockQuery;\n            return this.sendJsonRpc('block', { block_id: blockId, finality });\n        });\n    }\n    /**\n     * Query changes in block from the RPC\n     * pass block_id OR finality as blockQuery, not both\n     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)\n     */\n    blockChanges(blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { finality } = blockQuery;\n            const { blockId } = blockQuery;\n            return this.sendJsonRpc('EXPERIMENTAL_changes_in_block', { block_id: blockId, finality });\n        });\n    }\n    /**\n     * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block\n     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)\n     *\n     * @param chunkId Hash of a chunk ID or shard ID\n     */\n    chunk(chunkId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.sendJsonRpc('chunk', [chunkId]);\n        });\n    }\n    /**\n     * Query validators of the epoch defined by the given block id.\n     * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)\n     *\n     * @param blockId Block hash or height, or null for latest.\n     */\n    validators(blockId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.sendJsonRpc('validators', [blockId]);\n        });\n    }\n    /**\n     * Gets the protocol config at a block from RPC\n     *\n     * @param blockReference specifies the block to get the protocol config for\n     */\n    experimental_protocolConfig(blockReference) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _a = blockReference, { blockId } = _a, otherParams = __rest(_a, [\"blockId\"]);\n            return yield this.sendJsonRpc('EXPERIMENTAL_protocol_config', Object.assign(Object.assign({}, otherParams), { block_id: blockId }));\n        });\n    }\n    /**\n     * Gets a light client execution proof for verifying execution outcomes\n     * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)\n     */\n    lightClientProof(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.sendJsonRpc('EXPERIMENTAL_light_client_proof', request);\n        });\n    }\n    /**\n     * Gets access key changes for a given array of accountIds\n     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)\n     * @returns {Promise<ChangeResult>}\n     */\n    accessKeyChanges(accountIdArray, blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { finality } = blockQuery;\n            const { blockId } = blockQuery;\n            return this.sendJsonRpc('EXPERIMENTAL_changes', {\n                changes_type: 'all_access_key_changes',\n                account_ids: accountIdArray,\n                block_id: blockId,\n                finality\n            });\n        });\n    }\n    /**\n     * Gets single access key changes for a given array of access keys\n     * pass block_id OR finality as blockQuery, not both\n     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)\n     * @returns {Promise<ChangeResult>}\n     */\n    singleAccessKeyChanges(accessKeyArray, blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { finality } = blockQuery;\n            const { blockId } = blockQuery;\n            return this.sendJsonRpc('EXPERIMENTAL_changes', {\n                changes_type: 'single_access_key_changes',\n                keys: accessKeyArray,\n                block_id: blockId,\n                finality\n            });\n        });\n    }\n    /**\n     * Gets account changes for a given array of accountIds\n     * pass block_id OR finality as blockQuery, not both\n     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)\n     * @returns {Promise<ChangeResult>}\n     */\n    accountChanges(accountIdArray, blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { finality } = blockQuery;\n            const { blockId } = blockQuery;\n            return this.sendJsonRpc('EXPERIMENTAL_changes', {\n                changes_type: 'account_changes',\n                account_ids: accountIdArray,\n                block_id: blockId,\n                finality\n            });\n        });\n    }\n    /**\n     * Gets contract state changes for a given array of accountIds\n     * pass block_id OR finality as blockQuery, not both\n     * Note: If you pass a keyPrefix it must be base64 encoded\n     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)\n     * @returns {Promise<ChangeResult>}\n     */\n    contractStateChanges(accountIdArray, blockQuery, keyPrefix = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { finality } = blockQuery;\n            const { blockId } = blockQuery;\n            return this.sendJsonRpc('EXPERIMENTAL_changes', {\n                changes_type: 'data_changes',\n                account_ids: accountIdArray,\n                key_prefix_base64: keyPrefix,\n                block_id: blockId,\n                finality\n            });\n        });\n    }\n    /**\n     * Gets contract code changes for a given array of accountIds\n     * pass block_id OR finality as blockQuery, not both\n     * Note: Change is returned in a base64 encoded WASM file\n     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)\n     * @returns {Promise<ChangeResult>}\n     */\n    contractCodeChanges(accountIdArray, blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { finality } = blockQuery;\n            const { blockId } = blockQuery;\n            return this.sendJsonRpc('EXPERIMENTAL_changes', {\n                changes_type: 'contract_code_changes',\n                account_ids: accountIdArray,\n                block_id: blockId,\n                finality\n            });\n        });\n    }\n    /**\n     * Returns gas price for a specific block_height or block_hash.\n     * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)\n     *\n     * @param blockId Block hash or height, or null for latest.\n     */\n    gasPrice(blockId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.sendJsonRpc('gas_price', [blockId]);\n        });\n    }\n    /**\n     * Directly call the RPC specifying the method and params\n     *\n     * @param method RPC method\n     * @param params Parameters to the method\n     */\n    sendJsonRpc(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield (0, exponential_backoff_1.default)(REQUEST_RETRY_WAIT, REQUEST_RETRY_NUMBER, REQUEST_RETRY_WAIT_BACKOFF, () => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const request = {\n                        method,\n                        params,\n                        id: (_nextId++),\n                        jsonrpc: '2.0'\n                    };\n                    const response = yield (0, web_1.fetchJson)(this.connection, JSON.stringify(request));\n                    if (response.error) {\n                        if (typeof response.error.data === 'object') {\n                            if (typeof response.error.data.error_message === 'string' && typeof response.error.data.error_type === 'string') {\n                                // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n                                throw new errors_1.TypedError(response.error.data.error_message, response.error.data.error_type);\n                            }\n                            throw (0, rpc_errors_1.parseRpcError)(response.error.data);\n                        }\n                        else {\n                            const errorMessage = `[${response.error.code}] ${response.error.message}: ${response.error.data}`;\n                            // NOTE: All this hackery is happening because structured errors not implemented\n                            // TODO: Fix when https://github.com/nearprotocol/nearcore/issues/1839 gets resolved\n                            if (response.error.data === 'Timeout' || errorMessage.includes('Timeout error')\n                                || errorMessage.includes('query has timed out')) {\n                                throw new errors_1.TypedError(errorMessage, 'TimeoutError');\n                            }\n                            throw new errors_1.TypedError(errorMessage, response.error.name);\n                        }\n                    }\n                    // Success when response.error is not exist\n                    return response;\n                }\n                catch (error) {\n                    if (error.type === 'TimeoutError') {\n                        if (!process.env['NEAR_NO_LOGS']) {\n                            console.warn(`Retrying request to ${method} as it has timed out`, params);\n                        }\n                        return null;\n                    }\n                    throw error;\n                }\n            }));\n            const { result } = response;\n            // From jsonrpc spec:\n            // result\n            //   This member is REQUIRED on success.\n            //   This member MUST NOT exist if there was an error invoking the method.\n            if (typeof result === 'undefined') {\n                throw new errors_1.TypedError(`Exceeded ${REQUEST_RETRY_NUMBER} attempts for request to ${method}.`, 'RetriesExceeded');\n            }\n            return result;\n        });\n    }\n}\nexports.JsonRpcProvider = JsonRpcProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3Byb3ZpZGVycy9qc29uLXJwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0EsU0FBUyxzQ0FBc0M7QUFDL0M7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBWTtBQUN2QyxjQUFjLG1CQUFPLENBQUMsdUVBQWM7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsNkVBQWlCO0FBQzFDLDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCxnREFBK0MsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDeEgsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQU87QUFDL0IsOENBQThDLG1CQUFPLENBQUMsdUdBQThCO0FBQ3BGLHFCQUFxQixtQkFBTyxDQUFDLHFGQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQsdUZBQXVGLGtCQUFrQiwrQkFBK0I7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGFBQWEsS0FBSyxnQ0FBZ0M7QUFDcEg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUNBQXlDLFlBQVksa0NBQWtDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLG9CQUFvQixVQUFVO0FBQzlCLCtDQUErQyw2QkFBNkI7QUFDNUUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixvQkFBb0IsVUFBVTtBQUM5Qix1RUFBdUUsNkJBQTZCO0FBQ3BHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQsd0dBQXdHLGtCQUFrQixtQkFBbUI7QUFDN0ksU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0Isb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsb0JBQW9CLElBQUksdUJBQXVCLElBQUksb0JBQW9CO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzQkFBc0IsMEJBQTBCLE9BQU87QUFDakg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIvcHJvdmlkZXJzL2pzb24tcnBjLXByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuRXJyb3JDb250ZXh0ID0gZXhwb3J0cy5UeXBlZEVycm9yID0gdm9pZCAwO1xuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHRoZSB7QGxpbmsgSnNvblJwY1Byb3ZpZGVyfSBjbGllbnQgY2xhc3NcbiAqIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGludGVyYWN0IHdpdGggdGhlIFtORUFSIFJQQyBBUEldKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2ludHJvZHVjdGlvbikuXG4gKiBAc2VlIHtAbGluayBwcm92aWRlcnMvcHJvdmlkZXIgfCBwcm92aWRlcnN9IGZvciBhIGxpc3Qgb2YgcmVxdWVzdCBhbmQgcmVzcG9uc2UgdHlwZXNcbiAqL1xuY29uc3QgcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyXCIpO1xuY29uc3Qgd2ViXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvd2ViXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZXJyb3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZWRFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzXzEuVHlwZWRFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yQ29udGV4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzXzEuRXJyb3JDb250ZXh0OyB9IH0pO1xuY29uc3QgYm9yc2hfMSA9IHJlcXVpcmUoXCJib3JzaFwiKTtcbmNvbnN0IGV4cG9uZW50aWFsX2JhY2tvZmZfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvZXhwb25lbnRpYWwtYmFja29mZlwiKSk7XG5jb25zdCBycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvcnBjX2Vycm9yc1wiKTtcbi8vIERlZmF1bHQgbnVtYmVyIG9mIHJldHJpZXMgYmVmb3JlIGdpdmluZyB1cCBvbiBhIHJlcXVlc3QuXG5jb25zdCBSRVFVRVNUX1JFVFJZX05VTUJFUiA9IDEyO1xuLy8gRGVmYXVsdCB3YWl0IHVudGlsIG5leHQgcmV0cnkgaW4gbWlsbGlzLlxuY29uc3QgUkVRVUVTVF9SRVRSWV9XQUlUID0gNTAwO1xuLy8gRXhwb25lbnRpYWwgYmFjayBvZmYgZm9yIHdhaXRpbmcgdG8gcmV0cnkuXG5jb25zdCBSRVFVRVNUX1JFVFJZX1dBSVRfQkFDS09GRiA9IDEuNTtcbi8vLyBLZWVwIGlkcyB1bmlxdWUgYWNyb3NzIGFsbCBjb25uZWN0aW9ucy5cbmxldCBfbmV4dElkID0gMTIzO1xuLyoqXG4gKiBDbGllbnQgY2xhc3MgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgW05FQVIgUlBDIEFQSV0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvaW50cm9kdWN0aW9uKS5cbiAqIEBzZWUgW2h0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL25lYXJjb3JlL3RyZWUvbWFzdGVyL2NoYWluL2pzb25ycGNdKGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL25lYXJjb3JlL3RyZWUvbWFzdGVyL2NoYWluL2pzb25ycGMpXG4gKi9cbmNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyXzEuUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSW5mbyBDb25uZWN0aW9uIGluZm9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uSW5mbykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uSW5mbyB8fCB7IHVybDogJycgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUlBDJ3Mgc3RhdHVzXG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvZGV2ZWxvcC9mcm9udC1lbmQvcnBjI2dlbmVyYWwtdmFsaWRhdG9yLXN0YXR1c10oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvZGV2ZWxvcC9mcm9udC1lbmQvcnBjI2dlbmVyYWwtdmFsaWRhdG9yLXN0YXR1cylcbiAgICAgKi9cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kSnNvblJwYygnc3RhdHVzJywgW10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBzaWduZWQgdHJhbnNhY3Rpb24gdG8gdGhlIFJQQyBhbmQgd2FpdHMgdW50aWwgdHJhbnNhY3Rpb24gaXMgZnVsbHkgY29tcGxldGVcbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9kZXZlbG9wL2Zyb250LWVuZC9ycGMjc2VuZC10cmFuc2FjdGlvbi1hd2FpdF0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvZGV2ZWxvcC9mcm9udC1lbmQvcnBjI2dlbmVyYWwtdmFsaWRhdG9yLXN0YXR1cylcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduZWRUcmFuc2FjdGlvbiBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uIGJlaW5nIHNlbnRcbiAgICAgKi9cbiAgICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gc2lnbmVkVHJhbnNhY3Rpb24uZW5jb2RlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kSnNvblJwYygnYnJvYWRjYXN0X3R4X2NvbW1pdCcsIFtCdWZmZXIuZnJvbShieXRlcykudG9TdHJpbmcoJ2Jhc2U2NCcpXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHNpZ25lZCB0cmFuc2FjdGlvbiB0byB0aGUgUlBDIGFuZCBpbW1lZGlhdGVseSByZXR1cm5zIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgKiBTZWUgW2RvY3MgZm9yIG1vcmUgaW5mb10oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvZGV2ZWxvcC9mcm9udC1lbmQvcnBjI3NlbmQtdHJhbnNhY3Rpb24tYXN5bmMpXG4gICAgICogQHBhcmFtIHNpZ25lZFRyYW5zYWN0aW9uIFRoZSBzaWduZWQgdHJhbnNhY3Rpb24gYmVpbmcgc2VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59XG4gICAgICovXG4gICAgc2VuZFRyYW5zYWN0aW9uQXN5bmMoc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gc2lnbmVkVHJhbnNhY3Rpb24uZW5jb2RlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kSnNvblJwYygnYnJvYWRjYXN0X3R4X2FzeW5jJywgW0J1ZmZlci5mcm9tKGJ5dGVzKS50b1N0cmluZygnYmFzZTY0JyldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSB0cmFuc2FjdGlvbidzIHN0YXR1cyBmcm9tIHRoZSBSUENcbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9kZXZlbG9wL2Zyb250LWVuZC9ycGMjdHJhbnNhY3Rpb24tc3RhdHVzXShodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9kZXZlbG9wL2Zyb250LWVuZC9ycGMjZ2VuZXJhbC12YWxpZGF0b3Itc3RhdHVzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHR4SGFzaCBBIHRyYW5zYWN0aW9uIGhhc2ggYXMgZWl0aGVyIGEgVWludDhBcnJheSBvciBhIGJhc2U1OCBlbmNvZGVkIHN0cmluZ1xuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0aGF0IHNpZ25lZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0eFN0YXR1cyh0eEhhc2gsIGFjY291bnRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eEhhc2ggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHhTdGF0dXNTdHJpbmcodHhIYXNoLCBhY2NvdW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHhTdGF0dXNVaW50OEFycmF5KHR4SGFzaCwgYWNjb3VudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHR4U3RhdHVzVWludDhBcnJheSh0eEhhc2gsIGFjY291bnRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEpzb25ScGMoJ3R4JywgWygwLCBib3JzaF8xLmJhc2VFbmNvZGUpKHR4SGFzaCksIGFjY291bnRJZF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHhTdGF0dXNTdHJpbmcodHhIYXNoLCBhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRKc29uUnBjKCd0eCcsIFt0eEhhc2gsIGFjY291bnRJZF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHRyYW5zYWN0aW9uJ3Mgc3RhdHVzIGZyb20gdGhlIFJQQyB3aXRoIHJlY2VpcHRzXG4gICAgICogU2VlIFtkb2NzIGZvciBtb3JlIGluZm9dKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9kb2NzL2RldmVsb3AvZnJvbnQtZW5kL3JwYyN0cmFuc2FjdGlvbi1zdGF0dXMtd2l0aC1yZWNlaXB0cylcbiAgICAgKiBAcGFyYW0gdHhIYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0aGF0IHNpZ25lZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fVxuICAgICAqL1xuICAgIHR4U3RhdHVzUmVjZWlwdHModHhIYXNoLCBhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHhIYXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRKc29uUnBjKCdFWFBFUklNRU5UQUxfdHhfc3RhdHVzJywgW3R4SGFzaCwgYWNjb3VudElkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kSnNvblJwYygnRVhQRVJJTUVOVEFMX3R4X3N0YXR1cycsIFsoMCwgYm9yc2hfMS5iYXNlRW5jb2RlKSh0eEhhc2gpLCBhY2NvdW50SWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHRoZSBSUEMgYnkgcGFzc2luZyBhbiB7QGxpbmsgcHJvdmlkZXJzL3Byb3ZpZGVyIVJwY1F1ZXJ5UmVxdWVzdH1cbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHNdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cylcbiAgICAgKlxuICAgICAqIEB0eXBlUGFyYW0gVCB0aGUgc2hhcGUgb2YgdGhlIHJldHVybmVkIHF1ZXJ5IHJlc3BvbnNlXG4gICAgICovXG4gICAgcXVlcnkoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9hID0gYXJnc1swXSwgeyBibG9ja19pZCwgYmxvY2tJZCB9ID0gX2EsIG90aGVyUGFyYW1zID0gX19yZXN0KF9hLCBbXCJibG9ja19pZFwiLCBcImJsb2NrSWRcIl0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuc2VuZEpzb25ScGMoJ3F1ZXJ5JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdGhlclBhcmFtcyksIHsgYmxvY2tfaWQ6IGJsb2NrX2lkIHx8IGJsb2NrSWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3BhdGgsIGRhdGFdID0gYXJncztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLnNlbmRKc29uUnBjKCdxdWVyeScsIFtwYXRoLCBkYXRhXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5UeXBlZEVycm9yKGBRdWVyeWluZyBmYWlsZWQ6ICR7cmVzdWx0LmVycm9yfS5cXG4ke0pTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMil9YCwgcmVzdWx0LmVycm9yLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBibG9jayBpbmZvIGZyb20gdGhlIFJQQ1xuICAgICAqIHBhc3MgYmxvY2tfaWQgT1IgZmluYWxpdHkgYXMgYmxvY2tRdWVyeSwgbm90IGJvdGhcbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9ibG9jay1jaHVua10oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvYmxvY2stY2h1bmspXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmxvY2tRdWVyeSB7QGxpbmsgcHJvdmlkZXJzL3Byb3ZpZGVyIUJsb2NrUmVmZXJlbmNlfSAocGFzc2luZyBhIHtAbGluayBwcm92aWRlcnMvcHJvdmlkZXIhQmxvY2tJZH0gaXMgZGVwcmVjYXRlZClcbiAgICAgKi9cbiAgICBibG9jayhibG9ja1F1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZpbmFsaXR5IH0gPSBibG9ja1F1ZXJ5O1xuICAgICAgICAgICAgY29uc3QgeyBibG9ja0lkIH0gPSBibG9ja1F1ZXJ5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEpzb25ScGMoJ2Jsb2NrJywgeyBibG9ja19pZDogYmxvY2tJZCwgZmluYWxpdHkgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjaGFuZ2VzIGluIGJsb2NrIGZyb20gdGhlIFJQQ1xuICAgICAqIHBhc3MgYmxvY2tfaWQgT1IgZmluYWxpdHkgYXMgYmxvY2tRdWVyeSwgbm90IGJvdGhcbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9ibG9jay1jaHVua10oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvYmxvY2stY2h1bmspXG4gICAgICovXG4gICAgYmxvY2tDaGFuZ2VzKGJsb2NrUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmluYWxpdHkgfSA9IGJsb2NrUXVlcnk7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrSWQgfSA9IGJsb2NrUXVlcnk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kSnNvblJwYygnRVhQRVJJTUVOVEFMX2NoYW5nZXNfaW5fYmxvY2snLCB7IGJsb2NrX2lkOiBibG9ja0lkLCBmaW5hbGl0eSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgZm9yIGRldGFpbHMgYWJvdXQgYSBzcGVjaWZpYyBjaHVuayBhcHBlbmRpbmcgZGV0YWlscyBvZiByZWNlaXB0cyBhbmQgdHJhbnNhY3Rpb25zIHRvIHRoZSBzYW1lIGNodW5rIGRhdGEgcHJvdmlkZWQgYnkgYSBibG9ja1xuICAgICAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2Jsb2NrLWNodW5rXShodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9ibG9jay1jaHVuaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaHVua0lkIEhhc2ggb2YgYSBjaHVuayBJRCBvciBzaGFyZCBJRFxuICAgICAqL1xuICAgIGNodW5rKGNodW5rSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRKc29uUnBjKCdjaHVuaycsIFtjaHVua0lkXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSB2YWxpZGF0b3JzIG9mIHRoZSBlcG9jaCBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBibG9jayBpZC5cbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9uZXR3b3JrI3ZhbGlkYXRpb24tc3RhdHVzXShodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9uZXR3b3JrI3ZhbGlkYXRpb24tc3RhdHVzKVxuICAgICAqXG4gICAgICogQHBhcmFtIGJsb2NrSWQgQmxvY2sgaGFzaCBvciBoZWlnaHQsIG9yIG51bGwgZm9yIGxhdGVzdC5cbiAgICAgKi9cbiAgICB2YWxpZGF0b3JzKGJsb2NrSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRKc29uUnBjKCd2YWxpZGF0b3JzJywgW2Jsb2NrSWRdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3RvY29sIGNvbmZpZyBhdCBhIGJsb2NrIGZyb20gUlBDXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmxvY2tSZWZlcmVuY2Ugc3BlY2lmaWVzIHRoZSBibG9jayB0byBnZXQgdGhlIHByb3RvY29sIGNvbmZpZyBmb3JcbiAgICAgKi9cbiAgICBleHBlcmltZW50YWxfcHJvdG9jb2xDb25maWcoYmxvY2tSZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IF9hID0gYmxvY2tSZWZlcmVuY2UsIHsgYmxvY2tJZCB9ID0gX2EsIG90aGVyUGFyYW1zID0gX19yZXN0KF9hLCBbXCJibG9ja0lkXCJdKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnNlbmRKc29uUnBjKCdFWFBFUklNRU5UQUxfcHJvdG9jb2xfY29uZmlnJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdGhlclBhcmFtcyksIHsgYmxvY2tfaWQ6IGJsb2NrSWQgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpZ2h0IGNsaWVudCBleGVjdXRpb24gcHJvb2YgZm9yIHZlcmlmeWluZyBleGVjdXRpb24gb3V0Y29tZXNcbiAgICAgKiBAc2VlIFtodHRwczovL2dpdGh1Yi5jb20vbmVhcnByb3RvY29sL05FUHMvYmxvYi9tYXN0ZXIvc3BlY3MvQ2hhaW5TcGVjL0xpZ2h0Q2xpZW50Lm1kI2xpZ2h0LWNsaWVudC1wcm9vZl0oaHR0cHM6Ly9naXRodWIuY29tL25lYXJwcm90b2NvbC9ORVBzL2Jsb2IvbWFzdGVyL3NwZWNzL0NoYWluU3BlYy9MaWdodENsaWVudC5tZCNsaWdodC1jbGllbnQtcHJvb2YpXG4gICAgICovXG4gICAgbGlnaHRDbGllbnRQcm9vZihyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zZW5kSnNvblJwYygnRVhQRVJJTUVOVEFMX2xpZ2h0X2NsaWVudF9wcm9vZicsIHJlcXVlc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhY2Nlc3Mga2V5IGNoYW5nZXMgZm9yIGEgZ2l2ZW4gYXJyYXkgb2YgYWNjb3VudElkc1xuICAgICAqIFNlZSBbZG9jcyBmb3IgbW9yZSBpbmZvXShodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9kZXZlbG9wL2Zyb250LWVuZC9ycGMjdmlldy1hY2Nlc3Mta2V5LWNoYW5nZXMtYWxsKVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5nZVJlc3VsdD59XG4gICAgICovXG4gICAgYWNjZXNzS2V5Q2hhbmdlcyhhY2NvdW50SWRBcnJheSwgYmxvY2tRdWVyeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBmaW5hbGl0eSB9ID0gYmxvY2tRdWVyeTtcbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tJZCB9ID0gYmxvY2tRdWVyeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRKc29uUnBjKCdFWFBFUklNRU5UQUxfY2hhbmdlcycsIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzX3R5cGU6ICdhbGxfYWNjZXNzX2tleV9jaGFuZ2VzJyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkczogYWNjb3VudElkQXJyYXksXG4gICAgICAgICAgICAgICAgYmxvY2tfaWQ6IGJsb2NrSWQsXG4gICAgICAgICAgICAgICAgZmluYWxpdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBzaW5nbGUgYWNjZXNzIGtleSBjaGFuZ2VzIGZvciBhIGdpdmVuIGFycmF5IG9mIGFjY2VzcyBrZXlzXG4gICAgICogcGFzcyBibG9ja19pZCBPUiBmaW5hbGl0eSBhcyBibG9ja1F1ZXJ5LCBub3QgYm90aFxuICAgICAqIFNlZSBbZG9jcyBmb3IgbW9yZSBpbmZvXShodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9kZXZlbG9wL2Zyb250LWVuZC9ycGMjdmlldy1hY2Nlc3Mta2V5LWNoYW5nZXMtc2luZ2xlKVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5nZVJlc3VsdD59XG4gICAgICovXG4gICAgc2luZ2xlQWNjZXNzS2V5Q2hhbmdlcyhhY2Nlc3NLZXlBcnJheSwgYmxvY2tRdWVyeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBmaW5hbGl0eSB9ID0gYmxvY2tRdWVyeTtcbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tJZCB9ID0gYmxvY2tRdWVyeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRKc29uUnBjKCdFWFBFUklNRU5UQUxfY2hhbmdlcycsIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzX3R5cGU6ICdzaW5nbGVfYWNjZXNzX2tleV9jaGFuZ2VzJyxcbiAgICAgICAgICAgICAgICBrZXlzOiBhY2Nlc3NLZXlBcnJheSxcbiAgICAgICAgICAgICAgICBibG9ja19pZDogYmxvY2tJZCxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFjY291bnQgY2hhbmdlcyBmb3IgYSBnaXZlbiBhcnJheSBvZiBhY2NvdW50SWRzXG4gICAgICogcGFzcyBibG9ja19pZCBPUiBmaW5hbGl0eSBhcyBibG9ja1F1ZXJ5LCBub3QgYm90aFxuICAgICAqIFNlZSBbZG9jcyBmb3IgbW9yZSBpbmZvXShodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9kZXZlbG9wL2Zyb250LWVuZC9ycGMjdmlldy1hY2NvdW50LWNoYW5nZXMpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbmdlUmVzdWx0Pn1cbiAgICAgKi9cbiAgICBhY2NvdW50Q2hhbmdlcyhhY2NvdW50SWRBcnJheSwgYmxvY2tRdWVyeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBmaW5hbGl0eSB9ID0gYmxvY2tRdWVyeTtcbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tJZCB9ID0gYmxvY2tRdWVyeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRKc29uUnBjKCdFWFBFUklNRU5UQUxfY2hhbmdlcycsIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzX3R5cGU6ICdhY2NvdW50X2NoYW5nZXMnLFxuICAgICAgICAgICAgICAgIGFjY291bnRfaWRzOiBhY2NvdW50SWRBcnJheSxcbiAgICAgICAgICAgICAgICBibG9ja19pZDogYmxvY2tJZCxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNvbnRyYWN0IHN0YXRlIGNoYW5nZXMgZm9yIGEgZ2l2ZW4gYXJyYXkgb2YgYWNjb3VudElkc1xuICAgICAqIHBhc3MgYmxvY2tfaWQgT1IgZmluYWxpdHkgYXMgYmxvY2tRdWVyeSwgbm90IGJvdGhcbiAgICAgKiBOb3RlOiBJZiB5b3UgcGFzcyBhIGtleVByZWZpeCBpdCBtdXN0IGJlIGJhc2U2NCBlbmNvZGVkXG4gICAgICogU2VlIFtkb2NzIGZvciBtb3JlIGluZm9dKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9kb2NzL2RldmVsb3AvZnJvbnQtZW5kL3JwYyN2aWV3LWNvbnRyYWN0LXN0YXRlLWNoYW5nZXMpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbmdlUmVzdWx0Pn1cbiAgICAgKi9cbiAgICBjb250cmFjdFN0YXRlQ2hhbmdlcyhhY2NvdW50SWRBcnJheSwgYmxvY2tRdWVyeSwga2V5UHJlZml4ID0gJycpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmluYWxpdHkgfSA9IGJsb2NrUXVlcnk7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrSWQgfSA9IGJsb2NrUXVlcnk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kSnNvblJwYygnRVhQRVJJTUVOVEFMX2NoYW5nZXMnLCB7XG4gICAgICAgICAgICAgICAgY2hhbmdlc190eXBlOiAnZGF0YV9jaGFuZ2VzJyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkczogYWNjb3VudElkQXJyYXksXG4gICAgICAgICAgICAgICAga2V5X3ByZWZpeF9iYXNlNjQ6IGtleVByZWZpeCxcbiAgICAgICAgICAgICAgICBibG9ja19pZDogYmxvY2tJZCxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNvbnRyYWN0IGNvZGUgY2hhbmdlcyBmb3IgYSBnaXZlbiBhcnJheSBvZiBhY2NvdW50SWRzXG4gICAgICogcGFzcyBibG9ja19pZCBPUiBmaW5hbGl0eSBhcyBibG9ja1F1ZXJ5LCBub3QgYm90aFxuICAgICAqIE5vdGU6IENoYW5nZSBpcyByZXR1cm5lZCBpbiBhIGJhc2U2NCBlbmNvZGVkIFdBU00gZmlsZVxuICAgICAqIFNlZSBbZG9jcyBmb3IgbW9yZSBpbmZvXShodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9kZXZlbG9wL2Zyb250LWVuZC9ycGMjdmlldy1jb250cmFjdC1jb2RlLWNoYW5nZXMpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbmdlUmVzdWx0Pn1cbiAgICAgKi9cbiAgICBjb250cmFjdENvZGVDaGFuZ2VzKGFjY291bnRJZEFycmF5LCBibG9ja1F1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZpbmFsaXR5IH0gPSBibG9ja1F1ZXJ5O1xuICAgICAgICAgICAgY29uc3QgeyBibG9ja0lkIH0gPSBibG9ja1F1ZXJ5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEpzb25ScGMoJ0VYUEVSSU1FTlRBTF9jaGFuZ2VzJywge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNfdHlwZTogJ2NvbnRyYWN0X2NvZGVfY2hhbmdlcycsXG4gICAgICAgICAgICAgICAgYWNjb3VudF9pZHM6IGFjY291bnRJZEFycmF5LFxuICAgICAgICAgICAgICAgIGJsb2NrX2lkOiBibG9ja0lkLFxuICAgICAgICAgICAgICAgIGZpbmFsaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZ2FzIHByaWNlIGZvciBhIHNwZWNpZmljIGJsb2NrX2hlaWdodCBvciBibG9ja19oYXNoLlxuICAgICAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2dhc10oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvZ2FzKVxuICAgICAqXG4gICAgICogQHBhcmFtIGJsb2NrSWQgQmxvY2sgaGFzaCBvciBoZWlnaHQsIG9yIG51bGwgZm9yIGxhdGVzdC5cbiAgICAgKi9cbiAgICBnYXNQcmljZShibG9ja0lkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zZW5kSnNvblJwYygnZ2FzX3ByaWNlJywgW2Jsb2NrSWRdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpcmVjdGx5IGNhbGwgdGhlIFJQQyBzcGVjaWZ5aW5nIHRoZSBtZXRob2QgYW5kIHBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGhvZCBSUEMgbWV0aG9kXG4gICAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHRoZSBtZXRob2RcbiAgICAgKi9cbiAgICBzZW5kSnNvblJwYyhtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCAoMCwgZXhwb25lbnRpYWxfYmFja29mZl8xLmRlZmF1bHQpKFJFUVVFU1RfUkVUUllfV0FJVCwgUkVRVUVTVF9SRVRSWV9OVU1CRVIsIFJFUVVFU1RfUkVUUllfV0FJVF9CQUNLT0ZGLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAoX25leHRJZCsrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgKDAsIHdlYl8xLmZldGNoSnNvbikodGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5lcnJvci5kYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZXJyb3IuZGF0YS5lcnJvcl9tZXNzYWdlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgcmVzcG9uc2UuZXJyb3IuZGF0YS5lcnJvcl90eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBlcnJvciBkYXRhIGhhcyBlcnJvcl9tZXNzYWdlIGFuZCBlcnJvcl90eXBlIHByb3BlcnRpZXMsIHdlIGNvbnNpZGVyIHRoYXQgbm9kZSByZXR1cm5lZCBhbiBlcnJvciBpbiB0aGUgb2xkIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVHlwZWRFcnJvcihyZXNwb25zZS5lcnJvci5kYXRhLmVycm9yX21lc3NhZ2UsIHJlc3BvbnNlLmVycm9yLmRhdGEuZXJyb3JfdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCBycGNfZXJyb3JzXzEucGFyc2VScGNFcnJvcikocmVzcG9uc2UuZXJyb3IuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgWyR7cmVzcG9uc2UuZXJyb3IuY29kZX1dICR7cmVzcG9uc2UuZXJyb3IubWVzc2FnZX06ICR7cmVzcG9uc2UuZXJyb3IuZGF0YX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IEFsbCB0aGlzIGhhY2tlcnkgaXMgaGFwcGVuaW5nIGJlY2F1c2Ugc3RydWN0dXJlZCBlcnJvcnMgbm90IGltcGxlbWVudGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRml4IHdoZW4gaHR0cHM6Ly9naXRodWIuY29tL25lYXJwcm90b2NvbC9uZWFyY29yZS9pc3N1ZXMvMTgzOSBnZXRzIHJlc29sdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yLmRhdGEgPT09ICdUaW1lb3V0JyB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ1RpbWVvdXQgZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ3F1ZXJ5IGhhcyB0aW1lZCBvdXQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVHlwZWRFcnJvcihlcnJvck1lc3NhZ2UsICdUaW1lb3V0RXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlR5cGVkRXJyb3IoZXJyb3JNZXNzYWdlLCByZXNwb25zZS5lcnJvci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIHdoZW4gcmVzcG9uc2UuZXJyb3IgaXMgbm90IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSAnVGltZW91dEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzLmVudlsnTkVBUl9OT19MT0dTJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJldHJ5aW5nIHJlcXVlc3QgdG8gJHttZXRob2R9IGFzIGl0IGhhcyB0aW1lZCBvdXRgLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgLy8gRnJvbSBqc29ucnBjIHNwZWM6XG4gICAgICAgICAgICAvLyByZXN1bHRcbiAgICAgICAgICAgIC8vICAgVGhpcyBtZW1iZXIgaXMgUkVRVUlSRUQgb24gc3VjY2Vzcy5cbiAgICAgICAgICAgIC8vICAgVGhpcyBtZW1iZXIgTVVTVCBOT1QgZXhpc3QgaWYgdGhlcmUgd2FzIGFuIGVycm9yIGludm9raW5nIHRoZSBtZXRob2QuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVHlwZWRFcnJvcihgRXhjZWVkZWQgJHtSRVFVRVNUX1JFVFJZX05VTUJFUn0gYXR0ZW1wdHMgZm9yIHJlcXVlc3QgdG8gJHttZXRob2R9LmAsICdSZXRyaWVzRXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gSnNvblJwY1Byb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/providers/json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/providers/provider.js":
/*!************************************************************!*\
  !*** ./node_modules/near-api-js/lib/providers/provider.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * NEAR RPC API request types and responses\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getTransactionLastResult = exports.Provider = exports.IdType = exports.FinalExecutionStatusBasic = exports.ExecutionStatusBasic = void 0;\nvar ExecutionStatusBasic;\n(function (ExecutionStatusBasic) {\n    ExecutionStatusBasic[\"Unknown\"] = \"Unknown\";\n    ExecutionStatusBasic[\"Pending\"] = \"Pending\";\n    ExecutionStatusBasic[\"Failure\"] = \"Failure\";\n})(ExecutionStatusBasic = exports.ExecutionStatusBasic || (exports.ExecutionStatusBasic = {}));\nvar FinalExecutionStatusBasic;\n(function (FinalExecutionStatusBasic) {\n    FinalExecutionStatusBasic[\"NotStarted\"] = \"NotStarted\";\n    FinalExecutionStatusBasic[\"Started\"] = \"Started\";\n    FinalExecutionStatusBasic[\"Failure\"] = \"Failure\";\n})(FinalExecutionStatusBasic = exports.FinalExecutionStatusBasic || (exports.FinalExecutionStatusBasic = {}));\nvar IdType;\n(function (IdType) {\n    IdType[\"Transaction\"] = \"transaction\";\n    IdType[\"Receipt\"] = \"receipt\";\n})(IdType = exports.IdType || (exports.IdType = {}));\n/** @hidden */\nclass Provider {\n}\nexports.Provider = Provider;\n/** @hidden */\nfunction getTransactionLastResult(txResult) {\n    if (typeof txResult.status === 'object' && typeof txResult.status.SuccessValue === 'string') {\n        const value = Buffer.from(txResult.status.SuccessValue, 'base64').toString();\n        try {\n            return JSON.parse(value);\n        }\n        catch (e) {\n            return value;\n        }\n    }\n    return null;\n}\nexports.getTransactionLastResult = getTransactionLastResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3Byb3ZpZGVycy9wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxpQ0FBaUMsR0FBRyw0QkFBNEI7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBELDRCQUE0QixLQUFLO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9FQUFvRSxpQ0FBaUMsS0FBSztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCLGNBQWMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi9wcm92aWRlcnMvcHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIE5FQVIgUlBDIEFQSSByZXF1ZXN0IHR5cGVzIGFuZCByZXNwb25zZXNcbiAqIEBtb2R1bGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRUcmFuc2FjdGlvbkxhc3RSZXN1bHQgPSBleHBvcnRzLlByb3ZpZGVyID0gZXhwb3J0cy5JZFR5cGUgPSBleHBvcnRzLkZpbmFsRXhlY3V0aW9uU3RhdHVzQmFzaWMgPSBleHBvcnRzLkV4ZWN1dGlvblN0YXR1c0Jhc2ljID0gdm9pZCAwO1xudmFyIEV4ZWN1dGlvblN0YXR1c0Jhc2ljO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25TdGF0dXNCYXNpYykge1xuICAgIEV4ZWN1dGlvblN0YXR1c0Jhc2ljW1wiVW5rbm93blwiXSA9IFwiVW5rbm93blwiO1xuICAgIEV4ZWN1dGlvblN0YXR1c0Jhc2ljW1wiUGVuZGluZ1wiXSA9IFwiUGVuZGluZ1wiO1xuICAgIEV4ZWN1dGlvblN0YXR1c0Jhc2ljW1wiRmFpbHVyZVwiXSA9IFwiRmFpbHVyZVwiO1xufSkoRXhlY3V0aW9uU3RhdHVzQmFzaWMgPSBleHBvcnRzLkV4ZWN1dGlvblN0YXR1c0Jhc2ljIHx8IChleHBvcnRzLkV4ZWN1dGlvblN0YXR1c0Jhc2ljID0ge30pKTtcbnZhciBGaW5hbEV4ZWN1dGlvblN0YXR1c0Jhc2ljO1xuKGZ1bmN0aW9uIChGaW5hbEV4ZWN1dGlvblN0YXR1c0Jhc2ljKSB7XG4gICAgRmluYWxFeGVjdXRpb25TdGF0dXNCYXNpY1tcIk5vdFN0YXJ0ZWRcIl0gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgICBGaW5hbEV4ZWN1dGlvblN0YXR1c0Jhc2ljW1wiU3RhcnRlZFwiXSA9IFwiU3RhcnRlZFwiO1xuICAgIEZpbmFsRXhlY3V0aW9uU3RhdHVzQmFzaWNbXCJGYWlsdXJlXCJdID0gXCJGYWlsdXJlXCI7XG59KShGaW5hbEV4ZWN1dGlvblN0YXR1c0Jhc2ljID0gZXhwb3J0cy5GaW5hbEV4ZWN1dGlvblN0YXR1c0Jhc2ljIHx8IChleHBvcnRzLkZpbmFsRXhlY3V0aW9uU3RhdHVzQmFzaWMgPSB7fSkpO1xudmFyIElkVHlwZTtcbihmdW5jdGlvbiAoSWRUeXBlKSB7XG4gICAgSWRUeXBlW1wiVHJhbnNhY3Rpb25cIl0gPSBcInRyYW5zYWN0aW9uXCI7XG4gICAgSWRUeXBlW1wiUmVjZWlwdFwiXSA9IFwicmVjZWlwdFwiO1xufSkoSWRUeXBlID0gZXhwb3J0cy5JZFR5cGUgfHwgKGV4cG9ydHMuSWRUeXBlID0ge30pKTtcbi8qKiBAaGlkZGVuICovXG5jbGFzcyBQcm92aWRlciB7XG59XG5leHBvcnRzLlByb3ZpZGVyID0gUHJvdmlkZXI7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25MYXN0UmVzdWx0KHR4UmVzdWx0KSB7XG4gICAgaWYgKHR5cGVvZiB0eFJlc3VsdC5zdGF0dXMgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0eFJlc3VsdC5zdGF0dXMuU3VjY2Vzc1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHR4UmVzdWx0LnN0YXR1cy5TdWNjZXNzVmFsdWUsICdiYXNlNjQnKS50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmdldFRyYW5zYWN0aW9uTGFzdFJlc3VsdCA9IGdldFRyYW5zYWN0aW9uTGFzdFJlc3VsdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/providers/provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/res/error_messages.json":
/*!**************************************************************!*\
  !*** ./node_modules/near-api-js/lib/res/error_messages.json ***!
  \**************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"GasLimitExceeded":"Exceeded the maximum amount of gas allowed to burn per contract","MethodEmptyName":"Method name is empty","WasmerCompileError":"Wasmer compilation error: {{msg}}","GuestPanic":"Smart contract panicked: {{panic_msg}}","Memory":"Error creating Wasm memory","GasExceeded":"Exceeded the prepaid gas","MethodUTF8Error":"Method name is not valid UTF8 string","BadUTF16":"String encoding is bad UTF-16 sequence","WasmTrap":"WebAssembly trap: {{msg}}","GasInstrumentation":"Gas instrumentation failed or contract has denied instructions.","InvalidPromiseIndex":"{{promise_idx}} does not correspond to existing promises","InvalidPromiseResultIndex":"Accessed invalid promise result index: {{result_idx}}","Deserialization":"Error happened while deserializing the module","MethodNotFound":"Contract method is not found","InvalidRegisterId":"Accessed invalid register id: {{register_id}}","InvalidReceiptIndex":"VM Logic returned an invalid receipt index: {{receipt_index}}","EmptyMethodName":"Method name is empty in contract call","CannotReturnJointPromise":"Returning joint promise is currently prohibited","StackHeightInstrumentation":"Stack instrumentation failed","CodeDoesNotExist":"Cannot find contract code for account {{account_id}}","MethodInvalidSignature":"Invalid method signature","IntegerOverflow":"Integer overflow happened during contract execution","MemoryAccessViolation":"MemoryAccessViolation","InvalidIteratorIndex":"Iterator index {{iterator_index}} does not exist","IteratorWasInvalidated":"Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie","InvalidAccountId":"VM Logic returned an invalid account id","Serialization":"Error happened while serializing the module","CannotAppendActionToJointPromise":"Actions can only be appended to non-joint promise.","InternalMemoryDeclared":"Internal memory declaration has been found in the module","Instantiate":"Error happened during instantiation","ProhibitedInView":"{{method_name}} is not allowed in view calls","InvalidMethodName":"VM Logic returned an invalid method name","BadUTF8":"String encoding is bad UTF-8 sequence","BalanceExceeded":"Exceeded the account balance","LinkError":"Wasm contract link error: {{msg}}","InvalidPublicKey":"VM Logic provided an invalid public key","ActorNoPermission":"Actor {{actor_id}} doesn\'t have permission to account {{account_id}} to complete the action","LackBalanceForState":"The account {{account_id}} wouldn\'t have enough balance to cover storage, required to have {{amount}} yoctoNEAR more","ReceiverMismatch":"Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.","CostOverflow":"Transaction gas or balance cost is too high","InvalidSignature":"Transaction is not signed with the given public key","AccessKeyNotFound":"Signer \\"{{account_id}}\\" doesn\'t have access key with the given public_key {{public_key}}","NotEnoughBalance":"Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}","NotEnoughAllowance":"Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}","Expired":"Transaction has expired","DeleteAccountStaking":"Account {{account_id}} is staking and can not be deleted","SignerDoesNotExist":"Signer {{signer_id}} does not exist","TriesToStake":"Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}","AddKeyAlreadyExists":"The public key {{public_key}} is already used for an existing access key","InvalidSigner":"Invalid signer account ID {{signer_id}} according to requirements","CreateAccountNotAllowed":"The new account_id {{account_id}} can\'t be created by {{predecessor_id}}","RequiresFullAccess":"The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key","TriesToUnstake":"Account {{account_id}} is not yet staked, but tried to unstake","InvalidNonce":"Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}","AccountAlreadyExists":"Can\'t create a new account {{account_id}}, because it already exists","InvalidChain":"Transaction parent block hash doesn\'t belong to the current chain","AccountDoesNotExist":"Can\'t complete the action because account {{account_id}} doesn\'t exist","MethodNameMismatch":"Transaction method name {{method_name}} isn\'t allowed by the access key","DeleteAccountHasRent":"Account {{account_id}} can\'t be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent","DeleteAccountHasEnoughBalance":"Account {{account_id}} can\'t be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it\'s storage","InvalidReceiver":"Invalid receiver account ID {{receiver_id}} according to requirements","DeleteKeyDoesNotExist":"Account {{account_id}} tries to remove an access key that doesn\'t exist","Timeout":"Timeout exceeded","Closed":"Connection closed"}');

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/signer.js":
/*!************************************************!*\
  !*** ./node_modules/near-api-js/lib/signer.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemorySigner = exports.Signer = void 0;\nconst js_sha256_1 = __importDefault(__webpack_require__(/*! js-sha256 */ \"(ssr)/./node_modules/js-sha256/src/sha256.js\"));\nconst key_pair_1 = __webpack_require__(/*! ./utils/key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\nconst in_memory_key_store_1 = __webpack_require__(/*! ./key_stores/in_memory_key_store */ \"(ssr)/./node_modules/near-api-js/lib/key_stores/in_memory_key_store.js\");\n/**\n * General signing interface, can be used for in memory signing, RPC singing, external wallet, HSM, etc.\n */\nclass Signer {\n}\nexports.Signer = Signer;\n/**\n * Signs using in memory key store.\n */\nclass InMemorySigner extends Signer {\n    constructor(keyStore) {\n        super();\n        this.keyStore = keyStore;\n    }\n    /**\n     * Creates a single account Signer instance with account, network and keyPair provided.\n     *\n     * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).\n     *\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @param accountId The NEAR account to assign the key pair to\n     * @param keyPair The keyPair to use for signing\n     */\n    static fromKeyPair(networkId, accountId, keyPair) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyStore = new in_memory_key_store_1.InMemoryKeyStore();\n            yield keyStore.setKey(networkId, accountId, keyPair);\n            return new InMemorySigner(keyStore);\n        });\n    }\n    /**\n     * Creates a public key for the account given\n     * @param accountId The NEAR account to assign a public key to\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @returns {Promise<PublicKey>}\n     */\n    createKey(accountId, networkId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyPair = key_pair_1.KeyPair.fromRandom('ed25519');\n            yield this.keyStore.setKey(networkId, accountId, keyPair);\n            return keyPair.getPublicKey();\n        });\n    }\n    /**\n     * Gets the existing public key for a given account\n     * @param accountId The NEAR account to assign a public key to\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @returns {Promise<PublicKey>} Returns the public key or null if not found\n     */\n    getPublicKey(accountId, networkId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyPair = yield this.keyStore.getKey(networkId, accountId);\n            if (keyPair === null) {\n                return null;\n            }\n            return keyPair.getPublicKey();\n        });\n    }\n    /**\n     * @param message A message to be signed, typically a serialized transaction\n     * @param accountId the NEAR account signing the message\n     * @param networkId The targeted network. (ex. default, betanet, etc…)\n     * @returns {Promise<Signature>}\n     */\n    signMessage(message, accountId, networkId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const hash = new Uint8Array(js_sha256_1.default.sha256.array(message));\n            if (!accountId) {\n                throw new Error('InMemorySigner requires provided account id');\n            }\n            const keyPair = yield this.keyStore.getKey(networkId, accountId);\n            if (keyPair === null) {\n                throw new Error(`Key for ${accountId} not found in ${networkId}`);\n            }\n            return keyPair.sign(hash);\n        });\n    }\n    toString() {\n        return `InMemorySigner(${this.keyStore})`;\n    }\n}\nexports.InMemorySigner = InMemorySigner;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3NpZ25lci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxjQUFjO0FBQ3ZDLG9DQUFvQyxtQkFBTyxDQUFDLCtEQUFXO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLGdGQUFrQjtBQUM3Qyw4QkFBOEIsbUJBQU8sQ0FBQyxnSEFBa0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVcsZUFBZSxVQUFVO0FBQy9FO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi9zaWduZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5NZW1vcnlTaWduZXIgPSBleHBvcnRzLlNpZ25lciA9IHZvaWQgMDtcbmNvbnN0IGpzX3NoYTI1Nl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqcy1zaGEyNTZcIikpO1xuY29uc3Qga2V5X3BhaXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2tleV9wYWlyXCIpO1xuY29uc3QgaW5fbWVtb3J5X2tleV9zdG9yZV8xID0gcmVxdWlyZShcIi4va2V5X3N0b3Jlcy9pbl9tZW1vcnlfa2V5X3N0b3JlXCIpO1xuLyoqXG4gKiBHZW5lcmFsIHNpZ25pbmcgaW50ZXJmYWNlLCBjYW4gYmUgdXNlZCBmb3IgaW4gbWVtb3J5IHNpZ25pbmcsIFJQQyBzaW5naW5nLCBleHRlcm5hbCB3YWxsZXQsIEhTTSwgZXRjLlxuICovXG5jbGFzcyBTaWduZXIge1xufVxuZXhwb3J0cy5TaWduZXIgPSBTaWduZXI7XG4vKipcbiAqIFNpZ25zIHVzaW5nIGluIG1lbW9yeSBrZXkgc3RvcmUuXG4gKi9cbmNsYXNzIEluTWVtb3J5U2lnbmVyIGV4dGVuZHMgU2lnbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihrZXlTdG9yZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleVN0b3JlID0ga2V5U3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaW5nbGUgYWNjb3VudCBTaWduZXIgaW5zdGFuY2Ugd2l0aCBhY2NvdW50LCBuZXR3b3JrIGFuZCBrZXlQYWlyIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogSW50ZW5kZWQgdG8gYmUgdXNlZnVsIGZvciB0ZW1wb3Jhcnkga2V5cyAoZS5nLiBjbGFpbWluZyBhIExpbmtkcm9wKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0byBhc3NpZ24gdGhlIGtleSBwYWlyIHRvXG4gICAgICogQHBhcmFtIGtleVBhaXIgVGhlIGtleVBhaXIgdG8gdXNlIGZvciBzaWduaW5nXG4gICAgICovXG4gICAgc3RhdGljIGZyb21LZXlQYWlyKG5ldHdvcmtJZCwgYWNjb3VudElkLCBrZXlQYWlyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlTdG9yZSA9IG5ldyBpbl9tZW1vcnlfa2V5X3N0b3JlXzEuSW5NZW1vcnlLZXlTdG9yZSgpO1xuICAgICAgICAgICAgeWllbGQga2V5U3RvcmUuc2V0S2V5KG5ldHdvcmtJZCwgYWNjb3VudElkLCBrZXlQYWlyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5NZW1vcnlTaWduZXIoa2V5U3RvcmUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHB1YmxpYyBrZXkgZm9yIHRoZSBhY2NvdW50IGdpdmVuXG4gICAgICogQHBhcmFtIGFjY291bnRJZCBUaGUgTkVBUiBhY2NvdW50IHRvIGFzc2lnbiBhIHB1YmxpYyBrZXkgdG9cbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIFRoZSB0YXJnZXRlZCBuZXR3b3JrLiAoZXguIGRlZmF1bHQsIGJldGFuZXQsIGV0Y+KApilcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQdWJsaWNLZXk+fVxuICAgICAqL1xuICAgIGNyZWF0ZUtleShhY2NvdW50SWQsIG5ldHdvcmtJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5UGFpciA9IGtleV9wYWlyXzEuS2V5UGFpci5mcm9tUmFuZG9tKCdlZDI1NTE5Jyk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmtleVN0b3JlLnNldEtleShuZXR3b3JrSWQsIGFjY291bnRJZCwga2V5UGFpcik7XG4gICAgICAgICAgICByZXR1cm4ga2V5UGFpci5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGV4aXN0aW5nIHB1YmxpYyBrZXkgZm9yIGEgZ2l2ZW4gYWNjb3VudFxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCB0byBhc3NpZ24gYSBwdWJsaWMga2V5IHRvXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCBUaGUgdGFyZ2V0ZWQgbmV0d29yay4gKGV4LiBkZWZhdWx0LCBiZXRhbmV0LCBldGPigKYpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UHVibGljS2V5Pn0gUmV0dXJucyB0aGUgcHVibGljIGtleSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldFB1YmxpY0tleShhY2NvdW50SWQsIG5ldHdvcmtJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5UGFpciA9IHlpZWxkIHRoaXMua2V5U3RvcmUuZ2V0S2V5KG5ldHdvcmtJZCwgYWNjb3VudElkKTtcbiAgICAgICAgICAgIGlmIChrZXlQYWlyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5UGFpci5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIEEgbWVzc2FnZSB0byBiZSBzaWduZWQsIHR5cGljYWxseSBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYWNjb3VudElkIHRoZSBORUFSIGFjY291bnQgc2lnbmluZyB0aGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgVGhlIHRhcmdldGVkIG5ldHdvcmsuIChleC4gZGVmYXVsdCwgYmV0YW5ldCwgZXRj4oCmKVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25hdHVyZT59XG4gICAgICovXG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSwgYWNjb3VudElkLCBuZXR3b3JrSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBuZXcgVWludDhBcnJheShqc19zaGEyNTZfMS5kZWZhdWx0LnNoYTI1Ni5hcnJheShtZXNzYWdlKSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5NZW1vcnlTaWduZXIgcmVxdWlyZXMgcHJvdmlkZWQgYWNjb3VudCBpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5UGFpciA9IHlpZWxkIHRoaXMua2V5U3RvcmUuZ2V0S2V5KG5ldHdvcmtJZCwgYWNjb3VudElkKTtcbiAgICAgICAgICAgIGlmIChrZXlQYWlyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgZm9yICR7YWNjb3VudElkfSBub3QgZm91bmQgaW4gJHtuZXR3b3JrSWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5UGFpci5zaWduKGhhc2gpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgSW5NZW1vcnlTaWduZXIoJHt0aGlzLmtleVN0b3JlfSlgO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5NZW1vcnlTaWduZXIgPSBJbk1lbW9yeVNpZ25lcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/transaction.js":
/*!*****************************************************!*\
  !*** ./node_modules/near-api-js/lib/transaction.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.signTransaction = exports.createTransaction = exports.SCHEMA = exports.Action = exports.SignedTransaction = exports.Transaction = exports.Signature = exports.deleteAccount = exports.deleteKey = exports.addKey = exports.stake = exports.transfer = exports.functionCall = exports.stringifyJsonOrBytes = exports.deployContract = exports.createAccount = exports.DeleteAccount = exports.DeleteKey = exports.AddKey = exports.Stake = exports.Transfer = exports.FunctionCall = exports.DeployContract = exports.CreateAccount = exports.IAction = exports.functionCallAccessKey = exports.fullAccessKey = exports.AccessKey = exports.AccessKeyPermission = exports.FullAccessPermission = exports.FunctionCallPermission = void 0;\nconst js_sha256_1 = __importDefault(__webpack_require__(/*! js-sha256 */ \"(ssr)/./node_modules/js-sha256/src/sha256.js\"));\nconst enums_1 = __webpack_require__(/*! ./utils/enums */ \"(ssr)/./node_modules/near-api-js/lib/utils/enums.js\");\nconst borsh_1 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\nconst key_pair_1 = __webpack_require__(/*! ./utils/key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\nclass FunctionCallPermission extends enums_1.Assignable {\n}\nexports.FunctionCallPermission = FunctionCallPermission;\nclass FullAccessPermission extends enums_1.Assignable {\n}\nexports.FullAccessPermission = FullAccessPermission;\nclass AccessKeyPermission extends enums_1.Enum {\n}\nexports.AccessKeyPermission = AccessKeyPermission;\nclass AccessKey extends enums_1.Assignable {\n}\nexports.AccessKey = AccessKey;\nfunction fullAccessKey() {\n    return new AccessKey({ permission: new AccessKeyPermission({ fullAccess: new FullAccessPermission({}) }) });\n}\nexports.fullAccessKey = fullAccessKey;\nfunction functionCallAccessKey(receiverId, methodNames, allowance) {\n    return new AccessKey({ permission: new AccessKeyPermission({ functionCall: new FunctionCallPermission({ receiverId, allowance, methodNames }) }) });\n}\nexports.functionCallAccessKey = functionCallAccessKey;\nclass IAction extends enums_1.Assignable {\n}\nexports.IAction = IAction;\nclass CreateAccount extends IAction {\n}\nexports.CreateAccount = CreateAccount;\nclass DeployContract extends IAction {\n}\nexports.DeployContract = DeployContract;\nclass FunctionCall extends IAction {\n}\nexports.FunctionCall = FunctionCall;\nclass Transfer extends IAction {\n}\nexports.Transfer = Transfer;\nclass Stake extends IAction {\n}\nexports.Stake = Stake;\nclass AddKey extends IAction {\n}\nexports.AddKey = AddKey;\nclass DeleteKey extends IAction {\n}\nexports.DeleteKey = DeleteKey;\nclass DeleteAccount extends IAction {\n}\nexports.DeleteAccount = DeleteAccount;\nfunction createAccount() {\n    return new Action({ createAccount: new CreateAccount({}) });\n}\nexports.createAccount = createAccount;\nfunction deployContract(code) {\n    return new Action({ deployContract: new DeployContract({ code }) });\n}\nexports.deployContract = deployContract;\nfunction stringifyJsonOrBytes(args) {\n    const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;\n    const serializedArgs = isUint8Array ? args : Buffer.from(JSON.stringify(args));\n    return serializedArgs;\n}\nexports.stringifyJsonOrBytes = stringifyJsonOrBytes;\n/**\n * Constructs {@link Action} instance representing contract method call.\n *\n * @param methodName the name of the method to call\n * @param args arguments to pass to method. Can be either plain JS object which gets serialized as JSON automatically\n *  or `Uint8Array` instance which represents bytes passed as is.\n * @param gas max amount of gas that method call can use\n * @param deposit amount of NEAR (in yoctoNEAR) to send together with the call\n * @param stringify Convert input arguments into bytes array.\n * @param jsContract  Is contract from JS SDK, skips stringification of arguments.\n */\nfunction functionCall(methodName, args, gas, deposit, stringify = stringifyJsonOrBytes, jsContract = false) {\n    if (jsContract) {\n        return new Action({ functionCall: new FunctionCall({ methodName, args, gas, deposit }) });\n    }\n    return new Action({ functionCall: new FunctionCall({ methodName, args: stringify(args), gas, deposit }) });\n}\nexports.functionCall = functionCall;\nfunction transfer(deposit) {\n    return new Action({ transfer: new Transfer({ deposit }) });\n}\nexports.transfer = transfer;\nfunction stake(stake, publicKey) {\n    return new Action({ stake: new Stake({ stake, publicKey }) });\n}\nexports.stake = stake;\nfunction addKey(publicKey, accessKey) {\n    return new Action({ addKey: new AddKey({ publicKey, accessKey }) });\n}\nexports.addKey = addKey;\nfunction deleteKey(publicKey) {\n    return new Action({ deleteKey: new DeleteKey({ publicKey }) });\n}\nexports.deleteKey = deleteKey;\nfunction deleteAccount(beneficiaryId) {\n    return new Action({ deleteAccount: new DeleteAccount({ beneficiaryId }) });\n}\nexports.deleteAccount = deleteAccount;\nclass Signature extends enums_1.Assignable {\n}\nexports.Signature = Signature;\nclass Transaction extends enums_1.Assignable {\n    encode() {\n        return (0, borsh_1.serialize)(exports.SCHEMA, this);\n    }\n    static decode(bytes) {\n        return (0, borsh_1.deserialize)(exports.SCHEMA, Transaction, bytes);\n    }\n}\nexports.Transaction = Transaction;\nclass SignedTransaction extends enums_1.Assignable {\n    encode() {\n        return (0, borsh_1.serialize)(exports.SCHEMA, this);\n    }\n    static decode(bytes) {\n        return (0, borsh_1.deserialize)(exports.SCHEMA, SignedTransaction, bytes);\n    }\n}\nexports.SignedTransaction = SignedTransaction;\n/**\n * Contains a list of the valid transaction Actions available with this API\n * @see {@link https://nomicon.io/RuntimeSpec/Actions.html | Actions Spec}\n */\nclass Action extends enums_1.Enum {\n}\nexports.Action = Action;\nexports.SCHEMA = new Map([\n    [Signature, { kind: 'struct', fields: [\n                ['keyType', 'u8'],\n                ['data', [64]]\n            ] }],\n    [SignedTransaction, { kind: 'struct', fields: [\n                ['transaction', Transaction],\n                ['signature', Signature]\n            ] }],\n    [Transaction, { kind: 'struct', fields: [\n                ['signerId', 'string'],\n                ['publicKey', key_pair_1.PublicKey],\n                ['nonce', 'u64'],\n                ['receiverId', 'string'],\n                ['blockHash', [32]],\n                ['actions', [Action]]\n            ] }],\n    [key_pair_1.PublicKey, { kind: 'struct', fields: [\n                ['keyType', 'u8'],\n                ['data', [32]]\n            ] }],\n    [AccessKey, { kind: 'struct', fields: [\n                ['nonce', 'u64'],\n                ['permission', AccessKeyPermission],\n            ] }],\n    [AccessKeyPermission, { kind: 'enum', field: 'enum', values: [\n                ['functionCall', FunctionCallPermission],\n                ['fullAccess', FullAccessPermission],\n            ] }],\n    [FunctionCallPermission, { kind: 'struct', fields: [\n                ['allowance', { kind: 'option', type: 'u128' }],\n                ['receiverId', 'string'],\n                ['methodNames', ['string']],\n            ] }],\n    [FullAccessPermission, { kind: 'struct', fields: [] }],\n    [Action, { kind: 'enum', field: 'enum', values: [\n                ['createAccount', CreateAccount],\n                ['deployContract', DeployContract],\n                ['functionCall', FunctionCall],\n                ['transfer', Transfer],\n                ['stake', Stake],\n                ['addKey', AddKey],\n                ['deleteKey', DeleteKey],\n                ['deleteAccount', DeleteAccount],\n            ] }],\n    [CreateAccount, { kind: 'struct', fields: [] }],\n    [DeployContract, { kind: 'struct', fields: [\n                ['code', ['u8']]\n            ] }],\n    [FunctionCall, { kind: 'struct', fields: [\n                ['methodName', 'string'],\n                ['args', ['u8']],\n                ['gas', 'u64'],\n                ['deposit', 'u128']\n            ] }],\n    [Transfer, { kind: 'struct', fields: [\n                ['deposit', 'u128']\n            ] }],\n    [Stake, { kind: 'struct', fields: [\n                ['stake', 'u128'],\n                ['publicKey', key_pair_1.PublicKey]\n            ] }],\n    [AddKey, { kind: 'struct', fields: [\n                ['publicKey', key_pair_1.PublicKey],\n                ['accessKey', AccessKey]\n            ] }],\n    [DeleteKey, { kind: 'struct', fields: [\n                ['publicKey', key_pair_1.PublicKey]\n            ] }],\n    [DeleteAccount, { kind: 'struct', fields: [\n                ['beneficiaryId', 'string']\n            ] }],\n]);\nfunction createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {\n    return new Transaction({ signerId, publicKey, nonce, receiverId, actions, blockHash });\n}\nexports.createTransaction = createTransaction;\n/**\n * Signs a given transaction from an account with given keys, applied to the given network\n * @param transaction The Transaction object to sign\n * @param signer The {Signer} object that assists with signing keys\n * @param accountId The human-readable NEAR account name\n * @param networkId The targeted network. (ex. default, betanet, etc…)\n */\nfunction signTransactionObject(transaction, signer, accountId, networkId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const message = (0, borsh_1.serialize)(exports.SCHEMA, transaction);\n        const hash = new Uint8Array(js_sha256_1.default.sha256.array(message));\n        const signature = yield signer.signMessage(message, accountId, networkId);\n        const signedTx = new SignedTransaction({\n            transaction,\n            signature: new Signature({ keyType: transaction.publicKey.keyType, data: signature.signature })\n        });\n        return [hash, signedTx];\n    });\n}\nfunction signTransaction(...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (args[0].constructor === Transaction) {\n            const [transaction, signer, accountId, networkId] = args;\n            return signTransactionObject(transaction, signer, accountId, networkId);\n        }\n        else {\n            const [receiverId, nonce, actions, blockHash, signer, accountId, networkId] = args;\n            const publicKey = yield signer.getPublicKey(accountId, networkId);\n            const transaction = createTransaction(accountId, publicKey, receiverId, nonce, actions, blockHash);\n            return signTransactionObject(transaction, signer, accountId, networkId);\n        }\n    });\n}\nexports.signTransaction = signTransaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxvQkFBb0IsR0FBRyw0QkFBNEIsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGVBQWUsR0FBRyw2QkFBNkIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEI7QUFDdHNCLG9DQUFvQyxtQkFBTyxDQUFDLCtEQUFXO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFlO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFPO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFrQjtBQUM3QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLHNDQUFzQyx1Q0FBdUMsR0FBRyxHQUFHO0FBQzlHO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsMkJBQTJCLHNDQUFzQywyQ0FBMkMsb0NBQW9DLEdBQUcsR0FBRztBQUN0SjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHdCQUF3QixtQ0FBbUMsR0FBRztBQUM5RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHdCQUF3QixxQ0FBcUMsTUFBTSxHQUFHO0FBQ3RFO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUMsZ0NBQWdDLEdBQUc7QUFDaEc7QUFDQSx3QkFBd0IsaUNBQWlDLGlEQUFpRCxHQUFHO0FBQzdHO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esd0JBQXdCLHlCQUF5QixTQUFTLEdBQUc7QUFDN0Q7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSx3QkFBd0IsbUJBQW1CLGtCQUFrQixHQUFHO0FBQ2hFO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCLHFCQUFxQixzQkFBc0IsR0FBRztBQUN0RTtBQUNBLGNBQWM7QUFDZDtBQUNBLHdCQUF3QiwyQkFBMkIsV0FBVyxHQUFHO0FBQ2pFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esd0JBQXdCLG1DQUFtQyxlQUFlLEdBQUc7QUFDN0U7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsK0JBQStCO0FBQy9CLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBLGVBQWU7QUFDZiw2QkFBNkIsNEJBQTRCO0FBQ3pELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHNCQUFzQiw0QkFBNEI7QUFDbEQsdUJBQXVCO0FBQ3ZCO0FBQ0EsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCO0FBQ0EsZUFBZTtBQUNmLHNCQUFzQjtBQUN0QjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsNkJBQTZCLDREQUE0RDtBQUN6RjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtRUFBbUU7QUFDMUcsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIvdHJhbnNhY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2lnblRyYW5zYWN0aW9uID0gZXhwb3J0cy5jcmVhdGVUcmFuc2FjdGlvbiA9IGV4cG9ydHMuU0NIRU1BID0gZXhwb3J0cy5BY3Rpb24gPSBleHBvcnRzLlNpZ25lZFRyYW5zYWN0aW9uID0gZXhwb3J0cy5UcmFuc2FjdGlvbiA9IGV4cG9ydHMuU2lnbmF0dXJlID0gZXhwb3J0cy5kZWxldGVBY2NvdW50ID0gZXhwb3J0cy5kZWxldGVLZXkgPSBleHBvcnRzLmFkZEtleSA9IGV4cG9ydHMuc3Rha2UgPSBleHBvcnRzLnRyYW5zZmVyID0gZXhwb3J0cy5mdW5jdGlvbkNhbGwgPSBleHBvcnRzLnN0cmluZ2lmeUpzb25PckJ5dGVzID0gZXhwb3J0cy5kZXBsb3lDb250cmFjdCA9IGV4cG9ydHMuY3JlYXRlQWNjb3VudCA9IGV4cG9ydHMuRGVsZXRlQWNjb3VudCA9IGV4cG9ydHMuRGVsZXRlS2V5ID0gZXhwb3J0cy5BZGRLZXkgPSBleHBvcnRzLlN0YWtlID0gZXhwb3J0cy5UcmFuc2ZlciA9IGV4cG9ydHMuRnVuY3Rpb25DYWxsID0gZXhwb3J0cy5EZXBsb3lDb250cmFjdCA9IGV4cG9ydHMuQ3JlYXRlQWNjb3VudCA9IGV4cG9ydHMuSUFjdGlvbiA9IGV4cG9ydHMuZnVuY3Rpb25DYWxsQWNjZXNzS2V5ID0gZXhwb3J0cy5mdWxsQWNjZXNzS2V5ID0gZXhwb3J0cy5BY2Nlc3NLZXkgPSBleHBvcnRzLkFjY2Vzc0tleVBlcm1pc3Npb24gPSBleHBvcnRzLkZ1bGxBY2Nlc3NQZXJtaXNzaW9uID0gZXhwb3J0cy5GdW5jdGlvbkNhbGxQZXJtaXNzaW9uID0gdm9pZCAwO1xuY29uc3QganNfc2hhMjU2XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzLXNoYTI1NlwiKSk7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZW51bXNcIik7XG5jb25zdCBib3JzaF8xID0gcmVxdWlyZShcImJvcnNoXCIpO1xuY29uc3Qga2V5X3BhaXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2tleV9wYWlyXCIpO1xuY2xhc3MgRnVuY3Rpb25DYWxsUGVybWlzc2lvbiBleHRlbmRzIGVudW1zXzEuQXNzaWduYWJsZSB7XG59XG5leHBvcnRzLkZ1bmN0aW9uQ2FsbFBlcm1pc3Npb24gPSBGdW5jdGlvbkNhbGxQZXJtaXNzaW9uO1xuY2xhc3MgRnVsbEFjY2Vzc1Blcm1pc3Npb24gZXh0ZW5kcyBlbnVtc18xLkFzc2lnbmFibGUge1xufVxuZXhwb3J0cy5GdWxsQWNjZXNzUGVybWlzc2lvbiA9IEZ1bGxBY2Nlc3NQZXJtaXNzaW9uO1xuY2xhc3MgQWNjZXNzS2V5UGVybWlzc2lvbiBleHRlbmRzIGVudW1zXzEuRW51bSB7XG59XG5leHBvcnRzLkFjY2Vzc0tleVBlcm1pc3Npb24gPSBBY2Nlc3NLZXlQZXJtaXNzaW9uO1xuY2xhc3MgQWNjZXNzS2V5IGV4dGVuZHMgZW51bXNfMS5Bc3NpZ25hYmxlIHtcbn1cbmV4cG9ydHMuQWNjZXNzS2V5ID0gQWNjZXNzS2V5O1xuZnVuY3Rpb24gZnVsbEFjY2Vzc0tleSgpIHtcbiAgICByZXR1cm4gbmV3IEFjY2Vzc0tleSh7IHBlcm1pc3Npb246IG5ldyBBY2Nlc3NLZXlQZXJtaXNzaW9uKHsgZnVsbEFjY2VzczogbmV3IEZ1bGxBY2Nlc3NQZXJtaXNzaW9uKHt9KSB9KSB9KTtcbn1cbmV4cG9ydHMuZnVsbEFjY2Vzc0tleSA9IGZ1bGxBY2Nlc3NLZXk7XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxBY2Nlc3NLZXkocmVjZWl2ZXJJZCwgbWV0aG9kTmFtZXMsIGFsbG93YW5jZSkge1xuICAgIHJldHVybiBuZXcgQWNjZXNzS2V5KHsgcGVybWlzc2lvbjogbmV3IEFjY2Vzc0tleVBlcm1pc3Npb24oeyBmdW5jdGlvbkNhbGw6IG5ldyBGdW5jdGlvbkNhbGxQZXJtaXNzaW9uKHsgcmVjZWl2ZXJJZCwgYWxsb3dhbmNlLCBtZXRob2ROYW1lcyB9KSB9KSB9KTtcbn1cbmV4cG9ydHMuZnVuY3Rpb25DYWxsQWNjZXNzS2V5ID0gZnVuY3Rpb25DYWxsQWNjZXNzS2V5O1xuY2xhc3MgSUFjdGlvbiBleHRlbmRzIGVudW1zXzEuQXNzaWduYWJsZSB7XG59XG5leHBvcnRzLklBY3Rpb24gPSBJQWN0aW9uO1xuY2xhc3MgQ3JlYXRlQWNjb3VudCBleHRlbmRzIElBY3Rpb24ge1xufVxuZXhwb3J0cy5DcmVhdGVBY2NvdW50ID0gQ3JlYXRlQWNjb3VudDtcbmNsYXNzIERlcGxveUNvbnRyYWN0IGV4dGVuZHMgSUFjdGlvbiB7XG59XG5leHBvcnRzLkRlcGxveUNvbnRyYWN0ID0gRGVwbG95Q29udHJhY3Q7XG5jbGFzcyBGdW5jdGlvbkNhbGwgZXh0ZW5kcyBJQWN0aW9uIHtcbn1cbmV4cG9ydHMuRnVuY3Rpb25DYWxsID0gRnVuY3Rpb25DYWxsO1xuY2xhc3MgVHJhbnNmZXIgZXh0ZW5kcyBJQWN0aW9uIHtcbn1cbmV4cG9ydHMuVHJhbnNmZXIgPSBUcmFuc2ZlcjtcbmNsYXNzIFN0YWtlIGV4dGVuZHMgSUFjdGlvbiB7XG59XG5leHBvcnRzLlN0YWtlID0gU3Rha2U7XG5jbGFzcyBBZGRLZXkgZXh0ZW5kcyBJQWN0aW9uIHtcbn1cbmV4cG9ydHMuQWRkS2V5ID0gQWRkS2V5O1xuY2xhc3MgRGVsZXRlS2V5IGV4dGVuZHMgSUFjdGlvbiB7XG59XG5leHBvcnRzLkRlbGV0ZUtleSA9IERlbGV0ZUtleTtcbmNsYXNzIERlbGV0ZUFjY291bnQgZXh0ZW5kcyBJQWN0aW9uIHtcbn1cbmV4cG9ydHMuRGVsZXRlQWNjb3VudCA9IERlbGV0ZUFjY291bnQ7XG5mdW5jdGlvbiBjcmVhdGVBY2NvdW50KCkge1xuICAgIHJldHVybiBuZXcgQWN0aW9uKHsgY3JlYXRlQWNjb3VudDogbmV3IENyZWF0ZUFjY291bnQoe30pIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVBY2NvdW50ID0gY3JlYXRlQWNjb3VudDtcbmZ1bmN0aW9uIGRlcGxveUNvbnRyYWN0KGNvZGUpIHtcbiAgICByZXR1cm4gbmV3IEFjdGlvbih7IGRlcGxveUNvbnRyYWN0OiBuZXcgRGVwbG95Q29udHJhY3QoeyBjb2RlIH0pIH0pO1xufVxuZXhwb3J0cy5kZXBsb3lDb250cmFjdCA9IGRlcGxveUNvbnRyYWN0O1xuZnVuY3Rpb24gc3RyaW5naWZ5SnNvbk9yQnl0ZXMoYXJncykge1xuICAgIGNvbnN0IGlzVWludDhBcnJheSA9IGFyZ3MuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGFyZ3MuYnl0ZUxlbmd0aCA9PT0gYXJncy5sZW5ndGg7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFyZ3MgPSBpc1VpbnQ4QXJyYXkgPyBhcmdzIDogQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgIHJldHVybiBzZXJpYWxpemVkQXJncztcbn1cbmV4cG9ydHMuc3RyaW5naWZ5SnNvbk9yQnl0ZXMgPSBzdHJpbmdpZnlKc29uT3JCeXRlcztcbi8qKlxuICogQ29uc3RydWN0cyB7QGxpbmsgQWN0aW9ufSBpbnN0YW5jZSByZXByZXNlbnRpbmcgY29udHJhY3QgbWV0aG9kIGNhbGwuXG4gKlxuICogQHBhcmFtIG1ldGhvZE5hbWUgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBjYWxsXG4gKiBAcGFyYW0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byBtZXRob2QuIENhbiBiZSBlaXRoZXIgcGxhaW4gSlMgb2JqZWN0IHdoaWNoIGdldHMgc2VyaWFsaXplZCBhcyBKU09OIGF1dG9tYXRpY2FsbHlcbiAqICBvciBgVWludDhBcnJheWAgaW5zdGFuY2Ugd2hpY2ggcmVwcmVzZW50cyBieXRlcyBwYXNzZWQgYXMgaXMuXG4gKiBAcGFyYW0gZ2FzIG1heCBhbW91bnQgb2YgZ2FzIHRoYXQgbWV0aG9kIGNhbGwgY2FuIHVzZVxuICogQHBhcmFtIGRlcG9zaXQgYW1vdW50IG9mIE5FQVIgKGluIHlvY3RvTkVBUikgdG8gc2VuZCB0b2dldGhlciB3aXRoIHRoZSBjYWxsXG4gKiBAcGFyYW0gc3RyaW5naWZ5IENvbnZlcnQgaW5wdXQgYXJndW1lbnRzIGludG8gYnl0ZXMgYXJyYXkuXG4gKiBAcGFyYW0ganNDb250cmFjdCAgSXMgY29udHJhY3QgZnJvbSBKUyBTREssIHNraXBzIHN0cmluZ2lmaWNhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbChtZXRob2ROYW1lLCBhcmdzLCBnYXMsIGRlcG9zaXQsIHN0cmluZ2lmeSA9IHN0cmluZ2lmeUpzb25PckJ5dGVzLCBqc0NvbnRyYWN0ID0gZmFsc2UpIHtcbiAgICBpZiAoanNDb250cmFjdCkge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih7IGZ1bmN0aW9uQ2FsbDogbmV3IEZ1bmN0aW9uQ2FsbCh7IG1ldGhvZE5hbWUsIGFyZ3MsIGdhcywgZGVwb3NpdCB9KSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBY3Rpb24oeyBmdW5jdGlvbkNhbGw6IG5ldyBGdW5jdGlvbkNhbGwoeyBtZXRob2ROYW1lLCBhcmdzOiBzdHJpbmdpZnkoYXJncyksIGdhcywgZGVwb3NpdCB9KSB9KTtcbn1cbmV4cG9ydHMuZnVuY3Rpb25DYWxsID0gZnVuY3Rpb25DYWxsO1xuZnVuY3Rpb24gdHJhbnNmZXIoZGVwb3NpdCkge1xuICAgIHJldHVybiBuZXcgQWN0aW9uKHsgdHJhbnNmZXI6IG5ldyBUcmFuc2Zlcih7IGRlcG9zaXQgfSkgfSk7XG59XG5leHBvcnRzLnRyYW5zZmVyID0gdHJhbnNmZXI7XG5mdW5jdGlvbiBzdGFrZShzdGFrZSwgcHVibGljS2V5KSB7XG4gICAgcmV0dXJuIG5ldyBBY3Rpb24oeyBzdGFrZTogbmV3IFN0YWtlKHsgc3Rha2UsIHB1YmxpY0tleSB9KSB9KTtcbn1cbmV4cG9ydHMuc3Rha2UgPSBzdGFrZTtcbmZ1bmN0aW9uIGFkZEtleShwdWJsaWNLZXksIGFjY2Vzc0tleSkge1xuICAgIHJldHVybiBuZXcgQWN0aW9uKHsgYWRkS2V5OiBuZXcgQWRkS2V5KHsgcHVibGljS2V5LCBhY2Nlc3NLZXkgfSkgfSk7XG59XG5leHBvcnRzLmFkZEtleSA9IGFkZEtleTtcbmZ1bmN0aW9uIGRlbGV0ZUtleShwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gbmV3IEFjdGlvbih7IGRlbGV0ZUtleTogbmV3IERlbGV0ZUtleSh7IHB1YmxpY0tleSB9KSB9KTtcbn1cbmV4cG9ydHMuZGVsZXRlS2V5ID0gZGVsZXRlS2V5O1xuZnVuY3Rpb24gZGVsZXRlQWNjb3VudChiZW5lZmljaWFyeUlkKSB7XG4gICAgcmV0dXJuIG5ldyBBY3Rpb24oeyBkZWxldGVBY2NvdW50OiBuZXcgRGVsZXRlQWNjb3VudCh7IGJlbmVmaWNpYXJ5SWQgfSkgfSk7XG59XG5leHBvcnRzLmRlbGV0ZUFjY291bnQgPSBkZWxldGVBY2NvdW50O1xuY2xhc3MgU2lnbmF0dXJlIGV4dGVuZHMgZW51bXNfMS5Bc3NpZ25hYmxlIHtcbn1cbmV4cG9ydHMuU2lnbmF0dXJlID0gU2lnbmF0dXJlO1xuY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBlbnVtc18xLkFzc2lnbmFibGUge1xuICAgIGVuY29kZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBib3JzaF8xLnNlcmlhbGl6ZSkoZXhwb3J0cy5TQ0hFTUEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiAoMCwgYm9yc2hfMS5kZXNlcmlhbGl6ZSkoZXhwb3J0cy5TQ0hFTUEsIFRyYW5zYWN0aW9uLCBieXRlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuY2xhc3MgU2lnbmVkVHJhbnNhY3Rpb24gZXh0ZW5kcyBlbnVtc18xLkFzc2lnbmFibGUge1xuICAgIGVuY29kZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBib3JzaF8xLnNlcmlhbGl6ZSkoZXhwb3J0cy5TQ0hFTUEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiAoMCwgYm9yc2hfMS5kZXNlcmlhbGl6ZSkoZXhwb3J0cy5TQ0hFTUEsIFNpZ25lZFRyYW5zYWN0aW9uLCBieXRlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5TaWduZWRUcmFuc2FjdGlvbiA9IFNpZ25lZFRyYW5zYWN0aW9uO1xuLyoqXG4gKiBDb250YWlucyBhIGxpc3Qgb2YgdGhlIHZhbGlkIHRyYW5zYWN0aW9uIEFjdGlvbnMgYXZhaWxhYmxlIHdpdGggdGhpcyBBUElcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbm9taWNvbi5pby9SdW50aW1lU3BlYy9BY3Rpb25zLmh0bWwgfCBBY3Rpb25zIFNwZWN9XG4gKi9cbmNsYXNzIEFjdGlvbiBleHRlbmRzIGVudW1zXzEuRW51bSB7XG59XG5leHBvcnRzLkFjdGlvbiA9IEFjdGlvbjtcbmV4cG9ydHMuU0NIRU1BID0gbmV3IE1hcChbXG4gICAgW1NpZ25hdHVyZSwgeyBraW5kOiAnc3RydWN0JywgZmllbGRzOiBbXG4gICAgICAgICAgICAgICAgWydrZXlUeXBlJywgJ3U4J10sXG4gICAgICAgICAgICAgICAgWydkYXRhJywgWzY0XV1cbiAgICAgICAgICAgIF0gfV0sXG4gICAgW1NpZ25lZFRyYW5zYWN0aW9uLCB7IGtpbmQ6ICdzdHJ1Y3QnLCBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICBbJ3RyYW5zYWN0aW9uJywgVHJhbnNhY3Rpb25dLFxuICAgICAgICAgICAgICAgIFsnc2lnbmF0dXJlJywgU2lnbmF0dXJlXVxuICAgICAgICAgICAgXSB9XSxcbiAgICBbVHJhbnNhY3Rpb24sIHsga2luZDogJ3N0cnVjdCcsIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIFsnc2lnbmVySWQnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgICAgICAgWydwdWJsaWNLZXknLCBrZXlfcGFpcl8xLlB1YmxpY0tleV0sXG4gICAgICAgICAgICAgICAgWydub25jZScsICd1NjQnXSxcbiAgICAgICAgICAgICAgICBbJ3JlY2VpdmVySWQnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgICAgICAgWydibG9ja0hhc2gnLCBbMzJdXSxcbiAgICAgICAgICAgICAgICBbJ2FjdGlvbnMnLCBbQWN0aW9uXV1cbiAgICAgICAgICAgIF0gfV0sXG4gICAgW2tleV9wYWlyXzEuUHVibGljS2V5LCB7IGtpbmQ6ICdzdHJ1Y3QnLCBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICBbJ2tleVR5cGUnLCAndTgnXSxcbiAgICAgICAgICAgICAgICBbJ2RhdGEnLCBbMzJdXVxuICAgICAgICAgICAgXSB9XSxcbiAgICBbQWNjZXNzS2V5LCB7IGtpbmQ6ICdzdHJ1Y3QnLCBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICBbJ25vbmNlJywgJ3U2NCddLFxuICAgICAgICAgICAgICAgIFsncGVybWlzc2lvbicsIEFjY2Vzc0tleVBlcm1pc3Npb25dLFxuICAgICAgICAgICAgXSB9XSxcbiAgICBbQWNjZXNzS2V5UGVybWlzc2lvbiwgeyBraW5kOiAnZW51bScsIGZpZWxkOiAnZW51bScsIHZhbHVlczogW1xuICAgICAgICAgICAgICAgIFsnZnVuY3Rpb25DYWxsJywgRnVuY3Rpb25DYWxsUGVybWlzc2lvbl0sXG4gICAgICAgICAgICAgICAgWydmdWxsQWNjZXNzJywgRnVsbEFjY2Vzc1Blcm1pc3Npb25dLFxuICAgICAgICAgICAgXSB9XSxcbiAgICBbRnVuY3Rpb25DYWxsUGVybWlzc2lvbiwgeyBraW5kOiAnc3RydWN0JywgZmllbGRzOiBbXG4gICAgICAgICAgICAgICAgWydhbGxvd2FuY2UnLCB7IGtpbmQ6ICdvcHRpb24nLCB0eXBlOiAndTEyOCcgfV0sXG4gICAgICAgICAgICAgICAgWydyZWNlaXZlcklkJywgJ3N0cmluZyddLFxuICAgICAgICAgICAgICAgIFsnbWV0aG9kTmFtZXMnLCBbJ3N0cmluZyddXSxcbiAgICAgICAgICAgIF0gfV0sXG4gICAgW0Z1bGxBY2Nlc3NQZXJtaXNzaW9uLCB7IGtpbmQ6ICdzdHJ1Y3QnLCBmaWVsZHM6IFtdIH1dLFxuICAgIFtBY3Rpb24sIHsga2luZDogJ2VudW0nLCBmaWVsZDogJ2VudW0nLCB2YWx1ZXM6IFtcbiAgICAgICAgICAgICAgICBbJ2NyZWF0ZUFjY291bnQnLCBDcmVhdGVBY2NvdW50XSxcbiAgICAgICAgICAgICAgICBbJ2RlcGxveUNvbnRyYWN0JywgRGVwbG95Q29udHJhY3RdLFxuICAgICAgICAgICAgICAgIFsnZnVuY3Rpb25DYWxsJywgRnVuY3Rpb25DYWxsXSxcbiAgICAgICAgICAgICAgICBbJ3RyYW5zZmVyJywgVHJhbnNmZXJdLFxuICAgICAgICAgICAgICAgIFsnc3Rha2UnLCBTdGFrZV0sXG4gICAgICAgICAgICAgICAgWydhZGRLZXknLCBBZGRLZXldLFxuICAgICAgICAgICAgICAgIFsnZGVsZXRlS2V5JywgRGVsZXRlS2V5XSxcbiAgICAgICAgICAgICAgICBbJ2RlbGV0ZUFjY291bnQnLCBEZWxldGVBY2NvdW50XSxcbiAgICAgICAgICAgIF0gfV0sXG4gICAgW0NyZWF0ZUFjY291bnQsIHsga2luZDogJ3N0cnVjdCcsIGZpZWxkczogW10gfV0sXG4gICAgW0RlcGxveUNvbnRyYWN0LCB7IGtpbmQ6ICdzdHJ1Y3QnLCBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICBbJ2NvZGUnLCBbJ3U4J11dXG4gICAgICAgICAgICBdIH1dLFxuICAgIFtGdW5jdGlvbkNhbGwsIHsga2luZDogJ3N0cnVjdCcsIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIFsnbWV0aG9kTmFtZScsICdzdHJpbmcnXSxcbiAgICAgICAgICAgICAgICBbJ2FyZ3MnLCBbJ3U4J11dLFxuICAgICAgICAgICAgICAgIFsnZ2FzJywgJ3U2NCddLFxuICAgICAgICAgICAgICAgIFsnZGVwb3NpdCcsICd1MTI4J11cbiAgICAgICAgICAgIF0gfV0sXG4gICAgW1RyYW5zZmVyLCB7IGtpbmQ6ICdzdHJ1Y3QnLCBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICBbJ2RlcG9zaXQnLCAndTEyOCddXG4gICAgICAgICAgICBdIH1dLFxuICAgIFtTdGFrZSwgeyBraW5kOiAnc3RydWN0JywgZmllbGRzOiBbXG4gICAgICAgICAgICAgICAgWydzdGFrZScsICd1MTI4J10sXG4gICAgICAgICAgICAgICAgWydwdWJsaWNLZXknLCBrZXlfcGFpcl8xLlB1YmxpY0tleV1cbiAgICAgICAgICAgIF0gfV0sXG4gICAgW0FkZEtleSwgeyBraW5kOiAnc3RydWN0JywgZmllbGRzOiBbXG4gICAgICAgICAgICAgICAgWydwdWJsaWNLZXknLCBrZXlfcGFpcl8xLlB1YmxpY0tleV0sXG4gICAgICAgICAgICAgICAgWydhY2Nlc3NLZXknLCBBY2Nlc3NLZXldXG4gICAgICAgICAgICBdIH1dLFxuICAgIFtEZWxldGVLZXksIHsga2luZDogJ3N0cnVjdCcsIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIFsncHVibGljS2V5Jywga2V5X3BhaXJfMS5QdWJsaWNLZXldXG4gICAgICAgICAgICBdIH1dLFxuICAgIFtEZWxldGVBY2NvdW50LCB7IGtpbmQ6ICdzdHJ1Y3QnLCBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICBbJ2JlbmVmaWNpYXJ5SWQnLCAnc3RyaW5nJ11cbiAgICAgICAgICAgIF0gfV0sXG5dKTtcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uKHNpZ25lcklkLCBwdWJsaWNLZXksIHJlY2VpdmVySWQsIG5vbmNlLCBhY3Rpb25zLCBibG9ja0hhc2gpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHsgc2lnbmVySWQsIHB1YmxpY0tleSwgbm9uY2UsIHJlY2VpdmVySWQsIGFjdGlvbnMsIGJsb2NrSGFzaCB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlVHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbjtcbi8qKlxuICogU2lnbnMgYSBnaXZlbiB0cmFuc2FjdGlvbiBmcm9tIGFuIGFjY291bnQgd2l0aCBnaXZlbiBrZXlzLCBhcHBsaWVkIHRvIHRoZSBnaXZlbiBuZXR3b3JrXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIFRyYW5zYWN0aW9uIG9iamVjdCB0byBzaWduXG4gKiBAcGFyYW0gc2lnbmVyIFRoZSB7U2lnbmVyfSBvYmplY3QgdGhhdCBhc3Npc3RzIHdpdGggc2lnbmluZyBrZXlzXG4gKiBAcGFyYW0gYWNjb3VudElkIFRoZSBodW1hbi1yZWFkYWJsZSBORUFSIGFjY291bnQgbmFtZVxuICogQHBhcmFtIG5ldHdvcmtJZCBUaGUgdGFyZ2V0ZWQgbmV0d29yay4gKGV4LiBkZWZhdWx0LCBiZXRhbmV0LCBldGPigKYpXG4gKi9cbmZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbk9iamVjdCh0cmFuc2FjdGlvbiwgc2lnbmVyLCBhY2NvdW50SWQsIG5ldHdvcmtJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoMCwgYm9yc2hfMS5zZXJpYWxpemUpKGV4cG9ydHMuU0NIRU1BLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZXcgVWludDhBcnJheShqc19zaGEyNTZfMS5kZWZhdWx0LnNoYTI1Ni5hcnJheShtZXNzYWdlKSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHlpZWxkIHNpZ25lci5zaWduTWVzc2FnZShtZXNzYWdlLCBhY2NvdW50SWQsIG5ldHdvcmtJZCk7XG4gICAgICAgIGNvbnN0IHNpZ25lZFR4ID0gbmV3IFNpZ25lZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBuZXcgU2lnbmF0dXJlKHsga2V5VHlwZTogdHJhbnNhY3Rpb24ucHVibGljS2V5LmtleVR5cGUsIGRhdGE6IHNpZ25hdHVyZS5zaWduYXR1cmUgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbaGFzaCwgc2lnbmVkVHhdO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoYXJnc1swXS5jb25zdHJ1Y3RvciA9PT0gVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IFt0cmFuc2FjdGlvbiwgc2lnbmVyLCBhY2NvdW50SWQsIG5ldHdvcmtJZF0gPSBhcmdzO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ25UcmFuc2FjdGlvbk9iamVjdCh0cmFuc2FjdGlvbiwgc2lnbmVyLCBhY2NvdW50SWQsIG5ldHdvcmtJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBbcmVjZWl2ZXJJZCwgbm9uY2UsIGFjdGlvbnMsIGJsb2NrSGFzaCwgc2lnbmVyLCBhY2NvdW50SWQsIG5ldHdvcmtJZF0gPSBhcmdzO1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0geWllbGQgc2lnbmVyLmdldFB1YmxpY0tleShhY2NvdW50SWQsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uKGFjY291bnRJZCwgcHVibGljS2V5LCByZWNlaXZlcklkLCBub25jZSwgYWN0aW9ucywgYmxvY2tIYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBzaWduVHJhbnNhY3Rpb25PYmplY3QodHJhbnNhY3Rpb24sIHNpZ25lciwgYWNjb3VudElkLCBuZXR3b3JrSWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNpZ25UcmFuc2FjdGlvbiA9IHNpZ25UcmFuc2FjdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/enums.js":
/*!*****************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/enums.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Assignable = exports.Enum = void 0;\n/** @hidden @module */\nclass Enum {\n    constructor(properties) {\n        if (Object.keys(properties).length !== 1) {\n            throw new Error('Enum can only take single value');\n        }\n        Object.keys(properties).map((key) => {\n            this[key] = properties[key];\n            this.enum = key;\n        });\n    }\n}\nexports.Enum = Enum;\nclass Assignable {\n    constructor(properties) {\n        Object.keys(properties).map((key) => {\n            this[key] = properties[key];\n        });\n    }\n}\nexports.Assignable = Assignable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2VudW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2VudW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3NpZ25hYmxlID0gZXhwb3J0cy5FbnVtID0gdm9pZCAwO1xuLyoqIEBoaWRkZW4gQG1vZHVsZSAqL1xuY2xhc3MgRW51bSB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudW0gY2FuIG9ubHkgdGFrZSBzaW5nbGUgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpc1trZXldID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgICAgdGhpcy5lbnVtID0ga2V5O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkVudW0gPSBFbnVtO1xuY2xhc3MgQXNzaWduYWJsZSB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpc1trZXldID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFzc2lnbmFibGUgPSBBc3NpZ25hYmxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/enums.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.logWarning = exports.ErrorContext = exports.TypedError = exports.ArgumentTypeError = exports.PositionalArgsError = void 0;\nclass PositionalArgsError extends Error {\n    constructor() {\n        super('Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }');\n    }\n}\nexports.PositionalArgsError = PositionalArgsError;\nclass ArgumentTypeError extends Error {\n    constructor(argName, argType, argValue) {\n        super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);\n    }\n}\nexports.ArgumentTypeError = ArgumentTypeError;\nclass TypedError extends Error {\n    constructor(message, type, context) {\n        super(message);\n        this.type = type || 'UntypedError';\n        this.context = context;\n    }\n}\nexports.TypedError = TypedError;\nclass ErrorContext {\n    constructor(transactionHash) {\n        this.transactionHash = transactionHash;\n    }\n}\nexports.ErrorContext = ErrorContext;\nfunction logWarning(...args) {\n    if (!process.env['NEAR_NO_LOGS']) {\n        console.warn(...args);\n    }\n}\nexports.logWarning = logWarning;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkI7QUFDeEg7QUFDQTtBQUNBLHNGQUFzRiwwQ0FBMEM7QUFDaEk7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMEJBQTBCLFNBQVMsT0FBTyxRQUFRLHVCQUF1Qix5QkFBeUI7QUFDbEc7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi91dGlscy9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvZ1dhcm5pbmcgPSBleHBvcnRzLkVycm9yQ29udGV4dCA9IGV4cG9ydHMuVHlwZWRFcnJvciA9IGV4cG9ydHMuQXJndW1lbnRUeXBlRXJyb3IgPSBleHBvcnRzLlBvc2l0aW9uYWxBcmdzRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBQb3NpdGlvbmFsQXJnc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ29udHJhY3QgbWV0aG9kIGNhbGxzIGV4cGVjdCBuYW1lZCBhcmd1bWVudHMgd3JhcHBlZCBpbiBvYmplY3QsIGUuZy4geyBhcmdOYW1lMTogYXJnVmFsdWUxLCBhcmdOYW1lMjogYXJnVmFsdWUyIH0nKTtcbiAgICB9XG59XG5leHBvcnRzLlBvc2l0aW9uYWxBcmdzRXJyb3IgPSBQb3NpdGlvbmFsQXJnc0Vycm9yO1xuY2xhc3MgQXJndW1lbnRUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYXJnTmFtZSwgYXJnVHlwZSwgYXJnVmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYEV4cGVjdGVkICR7YXJnVHlwZX0gZm9yICcke2FyZ05hbWV9JyBhcmd1bWVudCwgYnV0IGdvdCAnJHtKU09OLnN0cmluZ2lmeShhcmdWYWx1ZSl9J2ApO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJndW1lbnRUeXBlRXJyb3IgPSBBcmd1bWVudFR5cGVFcnJvcjtcbmNsYXNzIFR5cGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSwgY29udGV4dCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCAnVW50eXBlZEVycm9yJztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG59XG5leHBvcnRzLlR5cGVkRXJyb3IgPSBUeXBlZEVycm9yO1xuY2xhc3MgRXJyb3JDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbkhhc2ggPSB0cmFuc2FjdGlvbkhhc2g7XG4gICAgfVxufVxuZXhwb3J0cy5FcnJvckNvbnRleHQgPSBFcnJvckNvbnRleHQ7XG5mdW5jdGlvbiBsb2dXYXJuaW5nKC4uLmFyZ3MpIHtcbiAgICBpZiAoIXByb2Nlc3MuZW52WydORUFSX05PX0xPR1MnXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oLi4uYXJncyk7XG4gICAgfVxufVxuZXhwb3J0cy5sb2dXYXJuaW5nID0gbG9nV2FybmluZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/exponential-backoff.js":
/*!*******************************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/exponential-backoff.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction exponentialBackoff(startWaitTime, retryNumber, waitBackoff, getResult) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // TODO: jitter?\n        let waitTime = startWaitTime;\n        for (let i = 0; i < retryNumber; i++) {\n            const result = yield getResult();\n            if (result) {\n                return result;\n            }\n            yield sleep(waitTime);\n            waitTime *= waitBackoff;\n        }\n        return null;\n    });\n}\nexports[\"default\"] = exponentialBackoff;\n// Sleep given number of millis.\nfunction sleep(millis) {\n    return new Promise(resolve => setTimeout(resolve, millis));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2V4cG9uZW50aWFsLWJhY2tvZmYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2V4cG9uZW50aWFsLWJhY2tvZmYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGV4cG9uZW50aWFsQmFja29mZihzdGFydFdhaXRUaW1lLCByZXRyeU51bWJlciwgd2FpdEJhY2tvZmYsIGdldFJlc3VsdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIFRPRE86IGppdHRlcj9cbiAgICAgICAgbGV0IHdhaXRUaW1lID0gc3RhcnRXYWl0VGltZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyeU51bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBnZXRSZXN1bHQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgc2xlZXAod2FpdFRpbWUpO1xuICAgICAgICAgICAgd2FpdFRpbWUgKj0gd2FpdEJhY2tvZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvbmVudGlhbEJhY2tvZmY7XG4vLyBTbGVlcCBnaXZlbiBudW1iZXIgb2YgbWlsbGlzLlxuZnVuY3Rpb24gc2xlZXAobWlsbGlzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtaWxsaXMpKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/exponential-backoff.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/format.js":
/*!******************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/format.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseNearAmount = exports.formatNearAmount = exports.NEAR_NOMINATION = exports.NEAR_NOMINATION_EXP = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\n/**\n * Exponent for calculating how many indivisible units are there in one NEAR. See {@link NEAR_NOMINATION}.\n */\nexports.NEAR_NOMINATION_EXP = 24;\n/**\n * Number of indivisible units in one NEAR. Derived from {@link NEAR_NOMINATION_EXP}.\n */\nexports.NEAR_NOMINATION = new bn_js_1.default('10', 10).pow(new bn_js_1.default(exports.NEAR_NOMINATION_EXP, 10));\n// Pre-calculate offests used for rounding to different number of digits\nconst ROUNDING_OFFSETS = [];\nconst BN10 = new bn_js_1.default(10);\nfor (let i = 0, offset = new bn_js_1.default(5); i < exports.NEAR_NOMINATION_EXP; i++, offset = offset.mul(BN10)) {\n    ROUNDING_OFFSETS[i] = offset;\n}\n/**\n * Convert account balance value from internal indivisible units to NEAR. 1 NEAR is defined by {@link NEAR_NOMINATION}.\n * Effectively this divides given amount by {@link NEAR_NOMINATION}.\n *\n * @param balance decimal string representing balance in smallest non-divisible NEAR units (as specified by {@link NEAR_NOMINATION})\n * @param fracDigits number of fractional digits to preserve in formatted string. Balance is rounded to match given number of digits.\n * @returns Value in Ⓝ\n */\nfunction formatNearAmount(balance, fracDigits = exports.NEAR_NOMINATION_EXP) {\n    const balanceBN = new bn_js_1.default(balance, 10);\n    if (fracDigits !== exports.NEAR_NOMINATION_EXP) {\n        // Adjust balance for rounding at given number of digits\n        const roundingExp = exports.NEAR_NOMINATION_EXP - fracDigits - 1;\n        if (roundingExp > 0) {\n            balanceBN.iadd(ROUNDING_OFFSETS[roundingExp]);\n        }\n    }\n    balance = balanceBN.toString();\n    const wholeStr = balance.substring(0, balance.length - exports.NEAR_NOMINATION_EXP) || '0';\n    const fractionStr = balance.substring(balance.length - exports.NEAR_NOMINATION_EXP)\n        .padStart(exports.NEAR_NOMINATION_EXP, '0').substring(0, fracDigits);\n    return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);\n}\nexports.formatNearAmount = formatNearAmount;\n/**\n * Convert human readable NEAR amount to internal indivisible units.\n * Effectively this multiplies given amount by {@link NEAR_NOMINATION}.\n *\n * @param amt decimal string (potentially fractional) denominated in NEAR.\n * @returns The parsed yoctoⓃ amount or null if no amount was passed in\n */\nfunction parseNearAmount(amt) {\n    if (!amt) {\n        return null;\n    }\n    amt = cleanupAmount(amt);\n    const split = amt.split('.');\n    const wholePart = split[0];\n    const fracPart = split[1] || '';\n    if (split.length > 2 || fracPart.length > exports.NEAR_NOMINATION_EXP) {\n        throw new Error(`Cannot parse '${amt}' as NEAR amount`);\n    }\n    return trimLeadingZeroes(wholePart + fracPart.padEnd(exports.NEAR_NOMINATION_EXP, '0'));\n}\nexports.parseNearAmount = parseNearAmount;\n/**\n * Removes commas from the input\n * @param amount A value or amount that may contain commas\n * @returns string The cleaned value\n */\nfunction cleanupAmount(amount) {\n    return amount.replace(/,/g, '').trim();\n}\n/**\n * Removes .000… from an input\n * @param value A value that may contain trailing zeroes in the decimals place\n * @returns string The value without the trailing zeros\n */\nfunction trimTrailingZeroes(value) {\n    return value.replace(/\\.?0*$/, '');\n}\n/**\n * Removes leading zeroes from an input\n * @param value A value that may contain leading zeroes\n * @returns string The value without the leading zeroes\n */\nfunction trimLeadingZeroes(value) {\n    value = value.replace(/^0+/, '');\n    if (value === '') {\n        return '0';\n    }\n    return value;\n}\n/**\n * Returns a human-readable value with commas\n * @param value A value that may not contain commas\n * @returns string A value with commas\n */\nfunction formatWithCommas(value) {\n    const pattern = /(-?\\d+)(\\d{3})/;\n    while (pattern.test(value)) {\n        value = value.replace(pattern, '$1,$2');\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2Zvcm1hdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLDJCQUEyQjtBQUMxRyxnQ0FBZ0MsbUJBQU8sQ0FBQyxtREFBTztBQUMvQztBQUNBLG1GQUFtRixzQkFBc0I7QUFDekc7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwwREFBMEQsMEJBQTBCO0FBQ3BGO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHNCQUFzQjtBQUN0SCw2Q0FBNkMsc0JBQXNCO0FBQ25FO0FBQ0EsNkdBQTZHLHNCQUFzQjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkIsR0FBRyxZQUFZO0FBQzNFO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2Zvcm1hdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VOZWFyQW1vdW50ID0gZXhwb3J0cy5mb3JtYXROZWFyQW1vdW50ID0gZXhwb3J0cy5ORUFSX05PTUlOQVRJT04gPSBleHBvcnRzLk5FQVJfTk9NSU5BVElPTl9FWFAgPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG4vKipcbiAqIEV4cG9uZW50IGZvciBjYWxjdWxhdGluZyBob3cgbWFueSBpbmRpdmlzaWJsZSB1bml0cyBhcmUgdGhlcmUgaW4gb25lIE5FQVIuIFNlZSB7QGxpbmsgTkVBUl9OT01JTkFUSU9OfS5cbiAqL1xuZXhwb3J0cy5ORUFSX05PTUlOQVRJT05fRVhQID0gMjQ7XG4vKipcbiAqIE51bWJlciBvZiBpbmRpdmlzaWJsZSB1bml0cyBpbiBvbmUgTkVBUi4gRGVyaXZlZCBmcm9tIHtAbGluayBORUFSX05PTUlOQVRJT05fRVhQfS5cbiAqL1xuZXhwb3J0cy5ORUFSX05PTUlOQVRJT04gPSBuZXcgYm5fanNfMS5kZWZhdWx0KCcxMCcsIDEwKS5wb3cobmV3IGJuX2pzXzEuZGVmYXVsdChleHBvcnRzLk5FQVJfTk9NSU5BVElPTl9FWFAsIDEwKSk7XG4vLyBQcmUtY2FsY3VsYXRlIG9mZmVzdHMgdXNlZCBmb3Igcm91bmRpbmcgdG8gZGlmZmVyZW50IG51bWJlciBvZiBkaWdpdHNcbmNvbnN0IFJPVU5ESU5HX09GRlNFVFMgPSBbXTtcbmNvbnN0IEJOMTAgPSBuZXcgYm5fanNfMS5kZWZhdWx0KDEwKTtcbmZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSBuZXcgYm5fanNfMS5kZWZhdWx0KDUpOyBpIDwgZXhwb3J0cy5ORUFSX05PTUlOQVRJT05fRVhQOyBpKyssIG9mZnNldCA9IG9mZnNldC5tdWwoQk4xMCkpIHtcbiAgICBST1VORElOR19PRkZTRVRTW2ldID0gb2Zmc2V0O1xufVxuLyoqXG4gKiBDb252ZXJ0IGFjY291bnQgYmFsYW5jZSB2YWx1ZSBmcm9tIGludGVybmFsIGluZGl2aXNpYmxlIHVuaXRzIHRvIE5FQVIuIDEgTkVBUiBpcyBkZWZpbmVkIGJ5IHtAbGluayBORUFSX05PTUlOQVRJT059LlxuICogRWZmZWN0aXZlbHkgdGhpcyBkaXZpZGVzIGdpdmVuIGFtb3VudCBieSB7QGxpbmsgTkVBUl9OT01JTkFUSU9OfS5cbiAqXG4gKiBAcGFyYW0gYmFsYW5jZSBkZWNpbWFsIHN0cmluZyByZXByZXNlbnRpbmcgYmFsYW5jZSBpbiBzbWFsbGVzdCBub24tZGl2aXNpYmxlIE5FQVIgdW5pdHMgKGFzIHNwZWNpZmllZCBieSB7QGxpbmsgTkVBUl9OT01JTkFUSU9OfSlcbiAqIEBwYXJhbSBmcmFjRGlnaXRzIG51bWJlciBvZiBmcmFjdGlvbmFsIGRpZ2l0cyB0byBwcmVzZXJ2ZSBpbiBmb3JtYXR0ZWQgc3RyaW5nLiBCYWxhbmNlIGlzIHJvdW5kZWQgdG8gbWF0Y2ggZ2l2ZW4gbnVtYmVyIG9mIGRpZ2l0cy5cbiAqIEByZXR1cm5zIFZhbHVlIGluIOKTg1xuICovXG5mdW5jdGlvbiBmb3JtYXROZWFyQW1vdW50KGJhbGFuY2UsIGZyYWNEaWdpdHMgPSBleHBvcnRzLk5FQVJfTk9NSU5BVElPTl9FWFApIHtcbiAgICBjb25zdCBiYWxhbmNlQk4gPSBuZXcgYm5fanNfMS5kZWZhdWx0KGJhbGFuY2UsIDEwKTtcbiAgICBpZiAoZnJhY0RpZ2l0cyAhPT0gZXhwb3J0cy5ORUFSX05PTUlOQVRJT05fRVhQKSB7XG4gICAgICAgIC8vIEFkanVzdCBiYWxhbmNlIGZvciByb3VuZGluZyBhdCBnaXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gICAgICAgIGNvbnN0IHJvdW5kaW5nRXhwID0gZXhwb3J0cy5ORUFSX05PTUlOQVRJT05fRVhQIC0gZnJhY0RpZ2l0cyAtIDE7XG4gICAgICAgIGlmIChyb3VuZGluZ0V4cCA+IDApIHtcbiAgICAgICAgICAgIGJhbGFuY2VCTi5pYWRkKFJPVU5ESU5HX09GRlNFVFNbcm91bmRpbmdFeHBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiYWxhbmNlID0gYmFsYW5jZUJOLnRvU3RyaW5nKCk7XG4gICAgY29uc3Qgd2hvbGVTdHIgPSBiYWxhbmNlLnN1YnN0cmluZygwLCBiYWxhbmNlLmxlbmd0aCAtIGV4cG9ydHMuTkVBUl9OT01JTkFUSU9OX0VYUCkgfHwgJzAnO1xuICAgIGNvbnN0IGZyYWN0aW9uU3RyID0gYmFsYW5jZS5zdWJzdHJpbmcoYmFsYW5jZS5sZW5ndGggLSBleHBvcnRzLk5FQVJfTk9NSU5BVElPTl9FWFApXG4gICAgICAgIC5wYWRTdGFydChleHBvcnRzLk5FQVJfTk9NSU5BVElPTl9FWFAsICcwJykuc3Vic3RyaW5nKDAsIGZyYWNEaWdpdHMpO1xuICAgIHJldHVybiB0cmltVHJhaWxpbmdaZXJvZXMoYCR7Zm9ybWF0V2l0aENvbW1hcyh3aG9sZVN0cil9LiR7ZnJhY3Rpb25TdHJ9YCk7XG59XG5leHBvcnRzLmZvcm1hdE5lYXJBbW91bnQgPSBmb3JtYXROZWFyQW1vdW50O1xuLyoqXG4gKiBDb252ZXJ0IGh1bWFuIHJlYWRhYmxlIE5FQVIgYW1vdW50IHRvIGludGVybmFsIGluZGl2aXNpYmxlIHVuaXRzLlxuICogRWZmZWN0aXZlbHkgdGhpcyBtdWx0aXBsaWVzIGdpdmVuIGFtb3VudCBieSB7QGxpbmsgTkVBUl9OT01JTkFUSU9OfS5cbiAqXG4gKiBAcGFyYW0gYW10IGRlY2ltYWwgc3RyaW5nIChwb3RlbnRpYWxseSBmcmFjdGlvbmFsKSBkZW5vbWluYXRlZCBpbiBORUFSLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCB5b2N0b+KTgyBhbW91bnQgb3IgbnVsbCBpZiBubyBhbW91bnQgd2FzIHBhc3NlZCBpblxuICovXG5mdW5jdGlvbiBwYXJzZU5lYXJBbW91bnQoYW10KSB7XG4gICAgaWYgKCFhbXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFtdCA9IGNsZWFudXBBbW91bnQoYW10KTtcbiAgICBjb25zdCBzcGxpdCA9IGFtdC5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHdob2xlUGFydCA9IHNwbGl0WzBdO1xuICAgIGNvbnN0IGZyYWNQYXJ0ID0gc3BsaXRbMV0gfHwgJyc7XG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDIgfHwgZnJhY1BhcnQubGVuZ3RoID4gZXhwb3J0cy5ORUFSX05PTUlOQVRJT05fRVhQKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlICcke2FtdH0nIGFzIE5FQVIgYW1vdW50YCk7XG4gICAgfVxuICAgIHJldHVybiB0cmltTGVhZGluZ1plcm9lcyh3aG9sZVBhcnQgKyBmcmFjUGFydC5wYWRFbmQoZXhwb3J0cy5ORUFSX05PTUlOQVRJT05fRVhQLCAnMCcpKTtcbn1cbmV4cG9ydHMucGFyc2VOZWFyQW1vdW50ID0gcGFyc2VOZWFyQW1vdW50O1xuLyoqXG4gKiBSZW1vdmVzIGNvbW1hcyBmcm9tIHRoZSBpbnB1dFxuICogQHBhcmFtIGFtb3VudCBBIHZhbHVlIG9yIGFtb3VudCB0aGF0IG1heSBjb250YWluIGNvbW1hc1xuICogQHJldHVybnMgc3RyaW5nIFRoZSBjbGVhbmVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNsZWFudXBBbW91bnQoYW1vdW50KSB7XG4gICAgcmV0dXJuIGFtb3VudC5yZXBsYWNlKC8sL2csICcnKS50cmltKCk7XG59XG4vKipcbiAqIFJlbW92ZXMgLjAwMOKApiBmcm9tIGFuIGlucHV0XG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSB0aGF0IG1heSBjb250YWluIHRyYWlsaW5nIHplcm9lcyBpbiB0aGUgZGVjaW1hbHMgcGxhY2VcbiAqIEByZXR1cm5zIHN0cmluZyBUaGUgdmFsdWUgd2l0aG91dCB0aGUgdHJhaWxpbmcgemVyb3NcbiAqL1xuZnVuY3Rpb24gdHJpbVRyYWlsaW5nWmVyb2VzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcLj8wKiQvLCAnJyk7XG59XG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyB6ZXJvZXMgZnJvbSBhbiBpbnB1dFxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBtYXkgY29udGFpbiBsZWFkaW5nIHplcm9lc1xuICogQHJldHVybnMgc3RyaW5nIFRoZSB2YWx1ZSB3aXRob3V0IHRoZSBsZWFkaW5nIHplcm9lc1xuICovXG5mdW5jdGlvbiB0cmltTGVhZGluZ1plcm9lcyh2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXjArLywgJycpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgdmFsdWUgd2l0aCBjb21tYXNcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgbWF5IG5vdCBjb250YWluIGNvbW1hc1xuICogQHJldHVybnMgc3RyaW5nIEEgdmFsdWUgd2l0aCBjb21tYXNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0V2l0aENvbW1hcyh2YWx1ZSkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSAvKC0/XFxkKykoXFxkezN9KS87XG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHBhdHRlcm4sICckMSwkMicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.logWarning = exports.rpc_errors = exports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.format = exports.enums = exports.web = exports.serialize = exports.key_pair = void 0;\nconst key_pair = __importStar(__webpack_require__(/*! ./key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\"));\nexports.key_pair = key_pair;\nconst serialize = __importStar(__webpack_require__(/*! ./serialize */ \"(ssr)/./node_modules/near-api-js/lib/utils/serialize.js\"));\nexports.serialize = serialize;\nconst web = __importStar(__webpack_require__(/*! ./web */ \"(ssr)/./node_modules/near-api-js/lib/utils/web.js\"));\nexports.web = web;\nconst enums = __importStar(__webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/near-api-js/lib/utils/enums.js\"));\nexports.enums = enums;\nconst format = __importStar(__webpack_require__(/*! ./format */ \"(ssr)/./node_modules/near-api-js/lib/utils/format.js\"));\nexports.format = format;\nconst rpc_errors = __importStar(__webpack_require__(/*! ./rpc_errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/rpc_errors.js\"));\nexports.rpc_errors = rpc_errors;\nconst key_pair_1 = __webpack_require__(/*! ./key_pair */ \"(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\");\nObject.defineProperty(exports, \"PublicKey\", ({ enumerable: true, get: function () { return key_pair_1.PublicKey; } }));\nObject.defineProperty(exports, \"KeyPair\", ({ enumerable: true, get: function () { return key_pair_1.KeyPair; } }));\nObject.defineProperty(exports, \"KeyPairEd25519\", ({ enumerable: true, get: function () { return key_pair_1.KeyPairEd25519; } }));\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/errors.js\");\nObject.defineProperty(exports, \"logWarning\", ({ enumerable: true, get: function () { return errors_1.logWarning; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxzQkFBc0IsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxXQUFXLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCO0FBQzVMLDhCQUE4QixtQkFBTyxDQUFDLDBFQUFZO0FBQ2xELGdCQUFnQjtBQUNoQiwrQkFBK0IsbUJBQU8sQ0FBQyw0RUFBYTtBQUNwRCxpQkFBaUI7QUFDakIseUJBQXlCLG1CQUFPLENBQUMsZ0VBQU87QUFDeEMsV0FBVztBQUNYLDJCQUEyQixtQkFBTyxDQUFDLG9FQUFTO0FBQzVDLGFBQWE7QUFDYiw0QkFBNEIsbUJBQU8sQ0FBQyxzRUFBVTtBQUM5QyxjQUFjO0FBQ2QsZ0NBQWdDLG1CQUFPLENBQUMsOEVBQWM7QUFDdEQsa0JBQWtCO0FBQ2xCLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFZO0FBQ3ZDLDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCwyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEgsa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlILGlCQUFpQixtQkFBTyxDQUFDLHNFQUFVO0FBQ25DLDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvZ1dhcm5pbmcgPSBleHBvcnRzLnJwY19lcnJvcnMgPSBleHBvcnRzLktleVBhaXJFZDI1NTE5ID0gZXhwb3J0cy5LZXlQYWlyID0gZXhwb3J0cy5QdWJsaWNLZXkgPSBleHBvcnRzLmZvcm1hdCA9IGV4cG9ydHMuZW51bXMgPSBleHBvcnRzLndlYiA9IGV4cG9ydHMuc2VyaWFsaXplID0gZXhwb3J0cy5rZXlfcGFpciA9IHZvaWQgMDtcbmNvbnN0IGtleV9wYWlyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleV9wYWlyXCIpKTtcbmV4cG9ydHMua2V5X3BhaXIgPSBrZXlfcGFpcjtcbmNvbnN0IHNlcmlhbGl6ZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZXJpYWxpemVcIikpO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5jb25zdCB3ZWIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vd2ViXCIpKTtcbmV4cG9ydHMud2ViID0gd2ViO1xuY29uc3QgZW51bXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZW51bXNcIikpO1xuZXhwb3J0cy5lbnVtcyA9IGVudW1zO1xuY29uc3QgZm9ybWF0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Zvcm1hdFwiKSk7XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbmNvbnN0IHJwY19lcnJvcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcnBjX2Vycm9yc1wiKSk7XG5leHBvcnRzLnJwY19lcnJvcnMgPSBycGNfZXJyb3JzO1xuY29uc3Qga2V5X3BhaXJfMSA9IHJlcXVpcmUoXCIuL2tleV9wYWlyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHVibGljS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlfcGFpcl8xLlB1YmxpY0tleTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleVBhaXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleV9wYWlyXzEuS2V5UGFpcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleVBhaXJFZDI1NTE5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlfcGFpcl8xLktleVBhaXJFZDI1NTE5OyB9IH0pO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2dXYXJuaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5sb2dXYXJuaW5nOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js":
/*!********************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/key_pair.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.KeyType = void 0;\nconst tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ \"(ssr)/./node_modules/tweetnacl/nacl-fast.js\"));\nconst serialize_1 = __webpack_require__(/*! ./serialize */ \"(ssr)/./node_modules/near-api-js/lib/utils/serialize.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/near-api-js/lib/utils/enums.js\");\n/** All supported key types */\nvar KeyType;\n(function (KeyType) {\n    KeyType[KeyType[\"ED25519\"] = 0] = \"ED25519\";\n})(KeyType = exports.KeyType || (exports.KeyType = {}));\nfunction key_type_to_str(keyType) {\n    switch (keyType) {\n        case KeyType.ED25519: return 'ed25519';\n        default: throw new Error(`Unknown key type ${keyType}`);\n    }\n}\nfunction str_to_key_type(keyType) {\n    switch (keyType.toLowerCase()) {\n        case 'ed25519': return KeyType.ED25519;\n        default: throw new Error(`Unknown key type ${keyType}`);\n    }\n}\n/**\n * PublicKey representation that has type and bytes of the key.\n */\nclass PublicKey extends enums_1.Assignable {\n    static from(value) {\n        if (typeof value === 'string') {\n            return PublicKey.fromString(value);\n        }\n        return value;\n    }\n    static fromString(encodedKey) {\n        const parts = encodedKey.split(':');\n        if (parts.length === 1) {\n            return new PublicKey({ keyType: KeyType.ED25519, data: (0, serialize_1.base_decode)(parts[0]) });\n        }\n        else if (parts.length === 2) {\n            return new PublicKey({ keyType: str_to_key_type(parts[0]), data: (0, serialize_1.base_decode)(parts[1]) });\n        }\n        else {\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n        }\n    }\n    toString() {\n        return `${key_type_to_str(this.keyType)}:${(0, serialize_1.base_encode)(this.data)}`;\n    }\n    verify(message, signature) {\n        switch (this.keyType) {\n            case KeyType.ED25519: return tweetnacl_1.default.sign.detached.verify(message, signature, this.data);\n            default: throw new Error(`Unknown key type ${this.keyType}`);\n        }\n    }\n}\nexports.PublicKey = PublicKey;\nclass KeyPair {\n    /**\n     * @param curve Name of elliptical curve, case-insensitive\n     * @returns Random KeyPair based on the curve\n     */\n    static fromRandom(curve) {\n        switch (curve.toUpperCase()) {\n            case 'ED25519': return KeyPairEd25519.fromRandom();\n            default: throw new Error(`Unknown curve ${curve}`);\n        }\n    }\n    static fromString(encodedKey) {\n        const parts = encodedKey.split(':');\n        if (parts.length === 1) {\n            return new KeyPairEd25519(parts[0]);\n        }\n        else if (parts.length === 2) {\n            switch (parts[0].toUpperCase()) {\n                case 'ED25519': return new KeyPairEd25519(parts[1]);\n                default: throw new Error(`Unknown curve: ${parts[0]}`);\n            }\n        }\n        else {\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n        }\n    }\n}\nexports.KeyPair = KeyPair;\n/**\n * This class provides key pair functionality for Ed25519 curve:\n * generating key pairs, encoding key pairs, signing and verifying.\n */\nclass KeyPairEd25519 extends KeyPair {\n    /**\n     * Construct an instance of key pair given a secret key.\n     * It's generally assumed that these are encoded in base58.\n     * @param {string} secretKey\n     */\n    constructor(secretKey) {\n        super();\n        const keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey((0, serialize_1.base_decode)(secretKey));\n        this.publicKey = new PublicKey({ keyType: KeyType.ED25519, data: keyPair.publicKey });\n        this.secretKey = secretKey;\n    }\n    /**\n     * Generate a new random keypair.\n     * @example\n     * const keyRandom = KeyPair.fromRandom();\n     * keyRandom.publicKey\n     * // returns [PUBLIC_KEY]\n     *\n     * keyRandom.secretKey\n     * // returns [SECRET_KEY]\n     */\n    static fromRandom() {\n        const newKeyPair = tweetnacl_1.default.sign.keyPair();\n        return new KeyPairEd25519((0, serialize_1.base_encode)(newKeyPair.secretKey));\n    }\n    sign(message) {\n        const signature = tweetnacl_1.default.sign.detached(message, (0, serialize_1.base_decode)(this.secretKey));\n        return { signature, publicKey: this.publicKey };\n    }\n    verify(message, signature) {\n        return this.publicKey.verify(message, signature);\n    }\n    toString() {\n        return `ed25519:${this.secretKey}`;\n    }\n    getPublicKey() {\n        return this.publicKey;\n    }\n}\nexports.KeyPairEd25519 = KeyPairEd25519;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL2tleV9wYWlyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLGVBQWU7QUFDOUUsb0NBQW9DLG1CQUFPLENBQUMsOERBQVc7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQyxlQUFlLEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3RUFBd0U7QUFDM0c7QUFDQTtBQUNBLG1DQUFtQyxrRkFBa0Y7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QixHQUFHLHdDQUF3QztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1EQUFtRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi91dGlscy9rZXlfcGFpci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2V5UGFpckVkMjU1MTkgPSBleHBvcnRzLktleVBhaXIgPSBleHBvcnRzLlB1YmxpY0tleSA9IGV4cG9ydHMuS2V5VHlwZSA9IHZvaWQgMDtcbmNvbnN0IHR3ZWV0bmFjbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0d2VldG5hY2xcIikpO1xuY29uc3Qgc2VyaWFsaXplXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG4vKiogQWxsIHN1cHBvcnRlZCBrZXkgdHlwZXMgKi9cbnZhciBLZXlUeXBlO1xuKGZ1bmN0aW9uIChLZXlUeXBlKSB7XG4gICAgS2V5VHlwZVtLZXlUeXBlW1wiRUQyNTUxOVwiXSA9IDBdID0gXCJFRDI1NTE5XCI7XG59KShLZXlUeXBlID0gZXhwb3J0cy5LZXlUeXBlIHx8IChleHBvcnRzLktleVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24ga2V5X3R5cGVfdG9fc3RyKGtleVR5cGUpIHtcbiAgICBzd2l0Y2ggKGtleVR5cGUpIHtcbiAgICAgICAgY2FzZSBLZXlUeXBlLkVEMjU1MTk6IHJldHVybiAnZWQyNTUxOSc7XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biBrZXkgdHlwZSAke2tleVR5cGV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyX3RvX2tleV90eXBlKGtleVR5cGUpIHtcbiAgICBzd2l0Y2ggKGtleVR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdlZDI1NTE5JzogcmV0dXJuIEtleVR5cGUuRUQyNTUxOTtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGtleSB0eXBlICR7a2V5VHlwZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIFB1YmxpY0tleSByZXByZXNlbnRhdGlvbiB0aGF0IGhhcyB0eXBlIGFuZCBieXRlcyBvZiB0aGUga2V5LlxuICovXG5jbGFzcyBQdWJsaWNLZXkgZXh0ZW5kcyBlbnVtc18xLkFzc2lnbmFibGUge1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcoZW5jb2RlZEtleSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGVuY29kZWRLZXkuc3BsaXQoJzonKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoeyBrZXlUeXBlOiBLZXlUeXBlLkVEMjU1MTksIGRhdGE6ICgwLCBzZXJpYWxpemVfMS5iYXNlX2RlY29kZSkocGFydHNbMF0pIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoeyBrZXlUeXBlOiBzdHJfdG9fa2V5X3R5cGUocGFydHNbMF0pLCBkYXRhOiAoMCwgc2VyaWFsaXplXzEuYmFzZV9kZWNvZGUpKHBhcnRzWzFdKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGVkIGtleSBmb3JtYXQsIG11c3QgYmUgPGN1cnZlPjo8ZW5jb2RlZCBrZXk+Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHtrZXlfdHlwZV90b19zdHIodGhpcy5rZXlUeXBlKX06JHsoMCwgc2VyaWFsaXplXzEuYmFzZV9lbmNvZGUpKHRoaXMuZGF0YSl9YDtcbiAgICB9XG4gICAgdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2V5VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkVEMjU1MTk6IHJldHVybiB0d2VldG5hY2xfMS5kZWZhdWx0LnNpZ24uZGV0YWNoZWQudmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgdGhpcy5kYXRhKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biBrZXkgdHlwZSAke3RoaXMua2V5VHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHVibGljS2V5ID0gUHVibGljS2V5O1xuY2xhc3MgS2V5UGFpciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGN1cnZlIE5hbWUgb2YgZWxsaXB0aWNhbCBjdXJ2ZSwgY2FzZS1pbnNlbnNpdGl2ZVxuICAgICAqIEByZXR1cm5zIFJhbmRvbSBLZXlQYWlyIGJhc2VkIG9uIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmFuZG9tKGN1cnZlKSB7XG4gICAgICAgIHN3aXRjaCAoY3VydmUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnRUQyNTUxOSc6IHJldHVybiBLZXlQYWlyRWQyNTUxOS5mcm9tUmFuZG9tKCk7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY3VydmUgJHtjdXJ2ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhlbmNvZGVkS2V5KSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gZW5jb2RlZEtleS5zcGxpdCgnOicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleVBhaXJFZDI1NTE5KHBhcnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydHNbMF0udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VEMjU1MTknOiByZXR1cm4gbmV3IEtleVBhaXJFZDI1NTE5KHBhcnRzWzFdKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY3VydmU6ICR7cGFydHNbMF19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RlZCBrZXkgZm9ybWF0LCBtdXN0IGJlIDxjdXJ2ZT46PGVuY29kZWQga2V5PicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5LZXlQYWlyID0gS2V5UGFpcjtcbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBrZXkgcGFpciBmdW5jdGlvbmFsaXR5IGZvciBFZDI1NTE5IGN1cnZlOlxuICogZ2VuZXJhdGluZyBrZXkgcGFpcnMsIGVuY29kaW5nIGtleSBwYWlycywgc2lnbmluZyBhbmQgdmVyaWZ5aW5nLlxuICovXG5jbGFzcyBLZXlQYWlyRWQyNTUxOSBleHRlbmRzIEtleVBhaXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBpbnN0YW5jZSBvZiBrZXkgcGFpciBnaXZlbiBhIHNlY3JldCBrZXkuXG4gICAgICogSXQncyBnZW5lcmFsbHkgYXNzdW1lZCB0aGF0IHRoZXNlIGFyZSBlbmNvZGVkIGluIGJhc2U1OC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0S2V5XG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VjcmV0S2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IGtleVBhaXIgPSB0d2VldG5hY2xfMS5kZWZhdWx0LnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5KCgwLCBzZXJpYWxpemVfMS5iYXNlX2RlY29kZSkoc2VjcmV0S2V5KSk7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gbmV3IFB1YmxpY0tleSh7IGtleVR5cGU6IEtleVR5cGUuRUQyNTUxOSwgZGF0YToga2V5UGFpci5wdWJsaWNLZXkgfSk7XG4gICAgICAgIHRoaXMuc2VjcmV0S2V5ID0gc2VjcmV0S2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIG5ldyByYW5kb20ga2V5cGFpci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGtleVJhbmRvbSA9IEtleVBhaXIuZnJvbVJhbmRvbSgpO1xuICAgICAqIGtleVJhbmRvbS5wdWJsaWNLZXlcbiAgICAgKiAvLyByZXR1cm5zIFtQVUJMSUNfS0VZXVxuICAgICAqXG4gICAgICoga2V5UmFuZG9tLnNlY3JldEtleVxuICAgICAqIC8vIHJldHVybnMgW1NFQ1JFVF9LRVldXG4gICAgICovXG4gICAgc3RhdGljIGZyb21SYW5kb20oKSB7XG4gICAgICAgIGNvbnN0IG5ld0tleVBhaXIgPSB0d2VldG5hY2xfMS5kZWZhdWx0LnNpZ24ua2V5UGFpcigpO1xuICAgICAgICByZXR1cm4gbmV3IEtleVBhaXJFZDI1NTE5KCgwLCBzZXJpYWxpemVfMS5iYXNlX2VuY29kZSkobmV3S2V5UGFpci5zZWNyZXRLZXkpKTtcbiAgICB9XG4gICAgc2lnbihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHR3ZWV0bmFjbF8xLmRlZmF1bHQuc2lnbi5kZXRhY2hlZChtZXNzYWdlLCAoMCwgc2VyaWFsaXplXzEuYmFzZV9kZWNvZGUpKHRoaXMuc2VjcmV0S2V5KSk7XG4gICAgICAgIHJldHVybiB7IHNpZ25hdHVyZSwgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleSB9O1xuICAgIH1cbiAgICB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0tleS52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgZWQyNTUxOToke3RoaXMuc2VjcmV0S2V5fWA7XG4gICAgfVxuICAgIGdldFB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgIH1cbn1cbmV4cG9ydHMuS2V5UGFpckVkMjU1MTkgPSBLZXlQYWlyRWQyNTUxOTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/key_pair.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/rpc_errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/rpc_errors.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatError = exports.parseResultError = exports.parseRpcError = exports.ServerError = void 0;\nconst mustache_1 = __importDefault(__webpack_require__(/*! mustache */ \"(ssr)/./node_modules/mustache/mustache.js\"));\nconst rpc_error_schema_json_1 = __importDefault(__webpack_require__(/*! ../generated/rpc_error_schema.json */ \"(ssr)/./node_modules/near-api-js/lib/generated/rpc_error_schema.json\"));\nconst error_messages_json_1 = __importDefault(__webpack_require__(/*! ../res/error_messages.json */ \"(ssr)/./node_modules/near-api-js/lib/res/error_messages.json\"));\nconst common_index_1 = __webpack_require__(/*! ../common-index */ \"(ssr)/./node_modules/near-api-js/lib/common-index.js\");\nconst errors_1 = __webpack_require__(/*! ../utils/errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/errors.js\");\nconst mustacheHelpers = {\n    formatNear: () => (n, render) => common_index_1.utils.format.formatNearAmount(render(n))\n};\nclass ServerError extends errors_1.TypedError {\n}\nexports.ServerError = ServerError;\nclass ServerTransactionError extends ServerError {\n}\nfunction parseRpcError(errorObj) {\n    const result = {};\n    const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, '');\n    // NOTE: This assumes that all errors extend TypedError\n    const error = new ServerError(formatError(errorClassName, result), errorClassName);\n    Object.assign(error, result);\n    return error;\n}\nexports.parseRpcError = parseRpcError;\nfunction parseResultError(result) {\n    const server_error = parseRpcError(result.status.Failure);\n    const server_tx_error = new ServerTransactionError();\n    Object.assign(server_tx_error, server_error);\n    server_tx_error.type = server_error.type;\n    server_tx_error.message = server_error.message;\n    server_tx_error.transaction_outcome = result.transaction_outcome;\n    return server_tx_error;\n}\nexports.parseResultError = parseResultError;\nfunction formatError(errorClassName, errorData) {\n    if (typeof error_messages_json_1.default[errorClassName] === 'string') {\n        return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));\n    }\n    return JSON.stringify(errorData);\n}\nexports.formatError = formatError;\n/**\n * Walks through defined schema returning error(s) recursively\n * @param errorObj The error to be parsed\n * @param schema A defined schema in JSON mapping to the RPC errors\n * @param result An object used in recursion or called directly\n * @param typeName The human-readable error type name as defined in the JSON mapping\n */\nfunction walkSubtype(errorObj, schema, result, typeName) {\n    let error;\n    let type;\n    let errorTypeName;\n    for (const errorName in schema) {\n        if (isString(errorObj[errorName])) {\n            // Return early if error type is in a schema\n            return errorObj[errorName];\n        }\n        if (isObject(errorObj[errorName])) {\n            error = errorObj[errorName];\n            type = schema[errorName];\n            errorTypeName = errorName;\n        }\n        else if (isObject(errorObj.kind) && isObject(errorObj.kind[errorName])) {\n            error = errorObj.kind[errorName];\n            type = schema[errorName];\n            errorTypeName = errorName;\n        }\n        else {\n            continue;\n        }\n    }\n    if (error && type) {\n        for (const prop of Object.keys(type.props)) {\n            result[prop] = error[prop];\n        }\n        return walkSubtype(error, schema, result, errorTypeName);\n    }\n    else {\n        // TODO: is this the right thing to do?\n        result.kind = errorObj;\n        return typeName;\n    }\n}\n/**\n * Helper function determining if the argument is an object\n * @param n Value to check\n */\nfunction isObject(n) {\n    return Object.prototype.toString.call(n) === '[object Object]';\n}\n/**\n * Helper function determining if the argument is a string\n * @param n Value to check\n */\nfunction isString(n) {\n    return Object.prototype.toString.call(n) === '[object String]';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL3JwY19lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUI7QUFDNUYsbUNBQW1DLG1CQUFPLENBQUMsMkRBQVU7QUFDckQsZ0RBQWdELG1CQUFPLENBQUMsZ0hBQW9DO0FBQzVGLDhDQUE4QyxtQkFBTyxDQUFDLGdHQUE0QjtBQUNsRix1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsNkVBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxzSEFBc0g7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi91dGlscy9ycGNfZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGV4cG9ydHMucGFyc2VSZXN1bHRFcnJvciA9IGV4cG9ydHMucGFyc2VScGNFcnJvciA9IGV4cG9ydHMuU2VydmVyRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBtdXN0YWNoZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtdXN0YWNoZVwiKSk7XG5jb25zdCBycGNfZXJyb3Jfc2NoZW1hX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZ2VuZXJhdGVkL3JwY19lcnJvcl9zY2hlbWEuanNvblwiKSk7XG5jb25zdCBlcnJvcl9tZXNzYWdlc19qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3Jlcy9lcnJvcl9tZXNzYWdlcy5qc29uXCIpKTtcbmNvbnN0IGNvbW1vbl9pbmRleF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi1pbmRleFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2Vycm9yc1wiKTtcbmNvbnN0IG11c3RhY2hlSGVscGVycyA9IHtcbiAgICBmb3JtYXROZWFyOiAoKSA9PiAobiwgcmVuZGVyKSA9PiBjb21tb25faW5kZXhfMS51dGlscy5mb3JtYXQuZm9ybWF0TmVhckFtb3VudChyZW5kZXIobikpXG59O1xuY2xhc3MgU2VydmVyRXJyb3IgZXh0ZW5kcyBlcnJvcnNfMS5UeXBlZEVycm9yIHtcbn1cbmV4cG9ydHMuU2VydmVyRXJyb3IgPSBTZXJ2ZXJFcnJvcjtcbmNsYXNzIFNlcnZlclRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XG59XG5mdW5jdGlvbiBwYXJzZVJwY0Vycm9yKGVycm9yT2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgZXJyb3JDbGFzc05hbWUgPSB3YWxrU3VidHlwZShlcnJvck9iaiwgcnBjX2Vycm9yX3NjaGVtYV9qc29uXzEuZGVmYXVsdC5zY2hlbWEsIHJlc3VsdCwgJycpO1xuICAgIC8vIE5PVEU6IFRoaXMgYXNzdW1lcyB0aGF0IGFsbCBlcnJvcnMgZXh0ZW5kIFR5cGVkRXJyb3JcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTZXJ2ZXJFcnJvcihmb3JtYXRFcnJvcihlcnJvckNsYXNzTmFtZSwgcmVzdWx0KSwgZXJyb3JDbGFzc05hbWUpO1xuICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIHJlc3VsdCk7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0cy5wYXJzZVJwY0Vycm9yID0gcGFyc2VScGNFcnJvcjtcbmZ1bmN0aW9uIHBhcnNlUmVzdWx0RXJyb3IocmVzdWx0KSB7XG4gICAgY29uc3Qgc2VydmVyX2Vycm9yID0gcGFyc2VScGNFcnJvcihyZXN1bHQuc3RhdHVzLkZhaWx1cmUpO1xuICAgIGNvbnN0IHNlcnZlcl90eF9lcnJvciA9IG5ldyBTZXJ2ZXJUcmFuc2FjdGlvbkVycm9yKCk7XG4gICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJfdHhfZXJyb3IsIHNlcnZlcl9lcnJvcik7XG4gICAgc2VydmVyX3R4X2Vycm9yLnR5cGUgPSBzZXJ2ZXJfZXJyb3IudHlwZTtcbiAgICBzZXJ2ZXJfdHhfZXJyb3IubWVzc2FnZSA9IHNlcnZlcl9lcnJvci5tZXNzYWdlO1xuICAgIHNlcnZlcl90eF9lcnJvci50cmFuc2FjdGlvbl9vdXRjb21lID0gcmVzdWx0LnRyYW5zYWN0aW9uX291dGNvbWU7XG4gICAgcmV0dXJuIHNlcnZlcl90eF9lcnJvcjtcbn1cbmV4cG9ydHMucGFyc2VSZXN1bHRFcnJvciA9IHBhcnNlUmVzdWx0RXJyb3I7XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvckNsYXNzTmFtZSwgZXJyb3JEYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvcl9tZXNzYWdlc19qc29uXzEuZGVmYXVsdFtlcnJvckNsYXNzTmFtZV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtdXN0YWNoZV8xLmRlZmF1bHQucmVuZGVyKGVycm9yX21lc3NhZ2VzX2pzb25fMS5kZWZhdWx0W2Vycm9yQ2xhc3NOYW1lXSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlcnJvckRhdGEpLCBtdXN0YWNoZUhlbHBlcnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yRGF0YSk7XG59XG5leHBvcnRzLmZvcm1hdEVycm9yID0gZm9ybWF0RXJyb3I7XG4vKipcbiAqIFdhbGtzIHRocm91Z2ggZGVmaW5lZCBzY2hlbWEgcmV0dXJuaW5nIGVycm9yKHMpIHJlY3Vyc2l2ZWx5XG4gKiBAcGFyYW0gZXJyb3JPYmogVGhlIGVycm9yIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHNjaGVtYSBBIGRlZmluZWQgc2NoZW1hIGluIEpTT04gbWFwcGluZyB0byB0aGUgUlBDIGVycm9yc1xuICogQHBhcmFtIHJlc3VsdCBBbiBvYmplY3QgdXNlZCBpbiByZWN1cnNpb24gb3IgY2FsbGVkIGRpcmVjdGx5XG4gKiBAcGFyYW0gdHlwZU5hbWUgVGhlIGh1bWFuLXJlYWRhYmxlIGVycm9yIHR5cGUgbmFtZSBhcyBkZWZpbmVkIGluIHRoZSBKU09OIG1hcHBpbmdcbiAqL1xuZnVuY3Rpb24gd2Fsa1N1YnR5cGUoZXJyb3JPYmosIHNjaGVtYSwgcmVzdWx0LCB0eXBlTmFtZSkge1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgZXJyb3JUeXBlTmFtZTtcbiAgICBmb3IgKGNvbnN0IGVycm9yTmFtZSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGVycm9yT2JqW2Vycm9yTmFtZV0pKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgZXJyb3IgdHlwZSBpcyBpbiBhIHNjaGVtYVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqW2Vycm9yTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0KGVycm9yT2JqW2Vycm9yTmFtZV0pKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yT2JqW2Vycm9yTmFtZV07XG4gICAgICAgICAgICB0eXBlID0gc2NoZW1hW2Vycm9yTmFtZV07XG4gICAgICAgICAgICBlcnJvclR5cGVOYW1lID0gZXJyb3JOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGVycm9yT2JqLmtpbmQpICYmIGlzT2JqZWN0KGVycm9yT2JqLmtpbmRbZXJyb3JOYW1lXSkpIHtcbiAgICAgICAgICAgIGVycm9yID0gZXJyb3JPYmoua2luZFtlcnJvck5hbWVdO1xuICAgICAgICAgICAgdHlwZSA9IHNjaGVtYVtlcnJvck5hbWVdO1xuICAgICAgICAgICAgZXJyb3JUeXBlTmFtZSA9IGVycm9yTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvciAmJiB0eXBlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyh0eXBlLnByb3BzKSkge1xuICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gZXJyb3JbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhbGtTdWJ0eXBlKGVycm9yLCBzY2hlbWEsIHJlc3VsdCwgZXJyb3JUeXBlTmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIHRoZSByaWdodCB0aGluZyB0byBkbz9cbiAgICAgICAgcmVzdWx0LmtpbmQgPSBlcnJvck9iajtcbiAgICAgICAgcmV0dXJuIHR5cGVOYW1lO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGRldGVybWluaW5nIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIEBwYXJhbSBuIFZhbHVlIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG4pIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4pID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGRldGVybWluaW5nIGlmIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZ1xuICogQHBhcmFtIG4gVmFsdWUgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcobikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/rpc_errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/serialize.js":
/*!*********************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/serialize.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.deserialize = exports.serialize = exports.base_decode = exports.base_encode = void 0;\nvar borsh_1 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\nObject.defineProperty(exports, \"base_encode\", ({ enumerable: true, get: function () { return borsh_1.baseEncode; } }));\nObject.defineProperty(exports, \"base_decode\", ({ enumerable: true, get: function () { return borsh_1.baseDecode; } }));\nObject.defineProperty(exports, \"serialize\", ({ enumerable: true, get: function () { return borsh_1.serialize; } }));\nObject.defineProperty(exports, \"deserialize\", ({ enumerable: true, get: function () { return borsh_1.deserialize; } }));\nObject.defineProperty(exports, \"BorshError\", ({ enumerable: true, get: function () { return borsh_1.BorshError; } }));\nObject.defineProperty(exports, \"BinaryWriter\", ({ enumerable: true, get: function () { return borsh_1.BinaryWriter; } }));\nObject.defineProperty(exports, \"BinaryReader\", ({ enumerable: true, get: function () { return borsh_1.BinaryReader; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL3NlcmlhbGl6ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDdEosY0FBYyxtQkFBTyxDQUFDLHNEQUFPO0FBQzdCLCtDQUE4QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNwSCwrQ0FBOEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDcEgsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pILCtDQUE4QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNySCw4Q0FBNkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbkgsZ0RBQStDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3ZILGdEQUErQyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2ZheWVoYWxsL2V0aGdsb2JhbC11bml0ZS1kZWZpL25lYXItZXNjcm93LXNyYy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL3NlcmlhbGl6ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmluYXJ5UmVhZGVyID0gZXhwb3J0cy5CaW5hcnlXcml0ZXIgPSBleHBvcnRzLkJvcnNoRXJyb3IgPSBleHBvcnRzLmRlc2VyaWFsaXplID0gZXhwb3J0cy5zZXJpYWxpemUgPSBleHBvcnRzLmJhc2VfZGVjb2RlID0gZXhwb3J0cy5iYXNlX2VuY29kZSA9IHZvaWQgMDtcbnZhciBib3JzaF8xID0gcmVxdWlyZShcImJvcnNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmFzZV9lbmNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvcnNoXzEuYmFzZUVuY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJhc2VfZGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib3JzaF8xLmJhc2VEZWNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXJpYWxpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvcnNoXzEuc2VyaWFsaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVzZXJpYWxpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvcnNoXzEuZGVzZXJpYWxpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCb3JzaEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib3JzaF8xLkJvcnNoRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaW5hcnlXcml0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvcnNoXzEuQmluYXJ5V3JpdGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmluYXJ5UmVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib3JzaF8xLkJpbmFyeVJlYWRlcjsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/serialize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/setup-node-fetch.js":
/*!****************************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/setup-node-fetch.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst node_fetch_1 = __importDefault(__webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.mjs\"));\nconst http_1 = __importDefault(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nconst httpAgent = new http_1.default.Agent({ keepAlive: true });\nconst httpsAgent = new https_1.default.Agent({ keepAlive: true });\nfunction agent(_parsedURL) {\n    if (_parsedURL.protocol === 'http:') {\n        return httpAgent;\n    }\n    else {\n        return httpsAgent;\n    }\n}\nfunction default_1(resource, init) {\n    return (0, node_fetch_1.default)(resource, Object.assign({ agent: agent(new URL(resource.toString())) }, init));\n}\nexports[\"default\"] = default_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL3NldHVwLW5vZGUtZmV0Y2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQ0FBcUMsbUJBQU8sQ0FBQyxpRUFBWTtBQUN6RCwrQkFBK0IsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxvQkFBTztBQUMvQyw2Q0FBNkMsaUJBQWlCO0FBQzlELCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDRDQUE0QztBQUMzRztBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvZmF5ZWhhbGwvZXRoZ2xvYmFsLXVuaXRlLWRlZmkvbmVhci1lc2Nyb3ctc3JjL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZWFyLWFwaS1qcy9saWIvdXRpbHMvc2V0dXAtbm9kZS1mZXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG5vZGVfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZS1mZXRjaFwiKSk7XG5jb25zdCBodHRwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cHNcIikpO1xuY29uc3QgaHR0cEFnZW50ID0gbmV3IGh0dHBfMS5kZWZhdWx0LkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pO1xuY29uc3QgaHR0cHNBZ2VudCA9IG5ldyBodHRwc18xLmRlZmF1bHQuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSk7XG5mdW5jdGlvbiBhZ2VudChfcGFyc2VkVVJMKSB7XG4gICAgaWYgKF9wYXJzZWRVUkwucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgcmV0dXJuIGh0dHBBZ2VudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBodHRwc0FnZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZmF1bHRfMShyZXNvdXJjZSwgaW5pdCkge1xuICAgIHJldHVybiAoMCwgbm9kZV9mZXRjaF8xLmRlZmF1bHQpKHJlc291cmNlLCBPYmplY3QuYXNzaWduKHsgYWdlbnQ6IGFnZW50KG5ldyBVUkwocmVzb3VyY2UudG9TdHJpbmcoKSkpIH0sIGluaXQpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/setup-node-fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/utils/web.js":
/*!***************************************************!*\
  !*** ./node_modules/near-api-js/lib/utils/web.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchJson = void 0;\nconst http_errors_1 = __importDefault(__webpack_require__(/*! http-errors */ \"(ssr)/./node_modules/http-errors/index.js\"));\nconst exponential_backoff_1 = __importDefault(__webpack_require__(/*! ./exponential-backoff */ \"(ssr)/./node_modules/near-api-js/lib/utils/exponential-backoff.js\"));\nconst providers_1 = __webpack_require__(/*! ../providers */ \"(ssr)/./node_modules/near-api-js/lib/providers/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/near-api-js/lib/utils/errors.js\");\nconst START_WAIT_TIME_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst RETRY_NUMBER = 10;\nfunction fetchJson(connectionInfoOrUrl, json) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connectionInfo = { url: null };\n        if (typeof (connectionInfoOrUrl) === 'string') {\n            connectionInfo.url = connectionInfoOrUrl;\n        }\n        else {\n            connectionInfo = connectionInfoOrUrl;\n        }\n        const response = yield (0, exponential_backoff_1.default)(START_WAIT_TIME_MS, RETRY_NUMBER, BACKOFF_MULTIPLIER, () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield fetch(connectionInfo.url, {\n                    method: json ? 'POST' : 'GET',\n                    body: json ? json : undefined,\n                    headers: Object.assign(Object.assign({}, connectionInfo.headers), { 'Content-Type': 'application/json' })\n                });\n                if (!response.ok) {\n                    if (response.status === 503) {\n                        (0, errors_1.logWarning)(`Retrying HTTP request for ${connectionInfo.url} as it's not available now`);\n                        return null;\n                    }\n                    throw (0, http_errors_1.default)(response.status, yield response.text());\n                }\n                return response;\n            }\n            catch (error) {\n                if (error.toString().includes('FetchError') || error.toString().includes('Failed to fetch')) {\n                    (0, errors_1.logWarning)(`Retrying HTTP request for ${connectionInfo.url} because of error: ${error}`);\n                    return null;\n                }\n                throw error;\n            }\n        }));\n        if (!response) {\n            throw new providers_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${connectionInfo.url}.`, 'RetriesExceeded');\n        }\n        return yield response.json();\n    });\n}\nexports.fetchJson = fetchJson;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3V0aWxzL3dlYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsc0NBQXNDLG1CQUFPLENBQUMsOERBQWE7QUFDM0QsOENBQThDLG1CQUFPLENBQUMsZ0dBQXVCO0FBQzdFLG9CQUFvQixtQkFBTyxDQUFDLDZFQUFjO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw2QkFBNkIsb0NBQW9DO0FBQzVILGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOEVBQThFLG9CQUFvQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLG9CQUFvQixvQkFBb0IsTUFBTTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlEQUF5RCxjQUFjLGVBQWUsbUJBQW1CO0FBQ3pHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi91dGlscy93ZWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmV0Y2hKc29uID0gdm9pZCAwO1xuY29uc3QgaHR0cF9lcnJvcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cC1lcnJvcnNcIikpO1xuY29uc3QgZXhwb25lbnRpYWxfYmFja29mZl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2V4cG9uZW50aWFsLWJhY2tvZmZcIikpO1xuY29uc3QgcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vcHJvdmlkZXJzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBTVEFSVF9XQUlUX1RJTUVfTVMgPSAxMDAwO1xuY29uc3QgQkFDS09GRl9NVUxUSVBMSUVSID0gMS41O1xuY29uc3QgUkVUUllfTlVNQkVSID0gMTA7XG5mdW5jdGlvbiBmZXRjaEpzb24oY29ubmVjdGlvbkluZm9PclVybCwganNvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxldCBjb25uZWN0aW9uSW5mbyA9IHsgdXJsOiBudWxsIH07XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb25JbmZvT3JVcmwpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29ubmVjdGlvbkluZm8udXJsID0gY29ubmVjdGlvbkluZm9PclVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JbmZvID0gY29ubmVjdGlvbkluZm9PclVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkICgwLCBleHBvbmVudGlhbF9iYWNrb2ZmXzEuZGVmYXVsdCkoU1RBUlRfV0FJVF9USU1FX01TLCBSRVRSWV9OVU1CRVIsIEJBQ0tPRkZfTVVMVElQTElFUiwgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKGNvbm5lY3Rpb25JbmZvLnVybCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGpzb24gPyAnUE9TVCcgOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToganNvbiA/IGpzb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbkluZm8uaGVhZGVycyksIHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgZXJyb3JzXzEubG9nV2FybmluZykoYFJldHJ5aW5nIEhUVFAgcmVxdWVzdCBmb3IgJHtjb25uZWN0aW9uSW5mby51cmx9IGFzIGl0J3Mgbm90IGF2YWlsYWJsZSBub3dgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCBodHRwX2Vycm9yc18xLmRlZmF1bHQpKHJlc3BvbnNlLnN0YXR1cywgeWllbGQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ0ZldGNoRXJyb3InKSB8fCBlcnJvci50b1N0cmluZygpLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgZXJyb3JzXzEubG9nV2FybmluZykoYFJldHJ5aW5nIEhUVFAgcmVxdWVzdCBmb3IgJHtjb25uZWN0aW9uSW5mby51cmx9IGJlY2F1c2Ugb2YgZXJyb3I6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdmlkZXJzXzEuVHlwZWRFcnJvcihgRXhjZWVkZWQgJHtSRVRSWV9OVU1CRVJ9IGF0dGVtcHRzIGZvciAke2Nvbm5lY3Rpb25JbmZvLnVybH0uYCwgJ1JldHJpZXNFeGNlZWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoSnNvbiA9IGZldGNoSnNvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/utils/web.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/validators.js":
/*!****************************************************!*\
  !*** ./node_modules/near-api-js/lib/validators.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.diffEpochValidators = exports.findSeatPrice = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nconst depd_1 = __importDefault(__webpack_require__(/*! depd */ \"(ssr)/./node_modules/depd/index.js\"));\n/** Finds seat price given validators stakes and number of seats.\n *  Calculation follow the spec: https://nomicon.io/Economics/README.html#validator-selection\n * @params validators: current or next epoch validators.\n * @params maxNumberOfSeats: maximum number of seats in the network.\n * @params minimumStakeRatio: minimum stake ratio\n * @params protocolVersion: version of the protocol from genesis config\n */\nfunction findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {\n    if (protocolVersion && protocolVersion < 49) {\n        return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);\n    }\n    if (!minimumStakeRatio) {\n        const deprecate = (0, depd_1.default)('findSeatPrice(validators, maxNumberOfSeats)');\n        deprecate('`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead');\n        minimumStakeRatio = [1, 6250]; // harcoded minimumStakeRation from 12/7/21\n    }\n    return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);\n}\nexports.findSeatPrice = findSeatPrice;\nfunction findSeatPriceForProtocolBefore49(validators, numSeats) {\n    const stakes = validators.map(v => new bn_js_1.default(v.stake, 10)).sort((a, b) => a.cmp(b));\n    const num = new bn_js_1.default(numSeats);\n    const stakesSum = stakes.reduce((a, b) => a.add(b));\n    if (stakesSum.lt(num)) {\n        throw new Error('Stakes are below seats');\n    }\n    // assert stakesSum >= numSeats\n    let left = new bn_js_1.default(1), right = stakesSum.add(new bn_js_1.default(1));\n    while (!left.eq(right.sub(new bn_js_1.default(1)))) {\n        const mid = left.add(right).div(new bn_js_1.default(2));\n        let found = false;\n        let currentSum = new bn_js_1.default(0);\n        for (let i = 0; i < stakes.length; ++i) {\n            currentSum = currentSum.add(stakes[i].div(mid));\n            if (currentSum.gte(num)) {\n                left = mid;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            right = mid;\n        }\n    }\n    return left;\n}\n// nearcore reference: https://github.com/near/nearcore/blob/5a8ae263ec07930cd34d0dcf5bcee250c67c02aa/chain/epoch_manager/src/validator_selection.rs#L308;L315\nfunction findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {\n    if (minimumStakeRatio.length != 2) {\n        throw Error('minimumStakeRatio should have 2 elements');\n    }\n    const stakes = validators.map(v => new bn_js_1.default(v.stake, 10)).sort((a, b) => a.cmp(b));\n    const stakesSum = stakes.reduce((a, b) => a.add(b));\n    if (validators.length < maxNumberOfSeats) {\n        return stakesSum.mul(new bn_js_1.default(minimumStakeRatio[0])).div(new bn_js_1.default(minimumStakeRatio[1]));\n    }\n    else {\n        return stakes[0].add(new bn_js_1.default(1));\n    }\n}\n/** Diff validators between current and next epoch.\n * Returns additions, subtractions and changes to validator set.\n * @params currentValidators: list of current validators.\n * @params nextValidators: list of next validators.\n */\nfunction diffEpochValidators(currentValidators, nextValidators) {\n    const validatorsMap = new Map();\n    currentValidators.forEach(v => validatorsMap.set(v.account_id, v));\n    const nextValidatorsSet = new Set(nextValidators.map(v => v.account_id));\n    return {\n        newValidators: nextValidators.filter(v => !validatorsMap.has(v.account_id)),\n        removedValidators: currentValidators.filter(v => !nextValidatorsSet.has(v.account_id)),\n        changedValidators: nextValidators.filter(v => (validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake))\n            .map(v => ({ current: validatorsMap.get(v.account_id), next: v }))\n    };\n}\nexports.diffEpochValidators = diffEpochValidators;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3ZhbGlkYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxxQkFBcUI7QUFDbkQsZ0NBQWdDLG1CQUFPLENBQUMsbURBQU87QUFDL0MsK0JBQStCLG1CQUFPLENBQUMsZ0RBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEpBQTBKO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbURBQW1EO0FBQzVFO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi92YWxpZGF0b3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGlmZkVwb2NoVmFsaWRhdG9ycyA9IGV4cG9ydHMuZmluZFNlYXRQcmljZSA9IHZvaWQgMDtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IGRlcGRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVwZFwiKSk7XG4vKiogRmluZHMgc2VhdCBwcmljZSBnaXZlbiB2YWxpZGF0b3JzIHN0YWtlcyBhbmQgbnVtYmVyIG9mIHNlYXRzLlxuICogIENhbGN1bGF0aW9uIGZvbGxvdyB0aGUgc3BlYzogaHR0cHM6Ly9ub21pY29uLmlvL0Vjb25vbWljcy9SRUFETUUuaHRtbCN2YWxpZGF0b3Itc2VsZWN0aW9uXG4gKiBAcGFyYW1zIHZhbGlkYXRvcnM6IGN1cnJlbnQgb3IgbmV4dCBlcG9jaCB2YWxpZGF0b3JzLlxuICogQHBhcmFtcyBtYXhOdW1iZXJPZlNlYXRzOiBtYXhpbXVtIG51bWJlciBvZiBzZWF0cyBpbiB0aGUgbmV0d29yay5cbiAqIEBwYXJhbXMgbWluaW11bVN0YWtlUmF0aW86IG1pbmltdW0gc3Rha2UgcmF0aW9cbiAqIEBwYXJhbXMgcHJvdG9jb2xWZXJzaW9uOiB2ZXJzaW9uIG9mIHRoZSBwcm90b2NvbCBmcm9tIGdlbmVzaXMgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGZpbmRTZWF0UHJpY2UodmFsaWRhdG9ycywgbWF4TnVtYmVyT2ZTZWF0cywgbWluaW11bVN0YWtlUmF0aW8sIHByb3RvY29sVmVyc2lvbikge1xuICAgIGlmIChwcm90b2NvbFZlcnNpb24gJiYgcHJvdG9jb2xWZXJzaW9uIDwgNDkpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWF0UHJpY2VGb3JQcm90b2NvbEJlZm9yZTQ5KHZhbGlkYXRvcnMsIG1heE51bWJlck9mU2VhdHMpO1xuICAgIH1cbiAgICBpZiAoIW1pbmltdW1TdGFrZVJhdGlvKSB7XG4gICAgICAgIGNvbnN0IGRlcHJlY2F0ZSA9ICgwLCBkZXBkXzEuZGVmYXVsdCkoJ2ZpbmRTZWF0UHJpY2UodmFsaWRhdG9ycywgbWF4TnVtYmVyT2ZTZWF0cyknKTtcbiAgICAgICAgZGVwcmVjYXRlKCdgdXNlIGBmaW5kU2VhdFByaWNlKHZhbGlkYXRvcnMsIG1heE51bWJlck9mU2VhdHMsIG1pbmltdW1TdGFrZVJhdGlvKWAgaW5zdGVhZCcpO1xuICAgICAgICBtaW5pbXVtU3Rha2VSYXRpbyA9IFsxLCA2MjUwXTsgLy8gaGFyY29kZWQgbWluaW11bVN0YWtlUmF0aW9uIGZyb20gMTIvNy8yMVxuICAgIH1cbiAgICByZXR1cm4gZmluZFNlYXRQcmljZUZvclByb3RvY29sQWZ0ZXI0OSh2YWxpZGF0b3JzLCBtYXhOdW1iZXJPZlNlYXRzLCBtaW5pbXVtU3Rha2VSYXRpbyk7XG59XG5leHBvcnRzLmZpbmRTZWF0UHJpY2UgPSBmaW5kU2VhdFByaWNlO1xuZnVuY3Rpb24gZmluZFNlYXRQcmljZUZvclByb3RvY29sQmVmb3JlNDkodmFsaWRhdG9ycywgbnVtU2VhdHMpIHtcbiAgICBjb25zdCBzdGFrZXMgPSB2YWxpZGF0b3JzLm1hcCh2ID0+IG5ldyBibl9qc18xLmRlZmF1bHQodi5zdGFrZSwgMTApKS5zb3J0KChhLCBiKSA9PiBhLmNtcChiKSk7XG4gICAgY29uc3QgbnVtID0gbmV3IGJuX2pzXzEuZGVmYXVsdChudW1TZWF0cyk7XG4gICAgY29uc3Qgc3Rha2VzU3VtID0gc3Rha2VzLnJlZHVjZSgoYSwgYikgPT4gYS5hZGQoYikpO1xuICAgIGlmIChzdGFrZXNTdW0ubHQobnVtKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWtlcyBhcmUgYmVsb3cgc2VhdHMnKTtcbiAgICB9XG4gICAgLy8gYXNzZXJ0IHN0YWtlc1N1bSA+PSBudW1TZWF0c1xuICAgIGxldCBsZWZ0ID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgxKSwgcmlnaHQgPSBzdGFrZXNTdW0uYWRkKG5ldyBibl9qc18xLmRlZmF1bHQoMSkpO1xuICAgIHdoaWxlICghbGVmdC5lcShyaWdodC5zdWIobmV3IGJuX2pzXzEuZGVmYXVsdCgxKSkpKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IGxlZnQuYWRkKHJpZ2h0KS5kaXYobmV3IGJuX2pzXzEuZGVmYXVsdCgyKSk7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY3VycmVudFN1bSA9IG5ldyBibl9qc18xLmRlZmF1bHQoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Rha2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjdXJyZW50U3VtID0gY3VycmVudFN1bS5hZGQoc3Rha2VzW2ldLmRpdihtaWQpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3VtLmd0ZShudW0pKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IG1pZDtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG59XG4vLyBuZWFyY29yZSByZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL25lYXJjb3JlL2Jsb2IvNWE4YWUyNjNlYzA3OTMwY2QzNGQwZGNmNWJjZWUyNTBjNjdjMDJhYS9jaGFpbi9lcG9jaF9tYW5hZ2VyL3NyYy92YWxpZGF0b3Jfc2VsZWN0aW9uLnJzI0wzMDg7TDMxNVxuZnVuY3Rpb24gZmluZFNlYXRQcmljZUZvclByb3RvY29sQWZ0ZXI0OSh2YWxpZGF0b3JzLCBtYXhOdW1iZXJPZlNlYXRzLCBtaW5pbXVtU3Rha2VSYXRpbykge1xuICAgIGlmIChtaW5pbXVtU3Rha2VSYXRpby5sZW5ndGggIT0gMikge1xuICAgICAgICB0aHJvdyBFcnJvcignbWluaW11bVN0YWtlUmF0aW8gc2hvdWxkIGhhdmUgMiBlbGVtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBzdGFrZXMgPSB2YWxpZGF0b3JzLm1hcCh2ID0+IG5ldyBibl9qc18xLmRlZmF1bHQodi5zdGFrZSwgMTApKS5zb3J0KChhLCBiKSA9PiBhLmNtcChiKSk7XG4gICAgY29uc3Qgc3Rha2VzU3VtID0gc3Rha2VzLnJlZHVjZSgoYSwgYikgPT4gYS5hZGQoYikpO1xuICAgIGlmICh2YWxpZGF0b3JzLmxlbmd0aCA8IG1heE51bWJlck9mU2VhdHMpIHtcbiAgICAgICAgcmV0dXJuIHN0YWtlc1N1bS5tdWwobmV3IGJuX2pzXzEuZGVmYXVsdChtaW5pbXVtU3Rha2VSYXRpb1swXSkpLmRpdihuZXcgYm5fanNfMS5kZWZhdWx0KG1pbmltdW1TdGFrZVJhdGlvWzFdKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3Rha2VzWzBdLmFkZChuZXcgYm5fanNfMS5kZWZhdWx0KDEpKTtcbiAgICB9XG59XG4vKiogRGlmZiB2YWxpZGF0b3JzIGJldHdlZW4gY3VycmVudCBhbmQgbmV4dCBlcG9jaC5cbiAqIFJldHVybnMgYWRkaXRpb25zLCBzdWJ0cmFjdGlvbnMgYW5kIGNoYW5nZXMgdG8gdmFsaWRhdG9yIHNldC5cbiAqIEBwYXJhbXMgY3VycmVudFZhbGlkYXRvcnM6IGxpc3Qgb2YgY3VycmVudCB2YWxpZGF0b3JzLlxuICogQHBhcmFtcyBuZXh0VmFsaWRhdG9yczogbGlzdCBvZiBuZXh0IHZhbGlkYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGRpZmZFcG9jaFZhbGlkYXRvcnMoY3VycmVudFZhbGlkYXRvcnMsIG5leHRWYWxpZGF0b3JzKSB7XG4gICAgY29uc3QgdmFsaWRhdG9yc01hcCA9IG5ldyBNYXAoKTtcbiAgICBjdXJyZW50VmFsaWRhdG9ycy5mb3JFYWNoKHYgPT4gdmFsaWRhdG9yc01hcC5zZXQodi5hY2NvdW50X2lkLCB2KSk7XG4gICAgY29uc3QgbmV4dFZhbGlkYXRvcnNTZXQgPSBuZXcgU2V0KG5leHRWYWxpZGF0b3JzLm1hcCh2ID0+IHYuYWNjb3VudF9pZCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5ld1ZhbGlkYXRvcnM6IG5leHRWYWxpZGF0b3JzLmZpbHRlcih2ID0+ICF2YWxpZGF0b3JzTWFwLmhhcyh2LmFjY291bnRfaWQpKSxcbiAgICAgICAgcmVtb3ZlZFZhbGlkYXRvcnM6IGN1cnJlbnRWYWxpZGF0b3JzLmZpbHRlcih2ID0+ICFuZXh0VmFsaWRhdG9yc1NldC5oYXModi5hY2NvdW50X2lkKSksXG4gICAgICAgIGNoYW5nZWRWYWxpZGF0b3JzOiBuZXh0VmFsaWRhdG9ycy5maWx0ZXIodiA9PiAodmFsaWRhdG9yc01hcC5oYXModi5hY2NvdW50X2lkKSAmJiB2YWxpZGF0b3JzTWFwLmdldCh2LmFjY291bnRfaWQpLnN0YWtlICE9IHYuc3Rha2UpKVxuICAgICAgICAgICAgLm1hcCh2ID0+ICh7IGN1cnJlbnQ6IHZhbGlkYXRvcnNNYXAuZ2V0KHYuYWNjb3VudF9pZCksIG5leHQ6IHYgfSkpXG4gICAgfTtcbn1cbmV4cG9ydHMuZGlmZkVwb2NoVmFsaWRhdG9ycyA9IGRpZmZFcG9jaFZhbGlkYXRvcnM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/validators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/near-api-js/lib/wallet-account.js":
/*!********************************************************!*\
  !*** ./node_modules/near-api-js/lib/wallet-account.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectedWalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link key_stores/browser_local_storage_key_store!BrowserLocalStorageKeyStore}.\n * This module exposes two classes:\n * * {@link WalletConnection} which redirects users to [NEAR Wallet](https://wallet.near.org/) for key management.\n * * {@link ConnectedWalletAccount} is an {@link account!Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/near-api-js/lib/account.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/near-api-js/lib/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/near-api-js/lib/utils/index.js\");\nconst borsh_1 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\nconst borsh_2 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is used in conjunction with the {@link key_stores/browser_local_storage_key_store!BrowserLocalStorageKeyStore}.\n * It redirects users to [NEAR Wallet](https://wallet.near.org) for key management.\n * This class is not intended for use outside the browser. Without `window` (i.e. in server contexts), it will instantiate but will throw a clear error when used.\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#wallet](https://docs.near.org/tools/near-api-js/quick-reference#wallet)\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSignedIn()) return wallet.requestSignIn()\n * ```\n */\nclass WalletConnection {\n    constructor(near, appKeyPrefix) {\n        if (typeof window === 'undefined') {\n            return new Proxy(this, {\n                get(target, property) {\n                    if (property === 'isSignedIn') {\n                        return () => false;\n                    }\n                    if (property === 'getAccountId') {\n                        return () => '';\n                    }\n                    if (target[property] && typeof target[property] === 'function') {\n                        return () => {\n                            throw new Error('No window found in context, please ensure you are using WalletConnection on the browser');\n                        };\n                    }\n                    return target[property];\n                }\n            });\n        }\n        this._near = near;\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n        const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n        this._networkId = near.config.networkId;\n        this._walletBaseUrl = near.config.walletUrl;\n        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n        this._keyStore = near.connection.signer.keyStore;\n        this._authData = authData || { allKeys: [] };\n        this._authDataKey = authDataKey;\n        if (!this.isSignedIn()) {\n            this._completeSignInPromise = this._completeSignInWithAccessKey();\n        }\n    }\n    /**\n     * Returns true, if this WalletConnection is authorized with the wallet.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn();\n     * ```\n     */\n    isSignedIn() {\n        return !!this._authData.accountId;\n    }\n    /**\n     * Returns promise of completing signing in after redirecting from wallet\n     * @example\n     * ```js\n     * // on login callback page\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn(); // false\n     * await wallet.isSignedInAsync(); // true\n     * ```\n     */\n    isSignedInAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._completeSignInPromise) {\n                return this.isSignedIn();\n            }\n            yield this._completeSignInPromise;\n            return this.isSignedIn();\n        });\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.getAccountId();\n     * ```\n     */\n    getAccountId() {\n        return this._authData.accountId || '';\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // redirects to the NEAR Wallet\n     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    requestSignIn({ contractId, methodNames, successUrl, failureUrl }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentUrl = new URL(window.location.href);\n            const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n            newUrl.searchParams.set('success_url', successUrl || currentUrl.href);\n            newUrl.searchParams.set('failure_url', failureUrl || currentUrl.href);\n            if (contractId) {\n                /* Throws exception if contract account does not exist */\n                const contractAccount = yield this._near.account(contractId);\n                yield contractAccount.state();\n                newUrl.searchParams.set('contract_id', contractId);\n                const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n                newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n                yield this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n            }\n            if (methodNames) {\n                methodNames.forEach(methodName => {\n                    newUrl.searchParams.append('methodNames', methodName);\n                });\n            }\n            window.location.assign(newUrl.toString());\n        });\n    }\n    /**\n     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.\n     */\n    requestSignTransactions({ transactions, meta, callbackUrl }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentUrl = new URL(window.location.href);\n            const newUrl = new URL('sign', this._walletBaseUrl);\n            newUrl.searchParams.set('transactions', transactions\n                .map(transaction => (0, borsh_2.serialize)(transaction_1.SCHEMA, transaction))\n                .map(serialized => Buffer.from(serialized).toString('base64'))\n                .join(','));\n            newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n            if (meta)\n                newUrl.searchParams.set('meta', meta);\n            window.location.assign(newUrl.toString());\n        });\n    }\n    /**\n     * @hidden\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n    _completeSignInWithAccessKey() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentUrl = new URL(window.location.href);\n            const publicKey = currentUrl.searchParams.get('public_key') || '';\n            const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n            const accountId = currentUrl.searchParams.get('account_id') || '';\n            // TODO: Handle errors during login\n            if (accountId) {\n                const authData = {\n                    accountId,\n                    allKeys\n                };\n                window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));\n                if (publicKey) {\n                    yield this._moveKeyFromTempToPermanent(accountId, publicKey);\n                }\n                this._authData = authData;\n            }\n            currentUrl.searchParams.delete('public_key');\n            currentUrl.searchParams.delete('all_keys');\n            currentUrl.searchParams.delete('account_id');\n            currentUrl.searchParams.delete('meta');\n            currentUrl.searchParams.delete('transactionHashes');\n            window.history.replaceState({}, document.title, currentUrl.toString());\n        });\n    }\n    /**\n     * @hidden\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n    _moveKeyFromTempToPermanent(accountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyPair = yield this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n            yield this._keyStore.setKey(this._networkId, accountId, keyPair);\n            yield this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n        });\n    }\n    /**\n     * Sign out from the current account\n     * @example\n     * walletConnection.signOut();\n     */\n    signOut() {\n        this._authData = {};\n        window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n    account() {\n        if (!this._connectedAccount) {\n            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n        }\n        return this._connectedAccount;\n    }\n}\nexports.WalletConnection = WalletConnection;\n/**\n * {@link account!Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nclass ConnectedWalletAccount extends account_1.Account {\n    constructor(walletConnection, connection, accountId) {\n        super(connection, accountId);\n        this.walletConnection = walletConnection;\n    }\n    // Overriding Account methods\n    /**\n     * Sign a transaction by redirecting to the NEAR Wallet\n     * @see {@link WalletConnection.requestSignTransactions}\n     */\n    signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const localKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n            let accessKey = yield this.accessKeyForTransaction(receiverId, actions, localKey);\n            if (!accessKey) {\n                throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n            }\n            if (localKey && localKey.toString() === accessKey.public_key) {\n                try {\n                    return yield _super.signAndSendTransaction.call(this, { receiverId, actions });\n                }\n                catch (e) {\n                    if (e.type === 'NotEnoughAllowance') {\n                        accessKey = yield this.accessKeyForTransaction(receiverId, actions);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = (0, borsh_1.baseDecode)(block.header.hash);\n            const publicKey = utils_1.PublicKey.from(accessKey.public_key);\n            // TODO: Cache & listen for nonce updates for given access key\n            const nonce = accessKey.access_key.nonce.add(new bn_js_1.default(1));\n            const transaction = (0, transaction_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n            yield this.walletConnection.requestSignTransactions({\n                transactions: [transaction],\n                meta: walletMeta,\n                callbackUrl: walletCallbackUrl\n            });\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    reject(new Error('Failed to redirect to sign transaction'));\n                }, 1000);\n            });\n            // TODO: Aggregate multiple transaction request with \"debounce\".\n            // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n        });\n    }\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of \\{access_key: AccessKey, public_key: PublicKey\\} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n    accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { access_key: { permission } } = accessKey;\n            if (permission === 'FullAccess') {\n                return true;\n            }\n            if (permission.FunctionCall) {\n                const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\n                /********************************\n                Accept multisig access keys and let wallets attempt to signAndSendTransaction\n                If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n                ********************************/\n                if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n                    return true;\n                }\n                if (allowedReceiverId === receiverId) {\n                    if (actions.length !== 1) {\n                        return false;\n                    }\n                    const [{ functionCall }] = actions;\n                    return functionCall &&\n                        (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?\n                        (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n                    // TODO: Handle cases when allowance doesn't have enough to pay for gas\n                }\n            }\n            // TODO: Support other permissions than FunctionCall\n            return false;\n        });\n    }\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     */\n    accessKeyForTransaction(receiverId, actions, localKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKeys = yield this.getAccessKeys();\n            if (localKey) {\n                const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n                if (accessKey && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n                    return accessKey;\n                }\n            }\n            const walletKeys = this.walletConnection._authData.allKeys;\n            for (const accessKey of accessKeys) {\n                if (walletKeys.indexOf(accessKey.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n                    return accessKey;\n                }\n            }\n            return null;\n        });\n    }\n}\nexports.ConnectedWalletAccount = ConnectedWalletAccount;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmVhci1hcGktanMvbGliL3dhbGxldC1hY2NvdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLHdCQUF3QjtBQUN6RDtBQUNBLGdFQUFnRSw2RUFBNkU7QUFDN0k7QUFDQSxNQUFNLHdCQUF3QjtBQUM5QixNQUFNLDhCQUE4QixPQUFPLHVCQUF1QiwwQkFBMEIsd0JBQXdCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGtFQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFPO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFPO0FBQy9CLGdDQUFnQyxtQkFBTyxDQUFDLG1EQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLCtDQUErQyw2RUFBNkU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBaUQ7QUFDL0U7QUFDQTtBQUNBLG9CQUFvQixpREFBaUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxJQUFJLHVCQUF1QixnREFBZ0Qsd0JBQXdCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QiwyRUFBMkU7QUFDeEc7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFdBQVc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHFCQUFxQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxtQkFBbUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUErRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYXllaGFsbC9ldGhnbG9iYWwtdW5pdGUtZGVmaS9uZWFyLWVzY3Jvdy1zcmMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25lYXItYXBpLWpzL2xpYi93YWxsZXQtYWNjb3VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0ZWRXYWxsZXRBY2NvdW50ID0gZXhwb3J0cy5XYWxsZXRDb25uZWN0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBUaGUgY2xhc3NlcyBpbiB0aGlzIG1vZHVsZSBhcmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSB7QGxpbmsga2V5X3N0b3Jlcy9icm93c2VyX2xvY2FsX3N0b3JhZ2Vfa2V5X3N0b3JlIUJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZX0uXG4gKiBUaGlzIG1vZHVsZSBleHBvc2VzIHR3byBjbGFzc2VzOlxuICogKiB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbn0gd2hpY2ggcmVkaXJlY3RzIHVzZXJzIHRvIFtORUFSIFdhbGxldF0oaHR0cHM6Ly93YWxsZXQubmVhci5vcmcvKSBmb3Iga2V5IG1hbmFnZW1lbnQuXG4gKiAqIHtAbGluayBDb25uZWN0ZWRXYWxsZXRBY2NvdW50fSBpcyBhbiB7QGxpbmsgYWNjb3VudCFBY2NvdW50fSBpbXBsZW1lbnRhdGlvbiB0aGF0IHVzZXMge0BsaW5rIFdhbGxldENvbm5lY3Rpb259IHRvIGdldCBrZXlzXG4gKlxuICogQG1vZHVsZSB3YWxsZXRBY2NvdW50XG4gKi9cbmNvbnN0IGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBib3JzaF8xID0gcmVxdWlyZShcImJvcnNoXCIpO1xuY29uc3QgYm9yc2hfMiA9IHJlcXVpcmUoXCJib3JzaFwiKTtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IExPR0lOX1dBTExFVF9VUkxfU1VGRklYID0gJy9sb2dpbi8nO1xuY29uc3QgTVVMVElTSUdfSEFTX01FVEhPRCA9ICdhZGRfcmVxdWVzdF9hbmRfY29uZmlybSc7XG5jb25zdCBMT0NBTF9TVE9SQUdFX0tFWV9TVUZGSVggPSAnX3dhbGxldF9hdXRoX2tleSc7XG5jb25zdCBQRU5ESU5HX0FDQ0VTU19LRVlfUFJFRklYID0gJ3BlbmRpbmdfa2V5JzsgLy8gYnJvd3NlciBzdG9yYWdlIGtleSBmb3IgYSBwZW5kaW5nIGFjY2VzcyBrZXkgKGkuZS4ga2V5IGhhcyBiZWVuIGdlbmVyYXRlZCBidXQgd2UgYXJlIG5vdCBzdXJlIGl0IHdhcyBhZGRlZCB5ZXQpXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSB7QGxpbmsga2V5X3N0b3Jlcy9icm93c2VyX2xvY2FsX3N0b3JhZ2Vfa2V5X3N0b3JlIUJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZX0uXG4gKiBJdCByZWRpcmVjdHMgdXNlcnMgdG8gW05FQVIgV2FsbGV0XShodHRwczovL3dhbGxldC5uZWFyLm9yZykgZm9yIGtleSBtYW5hZ2VtZW50LlxuICogVGhpcyBjbGFzcyBpcyBub3QgaW50ZW5kZWQgZm9yIHVzZSBvdXRzaWRlIHRoZSBicm93c2VyLiBXaXRob3V0IGB3aW5kb3dgIChpLmUuIGluIHNlcnZlciBjb250ZXh0cyksIGl0IHdpbGwgaW5zdGFudGlhdGUgYnV0IHdpbGwgdGhyb3cgYSBjbGVhciBlcnJvciB3aGVuIHVzZWQuXG4gKlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSN3YWxsZXRdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2Ujd2FsbGV0KVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgbmV3IFdhbGxldENvbm5lY3Rpb24gaW5zdGFuY2VcbiAqIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXRDb25uZWN0aW9uKG5lYXIsICdteS1hcHAnKTtcbiAqXG4gKiAvLyBJZiBub3Qgc2lnbmVkIGluIHJlZGlyZWN0IHRvIHRoZSBORUFSIHdhbGxldCB0byBzaWduIGluXG4gKiAvLyBrZXlzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBCcm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmVcbiAqIGlmKCF3YWxsZXQuaXNTaWduZWRJbigpKSByZXR1cm4gd2FsbGV0LnJlcXVlc3RTaWduSW4oKVxuICogYGBgXG4gKi9cbmNsYXNzIFdhbGxldENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG5lYXIsIGFwcEtleVByZWZpeCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2lzU2lnbmVkSW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnZ2V0QWNjb3VudElkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbcHJvcGVydHldICYmIHR5cGVvZiB0YXJnZXRbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2luZG93IGZvdW5kIGluIGNvbnRleHQsIHBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyBXYWxsZXRDb25uZWN0aW9uIG9uIHRoZSBicm93c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgICAgICBjb25zdCBhdXRoRGF0YUtleSA9IGFwcEtleVByZWZpeCArIExPQ0FMX1NUT1JBR0VfS0VZX1NVRkZJWDtcbiAgICAgICAgY29uc3QgYXV0aERhdGEgPSBKU09OLnBhcnNlKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShhdXRoRGF0YUtleSkpO1xuICAgICAgICB0aGlzLl9uZXR3b3JrSWQgPSBuZWFyLmNvbmZpZy5uZXR3b3JrSWQ7XG4gICAgICAgIHRoaXMuX3dhbGxldEJhc2VVcmwgPSBuZWFyLmNvbmZpZy53YWxsZXRVcmw7XG4gICAgICAgIGFwcEtleVByZWZpeCA9IGFwcEtleVByZWZpeCB8fCBuZWFyLmNvbmZpZy5jb250cmFjdE5hbWUgfHwgJ2RlZmF1bHQnO1xuICAgICAgICB0aGlzLl9rZXlTdG9yZSA9IG5lYXIuY29ubmVjdGlvbi5zaWduZXIua2V5U3RvcmU7XG4gICAgICAgIHRoaXMuX2F1dGhEYXRhID0gYXV0aERhdGEgfHwgeyBhbGxLZXlzOiBbXSB9O1xuICAgICAgICB0aGlzLl9hdXRoRGF0YUtleSA9IGF1dGhEYXRhS2V5O1xuICAgICAgICBpZiAoIXRoaXMuaXNTaWduZWRJbigpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZVNpZ25JblByb21pc2UgPSB0aGlzLl9jb21wbGV0ZVNpZ25JbldpdGhBY2Nlc3NLZXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUsIGlmIHRoaXMgV2FsbGV0Q29ubmVjdGlvbiBpcyBhdXRob3JpemVkIHdpdGggdGhlIHdhbGxldC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgd2FsbGV0ID0gbmV3IFdhbGxldENvbm5lY3Rpb24obmVhciwgJ215LWFwcCcpO1xuICAgICAqIHdhbGxldC5pc1NpZ25lZEluKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgaXNTaWduZWRJbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYXV0aERhdGEuYWNjb3VudElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHByb21pc2Ugb2YgY29tcGxldGluZyBzaWduaW5nIGluIGFmdGVyIHJlZGlyZWN0aW5nIGZyb20gd2FsbGV0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIG9uIGxvZ2luIGNhbGxiYWNrIHBhZ2VcbiAgICAgKiBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0Q29ubmVjdGlvbihuZWFyLCAnbXktYXBwJyk7XG4gICAgICogd2FsbGV0LmlzU2lnbmVkSW4oKTsgLy8gZmFsc2VcbiAgICAgKiBhd2FpdCB3YWxsZXQuaXNTaWduZWRJbkFzeW5jKCk7IC8vIHRydWVcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpc1NpZ25lZEluQXN5bmMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBsZXRlU2lnbkluUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU2lnbmVkSW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2NvbXBsZXRlU2lnbkluUHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU2lnbmVkSW4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXV0aG9yaXplZCBBY2NvdW50IElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0Q29ubmVjdGlvbihuZWFyLCAnbXktYXBwJyk7XG4gICAgICogd2FsbGV0LmdldEFjY291bnRJZCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldEFjY291bnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhEYXRhLmFjY291bnRJZCB8fCAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkaXJlY3RzIGN1cnJlbnQgcGFnZSB0byB0aGUgd2FsbGV0IGF1dGhlbnRpY2F0aW9uIHBhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdElkIFRoZSBORUFSIGFjY291bnQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3VjY2Vzc1VybCBVUkwgdG8gcmVkaXJlY3QgdXBvbiBzdWNjZXNzLiBEZWZhdWx0OiBjdXJyZW50IHVybFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZhaWx1cmVVcmwgVVJMIHRvIHJlZGlyZWN0IHVwb24gZmFpbHVyZS4gRGVmYXVsdDogY3VycmVudCB1cmxcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0Q29ubmVjdGlvbihuZWFyLCAnbXktYXBwJyk7XG4gICAgICogLy8gcmVkaXJlY3RzIHRvIHRoZSBORUFSIFdhbGxldFxuICAgICAqIHdhbGxldC5yZXF1ZXN0U2lnbkluKHsgY29udHJhY3RJZDogJ2FjY291bnQtd2l0aC1kZXBsb3ktY29udHJhY3QubmVhcicgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVxdWVzdFNpZ25Jbih7IGNvbnRyYWN0SWQsIG1ldGhvZE5hbWVzLCBzdWNjZXNzVXJsLCBmYWlsdXJlVXJsIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1VybCA9IG5ldyBVUkwodGhpcy5fd2FsbGV0QmFzZVVybCArIExPR0lOX1dBTExFVF9VUkxfU1VGRklYKTtcbiAgICAgICAgICAgIG5ld1VybC5zZWFyY2hQYXJhbXMuc2V0KCdzdWNjZXNzX3VybCcsIHN1Y2Nlc3NVcmwgfHwgY3VycmVudFVybC5ocmVmKTtcbiAgICAgICAgICAgIG5ld1VybC5zZWFyY2hQYXJhbXMuc2V0KCdmYWlsdXJlX3VybCcsIGZhaWx1cmVVcmwgfHwgY3VycmVudFVybC5ocmVmKTtcbiAgICAgICAgICAgIGlmIChjb250cmFjdElkKSB7XG4gICAgICAgICAgICAgICAgLyogVGhyb3dzIGV4Y2VwdGlvbiBpZiBjb250cmFjdCBhY2NvdW50IGRvZXMgbm90IGV4aXN0ICovXG4gICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3RBY2NvdW50ID0geWllbGQgdGhpcy5fbmVhci5hY2NvdW50KGNvbnRyYWN0SWQpO1xuICAgICAgICAgICAgICAgIHlpZWxkIGNvbnRyYWN0QWNjb3VudC5zdGF0ZSgpO1xuICAgICAgICAgICAgICAgIG5ld1VybC5zZWFyY2hQYXJhbXMuc2V0KCdjb250cmFjdF9pZCcsIGNvbnRyYWN0SWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IHV0aWxzXzEuS2V5UGFpci5mcm9tUmFuZG9tKCdlZDI1NTE5Jyk7XG4gICAgICAgICAgICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3B1YmxpY19rZXknLCBhY2Nlc3NLZXkuZ2V0UHVibGljS2V5KCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fa2V5U3RvcmUuc2V0S2V5KHRoaXMuX25ldHdvcmtJZCwgUEVORElOR19BQ0NFU1NfS0VZX1BSRUZJWCArIGFjY2Vzc0tleS5nZXRQdWJsaWNLZXkoKSwgYWNjZXNzS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdtZXRob2ROYW1lcycsIG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihuZXdVcmwudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyB0aGUgdXNlciB0byBxdWlja2x5IHNpZ24gZm9yIGEgdHJhbnNhY3Rpb24gb3IgYmF0Y2ggb2YgdHJhbnNhY3Rpb25zIGJ5IHJlZGlyZWN0aW5nIHRvIHRoZSBORUFSIHdhbGxldC5cbiAgICAgKi9cbiAgICByZXF1ZXN0U2lnblRyYW5zYWN0aW9ucyh7IHRyYW5zYWN0aW9ucywgbWV0YSwgY2FsbGJhY2tVcmwgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgY29uc3QgbmV3VXJsID0gbmV3IFVSTCgnc2lnbicsIHRoaXMuX3dhbGxldEJhc2VVcmwpO1xuICAgICAgICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3RyYW5zYWN0aW9ucycsIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5tYXAodHJhbnNhY3Rpb24gPT4gKDAsIGJvcnNoXzIuc2VyaWFsaXplKSh0cmFuc2FjdGlvbl8xLlNDSEVNQSwgdHJhbnNhY3Rpb24pKVxuICAgICAgICAgICAgICAgIC5tYXAoc2VyaWFsaXplZCA9PiBCdWZmZXIuZnJvbShzZXJpYWxpemVkKS50b1N0cmluZygnYmFzZTY0JykpXG4gICAgICAgICAgICAgICAgLmpvaW4oJywnKSk7XG4gICAgICAgICAgICBuZXdVcmwuc2VhcmNoUGFyYW1zLnNldCgnY2FsbGJhY2tVcmwnLCBjYWxsYmFja1VybCB8fCBjdXJyZW50VXJsLmhyZWYpO1xuICAgICAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5zZXQoJ21ldGEnLCBtZXRhKTtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24obmV3VXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIENvbXBsZXRlIHNpZ24gaW4gZm9yIGEgZ2l2ZW4gYWNjb3VudCBpZCBhbmQgcHVibGljIGtleS4gVG8gYmUgaW52b2tlZCBieSB0aGUgYXBwIHdoZW4gZ2V0dGluZyBhIGNhbGxiYWNrIGZyb20gdGhlIHdhbGxldC5cbiAgICAgKi9cbiAgICBfY29tcGxldGVTaWduSW5XaXRoQWNjZXNzS2V5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3VycmVudFVybC5zZWFyY2hQYXJhbXMuZ2V0KCdwdWJsaWNfa2V5JykgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBhbGxLZXlzID0gKGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLmdldCgnYWxsX2tleXMnKSB8fCAnJykuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRJZCA9IGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLmdldCgnYWNjb3VudF9pZCcpIHx8ICcnO1xuICAgICAgICAgICAgLy8gVE9ETzogSGFuZGxlIGVycm9ycyBkdXJpbmcgbG9naW5cbiAgICAgICAgICAgIGlmIChhY2NvdW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudElkLFxuICAgICAgICAgICAgICAgICAgICBhbGxLZXlzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5fYXV0aERhdGFLZXksIEpTT04uc3RyaW5naWZ5KGF1dGhEYXRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKHB1YmxpY0tleSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9tb3ZlS2V5RnJvbVRlbXBUb1Blcm1hbmVudChhY2NvdW50SWQsIHB1YmxpY0tleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhEYXRhID0gYXV0aERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ3B1YmxpY19rZXknKTtcbiAgICAgICAgICAgIGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnYWxsX2tleXMnKTtcbiAgICAgICAgICAgIGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnYWNjb3VudF9pZCcpO1xuICAgICAgICAgICAgY3VycmVudFVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdtZXRhJyk7XG4gICAgICAgICAgICBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ3RyYW5zYWN0aW9uSGFzaGVzJyk7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCBjdXJyZW50VXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCBvd25pbmcgdGhlIGdpdmVuIHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IGJlaW5nIHNldCB0byB0aGUga2V5IHN0b3JlXG4gICAgICovXG4gICAgX21vdmVLZXlGcm9tVGVtcFRvUGVybWFuZW50KGFjY291bnRJZCwgcHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlQYWlyID0geWllbGQgdGhpcy5fa2V5U3RvcmUuZ2V0S2V5KHRoaXMuX25ldHdvcmtJZCwgUEVORElOR19BQ0NFU1NfS0VZX1BSRUZJWCArIHB1YmxpY0tleSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLl9rZXlTdG9yZS5zZXRLZXkodGhpcy5fbmV0d29ya0lkLCBhY2NvdW50SWQsIGtleVBhaXIpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fa2V5U3RvcmUucmVtb3ZlS2V5KHRoaXMuX25ldHdvcmtJZCwgUEVORElOR19BQ0NFU1NfS0VZX1BSRUZJWCArIHB1YmxpY0tleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIG91dCBmcm9tIHRoZSBjdXJyZW50IGFjY291bnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHdhbGxldENvbm5lY3Rpb24uc2lnbk91dCgpO1xuICAgICAqL1xuICAgIHNpZ25PdXQoKSB7XG4gICAgICAgIHRoaXMuX2F1dGhEYXRhID0ge307XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLl9hdXRoRGF0YUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGVkIHdhbGxldCBhY2NvdW50XG4gICAgICovXG4gICAgYWNjb3VudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWRBY2NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0ZWRBY2NvdW50ID0gbmV3IENvbm5lY3RlZFdhbGxldEFjY291bnQodGhpcywgdGhpcy5fbmVhci5jb25uZWN0aW9uLCB0aGlzLl9hdXRoRGF0YS5hY2NvdW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWRBY2NvdW50O1xuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0Q29ubmVjdGlvbiA9IFdhbGxldENvbm5lY3Rpb247XG4vKipcbiAqIHtAbGluayBhY2NvdW50IUFjY291bnR9IGltcGxlbWVudGF0aW9uIHdoaWNoIHJlZGlyZWN0cyB0byB3YWxsZXQgdXNpbmcge0BsaW5rIFdhbGxldENvbm5lY3Rpb259IHdoZW4gbm8gbG9jYWwga2V5IGlzIGF2YWlsYWJsZS5cbiAqL1xuY2xhc3MgQ29ubmVjdGVkV2FsbGV0QWNjb3VudCBleHRlbmRzIGFjY291bnRfMS5BY2NvdW50IHtcbiAgICBjb25zdHJ1Y3Rvcih3YWxsZXRDb25uZWN0aW9uLCBjb25uZWN0aW9uLCBhY2NvdW50SWQpIHtcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgYWNjb3VudElkKTtcbiAgICAgICAgdGhpcy53YWxsZXRDb25uZWN0aW9uID0gd2FsbGV0Q29ubmVjdGlvbjtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGluZyBBY2NvdW50IG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBTaWduIGEgdHJhbnNhY3Rpb24gYnkgcmVkaXJlY3RpbmcgdG8gdGhlIE5FQVIgV2FsbGV0XG4gICAgICogQHNlZSB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbi5yZXF1ZXN0U2lnblRyYW5zYWN0aW9uc31cbiAgICAgKi9cbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHsgcmVjZWl2ZXJJZCwgYWN0aW9ucywgd2FsbGV0TWV0YSwgd2FsbGV0Q2FsbGJhY2tVcmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZiB9KSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogeyBnZXQ6ICgpID0+IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsS2V5ID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnNpZ25lci5nZXRQdWJsaWNLZXkodGhpcy5hY2NvdW50SWQsIHRoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWQpO1xuICAgICAgICAgICAgbGV0IGFjY2Vzc0tleSA9IHlpZWxkIHRoaXMuYWNjZXNzS2V5Rm9yVHJhbnNhY3Rpb24ocmVjZWl2ZXJJZCwgYWN0aW9ucywgbG9jYWxLZXkpO1xuICAgICAgICAgICAgaWYgKCFhY2Nlc3NLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIG1hdGNoaW5nIGtleSBmb3IgdHJhbnNhY3Rpb24gc2VudCB0byAke3JlY2VpdmVySWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxLZXkgJiYgbG9jYWxLZXkudG9TdHJpbmcoKSA9PT0gYWNjZXNzS2V5LnB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdOb3RFbm91Z2hBbGxvd2FuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NLZXkgPSB5aWVsZCB0aGlzLmFjY2Vzc0tleUZvclRyYW5zYWN0aW9uKHJlY2VpdmVySWQsIGFjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLmJsb2NrKHsgZmluYWxpdHk6ICdmaW5hbCcgfSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0hhc2ggPSAoMCwgYm9yc2hfMS5iYXNlRGVjb2RlKShibG9jay5oZWFkZXIuaGFzaCk7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSB1dGlsc18xLlB1YmxpY0tleS5mcm9tKGFjY2Vzc0tleS5wdWJsaWNfa2V5KTtcbiAgICAgICAgICAgIC8vIFRPRE86IENhY2hlICYgbGlzdGVuIGZvciBub25jZSB1cGRhdGVzIGZvciBnaXZlbiBhY2Nlc3Mga2V5XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGFjY2Vzc0tleS5hY2Nlc3Nfa2V5Lm5vbmNlLmFkZChuZXcgYm5fanNfMS5kZWZhdWx0KDEpKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gKDAsIHRyYW5zYWN0aW9uXzEuY3JlYXRlVHJhbnNhY3Rpb24pKHRoaXMuYWNjb3VudElkLCBwdWJsaWNLZXksIHJlY2VpdmVySWQsIG5vbmNlLCBhY3Rpb25zLCBibG9ja0hhc2gpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy53YWxsZXRDb25uZWN0aW9uLnJlcXVlc3RTaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgbWV0YTogd2FsbGV0TWV0YSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja1VybDogd2FsbGV0Q2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlZGlyZWN0IHRvIHNpZ24gdHJhbnNhY3Rpb24nKSk7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFnZ3JlZ2F0ZSBtdWx0aXBsZSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggXCJkZWJvdW5jZVwiLlxuICAgICAgICAgICAgLy8gVE9ETzogSW50cm9kdWNlIFRyYXNhY3Rpb25RdWV1ZSB3aGljaCBhbHNvIGNhbiBiZSB1c2VkIHRvIHdhdGNoIGZvciBzdGF0dXM/XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBnaXZlbiBhY2Nlc3Mga2V5IGFsbG93cyB0aGUgZnVuY3Rpb24gY2FsbCBvciBtZXRob2QgYXR0ZW1wdGVkIGluIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGFjY2Vzc0tleSBBcnJheSBvZiBcXHthY2Nlc3Nfa2V5OiBBY2Nlc3NLZXksIHB1YmxpY19rZXk6IFB1YmxpY0tleVxcfSBpdGVtc1xuICAgICAqIEBwYXJhbSByZWNlaXZlcklkIFRoZSBORUFSIGFjY291bnQgYXR0ZW1wdGluZyB0byBoYXZlIGFjY2Vzc1xuICAgICAqIEBwYXJhbSBhY3Rpb25zIFRoZSBhY3Rpb24ocykgbmVlZGVkIHRvIGJlIGNoZWNrZWQgZm9yIGFjY2Vzc1xuICAgICAqL1xuICAgIGFjY2Vzc0tleU1hdGNoZXNUcmFuc2FjdGlvbihhY2Nlc3NLZXksIHJlY2VpdmVySWQsIGFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjZXNzX2tleTogeyBwZXJtaXNzaW9uIH0gfSA9IGFjY2Vzc0tleTtcbiAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uID09PSAnRnVsbEFjY2VzcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uLkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVjZWl2ZXJfaWQ6IGFsbG93ZWRSZWNlaXZlcklkLCBtZXRob2RfbmFtZXM6IGFsbG93ZWRNZXRob2RzIH0gPSBwZXJtaXNzaW9uLkZ1bmN0aW9uQ2FsbDtcbiAgICAgICAgICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAgICBBY2NlcHQgbXVsdGlzaWcgYWNjZXNzIGtleXMgYW5kIGxldCB3YWxsZXRzIGF0dGVtcHQgdG8gc2lnbkFuZFNlbmRUcmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIElmIGFuIGFjY2VzcyBrZXkgaGFzIGl0c2VsZiBhcyByZWNlaXZlcklkIGFuZCBtZXRob2QgcGVybWlzc2lvbiBhZGRfcmVxdWVzdF9hbmRfY29uZmlybSwgdGhlbiBpdCBpcyBiZWluZyB1c2VkIGluIGEgd2FsbGV0IHdpdGggbXVsdGlzaWcgY29udHJhY3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL2NvcmUtY29udHJhY3RzL2Jsb2IvNjcxYzA1ZjA5YWJlY2FiZTdhN2U1OGVmZTk0MjU1MGEzNWZjMzI5Mi9tdWx0aXNpZy9zcmMvbGliLnJzI0wxNDktTDE1M1xuICAgICAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd2VkUmVjZWl2ZXJJZCA9PT0gdGhpcy5hY2NvdW50SWQgJiYgYWxsb3dlZE1ldGhvZHMuaW5jbHVkZXMoTVVMVElTSUdfSEFTX01FVEhPRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd2VkUmVjZWl2ZXJJZCA9PT0gcmVjZWl2ZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9ucy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbeyBmdW5jdGlvbkNhbGwgfV0gPSBhY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWZ1bmN0aW9uQ2FsbC5kZXBvc2l0IHx8IGZ1bmN0aW9uQ2FsbC5kZXBvc2l0LnRvU3RyaW5nKCkgPT09ICcwJykgJiYgLy8gVE9ETzogU2hvdWxkIHN1cHBvcnQgY2hhcmdpbmcgYW1vdW50IHNtYWxsZXIgdGhhbiBhbGxvd2FuY2U/XG4gICAgICAgICAgICAgICAgICAgICAgICAoYWxsb3dlZE1ldGhvZHMubGVuZ3RoID09PSAwIHx8IGFsbG93ZWRNZXRob2RzLmluY2x1ZGVzKGZ1bmN0aW9uQ2FsbC5tZXRob2ROYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSBjYXNlcyB3aGVuIGFsbG93YW5jZSBkb2Vzbid0IGhhdmUgZW5vdWdoIHRvIHBheSBmb3IgZ2FzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogU3VwcG9ydCBvdGhlciBwZXJtaXNzaW9ucyB0aGFuIEZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgYWNjZXNzIGtleSAoaWYgaXQgZXhpc3RzKSB0byB0aGUgcmVjZWl2ZXIgdGhhdCBncmFudHMgdGhlIGRlc2lnbmF0ZWQgcGVybWlzc2lvblxuICAgICAqIEBwYXJhbSByZWNlaXZlcklkIFRoZSBORUFSIGFjY291bnQgc2Vla2luZyB0aGUgYWNjZXNzIGtleSBmb3IgYSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBhY3Rpb25zIFRoZSBhY3Rpb24ocykgc291Z2h0IHRvIGdhaW4gYWNjZXNzIHRvXG4gICAgICogQHBhcmFtIGxvY2FsS2V5IEEgbG9jYWwgcHVibGljIGtleSBwcm92aWRlZCB0byBjaGVjayBmb3IgYWNjZXNzXG4gICAgICovXG4gICAgYWNjZXNzS2V5Rm9yVHJhbnNhY3Rpb24ocmVjZWl2ZXJJZCwgYWN0aW9ucywgbG9jYWxLZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleXMgPSB5aWVsZCB0aGlzLmdldEFjY2Vzc0tleXMoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IGFjY2Vzc0tleXMuZmluZChrZXkgPT4ga2V5LnB1YmxpY19rZXkudG9TdHJpbmcoKSA9PT0gbG9jYWxLZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjY2Vzc0tleSAmJiAoeWllbGQgdGhpcy5hY2Nlc3NLZXlNYXRjaGVzVHJhbnNhY3Rpb24oYWNjZXNzS2V5LCByZWNlaXZlcklkLCBhY3Rpb25zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc0tleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRLZXlzID0gdGhpcy53YWxsZXRDb25uZWN0aW9uLl9hdXRoRGF0YS5hbGxLZXlzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY2Nlc3NLZXkgb2YgYWNjZXNzS2V5cykge1xuICAgICAgICAgICAgICAgIGlmICh3YWxsZXRLZXlzLmluZGV4T2YoYWNjZXNzS2V5LnB1YmxpY19rZXkpICE9PSAtMSAmJiAoeWllbGQgdGhpcy5hY2Nlc3NLZXlNYXRjaGVzVHJhbnNhY3Rpb24oYWNjZXNzS2V5LCByZWNlaXZlcklkLCBhY3Rpb25zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc0tleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0ZWRXYWxsZXRBY2NvdW50ID0gQ29ubmVjdGVkV2FsbGV0QWNjb3VudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/near-api-js/lib/wallet-account.js\n");

/***/ })

};
;